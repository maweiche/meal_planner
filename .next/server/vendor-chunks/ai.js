"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/shared-client/streamable.tsx\n\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/shared-client/streamable.tsx\nfunction hasReadableValueSignature(value) {\n    return !!(value && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE);\n}\nfunction assertStreamableValue(value) {\n    if (!hasReadableValueSignature(value)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n}\nfunction isStreamableValue(value) {\n    const hasSignature = hasReadableValueSignature(value);\n    if (!hasSignature && typeof value !== \"undefined\") {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction readStreamableValue(streamableValue) {\n    assertStreamableValue(streamableValue);\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let curr = row.curr;\n            let done = false;\n            let initial = true;\n            return {\n                async next () {\n                    if (done) return {\n                        value: curr,\n                        done: true\n                    };\n                    row = await row;\n                    if (typeof row.error !== \"undefined\") {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            switch(row.diff[0]){\n                                case 0:\n                                    if (typeof curr !== \"string\") {\n                                        throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                    } else {\n                                        curr = curr + row.diff[1];\n                                    }\n                                    break;\n                            }\n                        } else {\n                            curr = row.curr;\n                        }\n                        if (!row.next) {\n                            done = true;\n                            return {\n                                value: curr,\n                                done: false\n                            };\n                        }\n                    }\n                    if (!row.next) {\n                        return {\n                            value: curr,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (initial) {\n                        initial = false;\n                        if (typeof curr === \"undefined\") {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value: curr,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!isStreamableValue(streamableValue)) return;\n        let cancelled = false;\n        const iterator = readStreamableValue(streamableValue);\n        if (streamableValue.next) {\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                if (cancelled) return;\n                setPending(true);\n            });\n        }\n        (async ()=>{\n            try {\n                for await (const value of iterator){\n                    if (cancelled) return;\n                    (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                        if (cancelled) return;\n                        setCurr(value);\n                    });\n                }\n            } catch (e) {\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setError(e);\n                });\n            } finally{\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setPending(false);\n                });\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// rsc/utils.tsx\n\n\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nvar isFunction = (x)=>typeof x === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (resolvedInitialAIStatePatch) {\n            return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n        }\n        return initialAIState;\n    }, [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        aiStateRef.current = aiState[0];\n    }, [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.fromEntries(Object.entries(wrappedActions).map(([key, action])=>[\n                key,\n                async (...args)=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                    (async ()=>{\n                        const delta = await aiStateDelta;\n                        if (delta !== void 0) {\n                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                        }\n                    })();\n                    return result;\n                }\n            ])), [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!wrappedSyncUIState) {\n            return ()=>{};\n        }\n        return async ()=>{\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n            if (uiState2 !== void 0) {\n                setUIState(uiState2);\n            }\n            const delta = await aiStateDelta;\n            if (delta !== void 0) {\n                const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                setAIState(patchedAiState);\n            }\n        };\n    }, [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : (newState)=>{\n        if (isFunction(newState)) {\n            return state[1]((s)=>{\n                return {\n                    ...s,\n                    [key]: newState(s[key])\n                };\n            });\n        } else {\n            return state[1]({\n                ...state[0],\n                [key]: newState\n            });\n        }\n    }, [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNoYXJlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTJEOztBQ0FwRCxJQUFNRyx3QkFBd0JDLE9BQU9DLEdBQUEsQ0FBSTtBQUN6QyxJQUFNQyxzQ0FBc0MsS0FBSzs7QURHeEQsU0FBU0MsMEJBQTBCQyxLQUFBO0lBQ2pDLE9BQU8sQ0FBQyxDQUNOQSxDQUFBQSxTQUNBLE9BQU9BLFVBQVUsWUFDakIsVUFBVUEsU0FDVkEsTUFBTUMsSUFBQSxLQUFTTixxQkFBQTtBQUVuQjtBQUVBLFNBQVNPLHNCQUNQRixLQUFBO0lBRUEsSUFBSSxDQUFDRCwwQkFBMEJDLFFBQVE7UUFDckMsTUFBTSxJQUFJRyxNQUNSO0lBRUo7QUFDRjtBQUVBLFNBQVNDLGtCQUFrQkosS0FBQTtJQUN6QixNQUFNSyxlQUFlTiwwQkFBMEJDO0lBRS9DLElBQUksQ0FBQ0ssZ0JBQWdCLE9BQU9MLFVBQVUsYUFBYTtRQUNqRCxNQUFNLElBQUlHLE1BQ1I7SUFFSjtJQUVBLE9BQU9FO0FBQ1Q7QUFnQ08sU0FBU0Msb0JBQ2RDLGVBQUE7SUFFQUwsc0JBQXNCSztJQUV0QixPQUFPO1FBQ0wsQ0FBQ1gsT0FBT1ksYUFBYTtZQUNuQixJQUFJQyxNQUNGRjtZQUNGLElBQUlHLE9BQU9ELElBQUlDLElBQUE7WUFDZixJQUFJQyxPQUFPO1lBQ1gsSUFBSUMsVUFBVTtZQUVkLE9BQU87Z0JBQ0wsTUFBTUM7b0JBQ0osSUFBSUYsTUFBTSxPQUFPO3dCQUFFWCxPQUFPVTt3QkFBTUMsTUFBTTtvQkFBSztvQkFFM0NGLE1BQU0sTUFBTUE7b0JBRVosSUFBSSxPQUFPQSxJQUFJSyxLQUFBLEtBQVUsYUFBYTt3QkFDcEMsTUFBTUwsSUFBSUssS0FBQTtvQkFDWjtvQkFDQSxJQUFJLFVBQVVMLE9BQU9BLElBQUlNLElBQUEsRUFBTTt3QkFDN0IsSUFBSU4sSUFBSU0sSUFBQSxFQUFNOzRCQUNaLE9BQVFOLElBQUlNLElBQUEs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QUFBLENBQ25CLE9BQU82QixRQUFRLGNBQ1hXLEtBQUEsQ0FBTSxFQUFDLEdBQ1AsQ0FBQ1E7UUFDQyxJQUFJbkQsV0FBV21ELFdBQVc7WUFDeEIsT0FBT1IsS0FBQSxDQUFNLEVBQUMsQ0FBRSxDQUFBUztnQkFDZCxPQUFPO29CQUFFLEdBQUdBLENBQUE7b0JBQUcsQ0FBQ3BCLElBQUcsRUFBR21CLFNBQVNDLENBQUEsQ0FBRXBCLElBQUk7Z0JBQUU7WUFDekM7UUFDRixPQUFPO1lBQ0wsT0FBT1csS0FBQSxDQUFNLEVBQUMsQ0FBRTtnQkFBRSxHQUFHQSxLQUFBLENBQU0sRUFBQztnQkFBRyxDQUFDWCxJQUFHLEVBQUdtQjtZQUFTO1FBQ2pEO0lBQ0YsR0FDSjtRQUFDbkI7S0FBRztJQUdOLElBQUlFLEtBQUtjLE1BQUEsS0FBVyxHQUFHO1FBQ3JCLE9BQU9MO0lBQ1QsT0FBTztRQUNMLE9BQU87WUFBQ0EsS0FBQSxDQUFNLEVBQUMsQ0FBRVQsSUFBQSxDQUFLLEVBQUU7WUFBR2U7U0FBTTtJQUNuQztBQUNGO0FBRU8sU0FBU0k7SUFHZCxNQUFNQyxVQUFnQm5ELDZDQUFBLENBQWNHO0lBQ3BDLE9BQU9nRDtBQUNUO0FBRU8sU0FBU0M7SUFDZCxNQUFNQyxjQUFvQnJELDZDQUFBLENBQ3hCSTtJQUdGLElBQUlpRCxnQkFBZ0IsTUFBTTtRQUN4QixNQUFNLElBQUkxRixNQUFNO0lBQ2xCO0lBRUEsT0FBTzBGO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc2hhcmVkLWNsaWVudC9zdHJlYW1hYmxlLnRzeD9lMThiIiwid2VicGFjazovLy8uLi9jb25zdGFudHMudHM/YWI3MiIsIndlYnBhY2s6Ly8vLi4vc2hhcmVkLWNsaWVudC9jb250ZXh0LnRzeD9jYjNmIiwid2VicGFjazovLy8uLi91dGlscy50c3g/N2EyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24sIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHR5cGUgeyBTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmZ1bmN0aW9uIGhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBTdHJlYW1hYmxlVmFsdWUge1xuICByZXR1cm4gISEoXG4gICAgdmFsdWUgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgJ3R5cGUnIGluIHZhbHVlICYmXG4gICAgdmFsdWUudHlwZSA9PT0gU1RSRUFNQUJMRV9WQUxVRV9UWVBFXG4gICk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmVhbWFibGVWYWx1ZShcbiAgdmFsdWU6IHVua25vd24sXG4pOiBhc3NlcnRzIHZhbHVlIGlzIFN0cmVhbWFibGVWYWx1ZSB7XG4gIGlmICghaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCB2YWx1ZTogdGhpcyBob29rIG9ubHkgYWNjZXB0cyB2YWx1ZXMgY3JlYXRlZCB2aWEgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZWAuJyxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RyZWFtYWJsZVZhbHVlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU3RyZWFtYWJsZVZhbHVlIHtcbiAgY29uc3QgaGFzU2lnbmF0dXJlID0gaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSh2YWx1ZSk7XG5cbiAgaWYgKCFoYXNTaWduYXR1cmUgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHZhbHVlOiB0aGlzIGhvb2sgb25seSBhY2NlcHRzIHZhbHVlcyBjcmVhdGVkIHZpYSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlYC4nLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gaGFzU2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0YWtlcyBhIHN0cmVhbWFibGUgdmFsdWUgY3JlYXRlZCB2aWEgdGhlIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoKS52YWx1ZWAgQVBJLFxuICogYW5kIHJldHVybnMgYW4gYXN5bmMgaXRlcmF0b3IuXG4gKlxuICogYGBganNcbiAqIC8vIEluc2lkZSB5b3VyIEFJIGFjdGlvbjpcbiAqXG4gKiBhc3luYyBmdW5jdGlvbiBhY3Rpb24oKSB7XG4gKiAgICd1c2Ugc2VydmVyJ1xuICogICBjb25zdCBzdHJlYW1hYmxlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCk7XG4gKlxuICogICBzdHJlYW1hYmxlLnVwZGF0ZSgxKTtcbiAqICAgc3RyZWFtYWJsZS51cGRhdGUoMik7XG4gKiAgIHN0cmVhbWFibGUuZG9uZSgzKTtcbiAqICAgLy8gLi4uXG4gKiAgIHJldHVybiBzdHJlYW1hYmxlLnZhbHVlO1xuICogfVxuICogYGBgXG4gKlxuICogQW5kIHRvIHJlYWQgdGhlIHZhbHVlOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBzdHJlYW1hYmxlVmFsdWUgPSBhd2FpdCBhY3Rpb24oKVxuICogZm9yIGF3YWl0IChjb25zdCB2IG9mIHJlYWRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSkge1xuICogICBjb25zb2xlLmxvZyh2KVxuICogfVxuICogYGBgXG4gKlxuICogVGhpcyBsb2dzIG91dCAxLCAyLCAzIG9uIGNvbnNvbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3RyZWFtYWJsZVZhbHVlPFQgPSB1bmtub3duPihcbiAgc3RyZWFtYWJsZVZhbHVlOiBTdHJlYW1hYmxlVmFsdWU8VD4sXG4pOiBBc3luY0l0ZXJhYmxlPFQgfCB1bmRlZmluZWQ+IHtcbiAgYXNzZXJ0U3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgbGV0IHJvdzogU3RyZWFtYWJsZVZhbHVlPFQ+IHwgUHJvbWlzZTxTdHJlYW1hYmxlVmFsdWU8VD4+ID1cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlO1xuICAgICAgbGV0IGN1cnIgPSByb3cuY3VycjtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICBsZXQgaW5pdGlhbCA9IHRydWU7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybiB7IHZhbHVlOiBjdXJyLCBkb25lOiB0cnVlIH07XG5cbiAgICAgICAgICByb3cgPSBhd2FpdCByb3c7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHJvdy5lcnJvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IHJvdy5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdjdXJyJyBpbiByb3cgfHwgcm93LmRpZmYpIHtcbiAgICAgICAgICAgIGlmIChyb3cuZGlmZikge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHJvdy5kaWZmWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgcGF0Y2g6IGNhbiBvbmx5IGFwcGVuZCB0byBzdHJpbmcgdHlwZXMuIFRoaXMgaXMgYSBidWcgaW4gdGhlIEFJIFNESy4nLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKGN1cnIgYXMgc3RyaW5nKSA9IGN1cnIgKyByb3cuZGlmZlsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyID0gcm93LmN1cnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IGVtaXR0ZWQgeyBkb25lOiB0cnVlIH0gd29uJ3QgYmUgdXNlZCBhcyB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBmb3IgYXdhaXQuLi5vZiBzeW50YXguXG4gICAgICAgICAgICBpZiAoIXJvdy5uZXh0KSB7XG4gICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyLFxuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcm93Lm5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBjdXJyLFxuICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgPSByb3cubmV4dDtcbiAgICAgICAgICBpZiAoaW5pdGlhbCkge1xuICAgICAgICAgICAgaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBpbml0aWFsIGNodW5rIGFuZCB0aGVyZSBpc24ndCBhbiBpbml0aWFsIHZhbHVlIHlldC5cbiAgICAgICAgICAgICAgLy8gTGV0J3Mgc2tpcCB0aGlzIG9uZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogY3VycixcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogYHVzZVN0cmVhbWFibGVWYWx1ZWAgaXMgYSBSZWFjdCBob29rIHRoYXQgdGFrZXMgYSBzdHJlYW1hYmxlIHZhbHVlIGNyZWF0ZWQgdmlhIHRoZSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCkudmFsdWVgIEFQSSxcbiAqIGFuZCByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlLCBlcnJvciwgYW5kIHBlbmRpbmcgc3RhdGUuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbnN1bWluZyBzdHJlYW1hYmxlIHZhbHVlcyByZWNlaXZlZCBmcm9tIGEgY29tcG9uZW50J3MgcHJvcHMuIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBNeUNvbXBvbmVudCh7IHN0cmVhbWFibGVWYWx1ZSB9KSB7XG4gKiAgIGNvbnN0IFtkYXRhLCBlcnJvciwgcGVuZGluZ10gPSB1c2VTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKTtcbiAqXG4gKiAgIGlmIChwZW5kaW5nKSByZXR1cm4gPGRpdj5Mb2FkaW5nLi4uPC9kaXY+O1xuICogICBpZiAoZXJyb3IpIHJldHVybiA8ZGl2PkVycm9yOiB7ZXJyb3IubWVzc2FnZX08L2Rpdj47XG4gKlxuICogICByZXR1cm4gPGRpdj5EYXRhOiB7ZGF0YX08L2Rpdj47XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0cmVhbWFibGVWYWx1ZTxUID0gdW5rbm93biwgRXJyb3IgPSB1bmtub3duPihcbiAgc3RyZWFtYWJsZVZhbHVlPzogU3RyZWFtYWJsZVZhbHVlPFQ+LFxuKTogW2RhdGE6IFQgfCB1bmRlZmluZWQsIGVycm9yOiBFcnJvciB8IHVuZGVmaW5lZCwgcGVuZGluZzogYm9vbGVhbl0ge1xuICBjb25zdCBbY3Vyciwgc2V0Q3Vycl0gPSB1c2VTdGF0ZTxUIHwgdW5kZWZpbmVkPihcbiAgICBpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gc3RyZWFtYWJsZVZhbHVlLmN1cnIgOiB1bmRlZmluZWQsXG4gICk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8RXJyb3IgfCB1bmRlZmluZWQ+KFxuICAgIGlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkgPyBzdHJlYW1hYmxlVmFsdWUuZXJyb3IgOiB1bmRlZmluZWQsXG4gICk7XG4gIGNvbnN0IFtwZW5kaW5nLCBzZXRQZW5kaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KFxuICAgIGlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkgPyAhIXN0cmVhbWFibGVWYWx1ZS5uZXh0IDogZmFsc2UsXG4gICk7XG5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkpIHJldHVybjtcblxuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gcmVhZFN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuICAgIGlmIChzdHJlYW1hYmxlVmFsdWUubmV4dCkge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzZXRQZW5kaW5nKHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHNldEN1cnIodmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgc2V0RXJyb3IoZSBhcyBFcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gIH0sIFtzdHJlYW1hYmxlVmFsdWVdKTtcblxuICByZXR1cm4gW2N1cnIsIGVycm9yLCBwZW5kaW5nXTtcbn1cbiIsImV4cG9ydCBjb25zdCBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUgPSBTeW1ib2wuZm9yKCd1aS5zdHJlYW1hYmxlLnZhbHVlJyk7XG5leHBvcnQgY29uc3QgREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUgPSAxNSAqIDEwMDA7XG4iLCIndXNlIGNsaWVudCc7XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0ICogYXMganNvbmRpZmZwYXRjaCBmcm9tICdqc29uZGlmZnBhdGNoJztcbmltcG9ydCB0eXBlIHtcbiAgSW50ZXJuYWxBSVByb3ZpZGVyUHJvcHMsXG4gIEFJUHJvdmlkZXIsXG4gIEluZmVyQUlTdGF0ZSxcbiAgVmFsdWVPclVwZGF0ZXIsXG4gIEluZmVyQWN0aW9ucyxcbiAgSW5mZXJVSVN0YXRlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBJbnRlcm5hbFVJU3RhdGVQcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8bnVsbCB8IGFueT4obnVsbCk7XG5jb25zdCBJbnRlcm5hbEFJU3RhdGVQcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8dW5kZWZpbmVkIHwgYW55Pih1bmRlZmluZWQpO1xuY29uc3QgSW50ZXJuYWxBY3Rpb25Qcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8bnVsbCB8IGFueT4obnVsbCk7XG5jb25zdCBJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gSW50ZXJuYWxBSVByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxVSVN0YXRlLFxuICBpbml0aWFsQUlTdGF0ZSxcbiAgaW5pdGlhbEFJU3RhdGVQYXRjaCxcbiAgd3JhcHBlZEFjdGlvbnMsXG4gIHdyYXBwZWRTeW5jVUlTdGF0ZSxcbn06IEludGVybmFsQUlQcm92aWRlclByb3BzKSB7XG4gIGlmICghKCd1c2UnIGluIFJlYWN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUmVhY3QgdmVyc2lvbi4nKTtcbiAgfVxuXG4gIGNvbnN0IHVpU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsVUlTdGF0ZSk7XG4gIGNvbnN0IHNldFVJU3RhdGUgPSB1aVN0YXRlWzFdO1xuXG4gIGNvbnN0IHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCA9IGluaXRpYWxBSVN0YXRlUGF0Y2hcbiAgICA/IChSZWFjdCBhcyBhbnkpLnVzZShpbml0aWFsQUlTdGF0ZVBhdGNoKVxuICAgIDogdW5kZWZpbmVkO1xuICBpbml0aWFsQUlTdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2gpIHtcbiAgICAgIHJldHVybiBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGluaXRpYWxBSVN0YXRlKSxcbiAgICAgICAgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxBSVN0YXRlO1xuICB9LCBbaW5pdGlhbEFJU3RhdGUsIHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaF0pO1xuXG4gIGNvbnN0IGFpU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShpbml0aWFsQUlTdGF0ZSk7XG4gIGNvbnN0IHNldEFJU3RhdGUgPSBhaVN0YXRlWzFdO1xuICBjb25zdCBhaVN0YXRlUmVmID0gUmVhY3QudXNlUmVmKGFpU3RhdGVbMF0pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYWlTdGF0ZVJlZi5jdXJyZW50ID0gYWlTdGF0ZVswXTtcbiAgfSwgW2FpU3RhdGVbMF1dKTtcblxuICBjb25zdCBjbGllbnRXcmFwcGVkQWN0aW9ucyA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMod3JhcHBlZEFjdGlvbnMpLm1hcCgoW2tleSwgYWN0aW9uXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBhc3luYyAoLi4uYXJnczogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhaVN0YXRlU25hcHNob3QgPSBhaVN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBjb25zdCBbYWlTdGF0ZURlbHRhLCByZXN1bHRdID0gYXdhaXQgYWN0aW9uKFxuICAgICAgICAgICAgICBhaVN0YXRlU25hcHNob3QsXG4gICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBhd2FpdCBhaVN0YXRlRGVsdGE7XG4gICAgICAgICAgICAgIGlmIChkZWx0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWlTdGF0ZVsxXShcbiAgICAgICAgICAgICAgICAgIGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgICAgICAgICAgICAgIGpzb25kaWZmcGF0Y2guY2xvbmUoYWlTdGF0ZVNuYXBzaG90KSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0sXG4gICAgICAgIF0pLFxuICAgICAgKSxcbiAgICBbd3JhcHBlZEFjdGlvbnNdLFxuICApO1xuXG4gIGNvbnN0IGNsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghd3JhcHBlZFN5bmNVSVN0YXRlKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFpU3RhdGVTbmFwc2hvdCA9IGFpU3RhdGVSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IFthaVN0YXRlRGVsdGEsIHVpU3RhdGVdID0gYXdhaXQgd3JhcHBlZFN5bmNVSVN0YXRlIShcbiAgICAgICAgYWlTdGF0ZVNuYXBzaG90LFxuICAgICAgKTtcblxuICAgICAgaWYgKHVpU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRVSVN0YXRlKHVpU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWx0YSA9IGF3YWl0IGFpU3RhdGVEZWx0YTtcbiAgICAgIGlmIChkZWx0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHBhdGNoZWRBaVN0YXRlID0ganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGFpU3RhdGVTbmFwc2hvdCksXG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICk7XG4gICAgICAgIHNldEFJU3RhdGUocGF0Y2hlZEFpU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt3cmFwcGVkU3luY1VJU3RhdGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxJbnRlcm5hbEFJU3RhdGVQcm92aWRlci5Qcm92aWRlciB2YWx1ZT17YWlTdGF0ZX0+XG4gICAgICA8SW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXIgdmFsdWU9e3VpU3RhdGV9PlxuICAgICAgICA8SW50ZXJuYWxBY3Rpb25Qcm92aWRlci5Qcm92aWRlciB2YWx1ZT17Y2xpZW50V3JhcHBlZEFjdGlvbnN9PlxuICAgICAgICAgIDxJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXJcbiAgICAgICAgICAgIHZhbHVlPXtjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb259XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgIDwvSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICAgICAgICA8L0ludGVybmFsQWN0aW9uUHJvdmlkZXIuUHJvdmlkZXI+XG4gICAgICA8L0ludGVybmFsVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICAgIDwvSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VVSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKSB7XG4gIHR5cGUgVCA9IEluZmVyVUlTdGF0ZTxBSSwgYW55PjtcblxuICBjb25zdCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8XG4gICAgW1QsICh2OiBUIHwgKCh2XzogVCkgPT4gVCkpID0+IHZvaWRdIHwgbnVsbCB8IHVuZGVmaW5lZFxuICA+KEludGVybmFsVUlTdGF0ZVByb3ZpZGVyKTtcbiAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlVUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICBpZiAoc3RhdGVbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgaW5pdGlhbFVJU3RhdGVgIG11c3QgYmUgcHJvdmlkZWQgdG8gYGNyZWF0ZUFJYCBvciBgPEFJPmAnLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vLyBUT0RPOiBIb3cgZG8gd2UgYXZvaWQgY2F1c2luZyBhIHJlLXJlbmRlciB3aGVuIHRoZSBBSSBzdGF0ZSBjaGFuZ2VzIGJ1dCB5b3Vcbi8vIGFyZSBvbmx5IGxpc3RlbmluZyB0byBhIHNwZWNpZmljIGtleT8gV2UgbmVlZCB1c2VTRVMgcGVyaGFwcz9cbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBbXG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55PixcbiAgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxJbmZlckFJU3RhdGU8QUksIGFueT4+KSA9PiB2b2lkLFxuXTtcbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAga2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4pOiBbXG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XSxcbiAgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0+KSA9PiB2b2lkLFxuXTtcbmZ1bmN0aW9uIHVzZUFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAgLi4uYXJnczogW10gfCBba2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIHR5cGUgVCA9IEluZmVyQUlTdGF0ZTxBSSwgYW55PjtcblxuICBjb25zdCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8XG4gICAgW1QsIChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8VD4pID0+IHZvaWRdIHwgbnVsbCB8IHVuZGVmaW5lZFxuICA+KEludGVybmFsQUlTdGF0ZVByb3ZpZGVyKTtcbiAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlQUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICBpZiAoc3RhdGVbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgaW5pdGlhbEFJU3RhdGVgIG11c3QgYmUgcHJvdmlkZWQgdG8gYGNyZWF0ZUFJYCBvciBgPEFJPmAnLFxuICAgICk7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoID49IDEgJiYgdHlwZW9mIHN0YXRlWzBdICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdXaGVuIHVzaW5nIGB1c2VBSVN0YXRlYCB3aXRoIGEga2V5LCB0aGUgQUkgc3RhdGUgbXVzdCBiZSBhbiBvYmplY3QuJyxcbiAgICApO1xuICB9XG5cbiAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgY29uc3Qgc2V0dGVyID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgdHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gc3RhdGVbMV1cbiAgICAgIDogKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxUPikgPT4ge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG5ld1N0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlWzFdKHMgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4geyAuLi5zLCBba2V5XTogbmV3U3RhdGUoc1trZXldKSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZVsxXSh7IC4uLnN0YXRlWzBdLCBba2V5XTogbmV3U3RhdGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIFtrZXldLFxuICApO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3N0YXRlWzBdW2FyZ3NbMF1dLCBzZXR0ZXJdO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3Rpb25zPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKSB7XG4gIHR5cGUgVCA9IEluZmVyQWN0aW9uczxBSSwgYW55PjtcblxuICBjb25zdCBhY3Rpb25zID0gUmVhY3QudXNlQ29udGV4dDxUPihJbnRlcm5hbEFjdGlvblByb3ZpZGVyKTtcbiAgcmV0dXJuIGFjdGlvbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTeW5jVUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3luY1VJU3RhdGUgPSBSZWFjdC51c2VDb250ZXh0PCgpID0+IFByb21pc2U8dm9pZD4+KFxuICAgIEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlcixcbiAgKTtcblxuICBpZiAoc3luY1VJU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VTeW5jVUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLicpO1xuICB9XG5cbiAgcmV0dXJuIHN5bmNVSVN0YXRlO1xufVxuXG5leHBvcnQgeyB1c2VBSVN0YXRlIH07XG4iLCJpbXBvcnQgUmVhY3QsIHsgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTxUID0gYW55PigpIHtcbiAgbGV0IHJlc29sdmU6ICh2YWx1ZTogVCkgPT4gdm9pZCwgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWQ7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlOiByZXNvbHZlISxcbiAgICByZWplY3Q6IHJlamVjdCEsXG4gIH07XG59XG5cbi8vIFVzZSB0aGUgbmFtZSBgUmAgZm9yIGBSb3dgIGFzIGl0IHdpbGwgYmUgc2hvcnRlciBpbiB0aGUgUlNDIHBheWxvYWQuXG5jb25zdCBSID0gW1xuICAoYXN5bmMgKHtcbiAgICBjLCAvLyBjdXJyZW50XG4gICAgbiwgLy8gbmV4dFxuICB9OiB7XG4gICAgYzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG46IFByb21pc2U8YW55PjtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGNodW5rID0gYXdhaXQgbjtcbiAgICBpZiAoY2h1bmsuZG9uZSkge1xuICAgICAgcmV0dXJuIGNodW5rLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChjaHVuay5hcHBlbmQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAge2N9XG4gICAgICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtjaHVuay52YWx1ZX0+XG4gICAgICAgICAgICA8UiBjPXtjaHVuay52YWx1ZX0gbj17Y2h1bmsubmV4dH0gLz5cbiAgICAgICAgICA8L1N1c3BlbnNlPlxuICAgICAgICA8Lz5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17Y2h1bmsudmFsdWV9PlxuICAgICAgICA8UiBjPXtjaHVuay52YWx1ZX0gbj17Y2h1bmsubmV4dH0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgKTtcbiAgfSkgYXMgdW5rbm93biBhcyBSZWFjdC5GQzx7XG4gICAgYzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG46IFByb21pc2U8YW55PjtcbiAgfT4sXG5dWzBdO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VkQ2h1bmsoaW5pdGlhbFZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgcmV0dXJuIHtcbiAgICByb3c6IChcbiAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17aW5pdGlhbFZhbHVlfT5cbiAgICAgICAgPFIgYz17aW5pdGlhbFZhbHVlfSBuPXtwcm9taXNlfSAvPlxuICAgICAgPC9TdXNwZW5zZT5cbiAgICApLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0LFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9ICh4OiB1bmtub3duKTogeCBpcyBGdW5jdGlvbiA9PlxuICB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcblxuZXhwb3J0IGNvbnN0IGNvbnN1bWVTdHJlYW0gPSBhc3luYyAoc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSkgPT4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSBicmVhaztcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJzdGFydFRyYW5zaXRpb24iLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VTdGF0ZSIsIlNUUkVBTUFCTEVfVkFMVUVfVFlQRSIsIlN5bWJvbCIsImZvciIsIkRFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FIiwiaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSIsInZhbHVlIiwidHlwZSIsImFzc2VydFN0cmVhbWFibGVWYWx1ZSIsIkVycm9yIiwiaXNTdHJlYW1hYmxlVmFsdWUiLCJoYXNTaWduYXR1cmUiLCJyZWFkU3RyZWFtYWJsZVZhbHVlIiwic3RyZWFtYWJsZVZhbHVlIiwiYXN5bmNJdGVyYXRvciIsInJvdyIsImN1cnIiLCJkb25lIiwiaW5pdGlhbCIsIm5leHQiLCJlcnJvciIsImRpZmYiLCJ1c2VTdHJlYW1hYmxlVmFsdWUiLCJzZXRDdXJyIiwic2V0RXJyb3IiLCJwZW5kaW5nIiwic2V0UGVuZGluZyIsImNhbmNlbGxlZCIsIml0ZXJhdG9yIiwiZSIsIlJlYWN0IiwianNvbmRpZmZwYXRjaCIsIlN1c3BlbnNlIiwiRnJhZ21lbnQiLCJqc3giLCJqc3hzIiwiUiIsImMiLCJuIiwiY2h1bmsiLCJhcHBlbmQiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwiaXNGdW5jdGlvbiIsIngiLCJJbnRlcm5hbFVJU3RhdGVQcm92aWRlciIsIlJlYWN0MiIsImNyZWF0ZUNvbnRleHQiLCJJbnRlcm5hbEFJU3RhdGVQcm92aWRlciIsIkludGVybmFsQWN0aW9uUHJvdmlkZXIiLCJJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIiLCJJbnRlcm5hbEFJUHJvdmlkZXIiLCJpbml0aWFsVUlTdGF0ZSIsImluaXRpYWxBSVN0YXRlIiwiaW5pdGlhbEFJU3RhdGVQYXRjaCIsIndyYXBwZWRBY3Rpb25zIiwid3JhcHBlZFN5bmNVSVN0YXRlIiwidWlTdGF0ZSIsInNldFVJU3RhdGUiLCJyZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2giLCJ1c2UiLCJ1c2VNZW1vIiwicGF0Y2giLCJjbG9uZSIsImFpU3RhdGUiLCJzZXRBSVN0YXRlIiwiYWlTdGF0ZVJlZiIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJjbGllbnRXcmFwcGVkQWN0aW9ucyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm1hcCIsImtleSIsImFjdGlvbiIsImFyZ3MiLCJhaVN0YXRlU25hcHNob3QiLCJhaVN0YXRlRGVsdGEiLCJyZXN1bHQiLCJkZWx0YSIsImNsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbiIsInBhdGNoZWRBaVN0YXRlIiwiUHJvdmlkZXIiLCJ1c2VVSVN0YXRlIiwic3RhdGUiLCJ1c2VDb250ZXh0IiwiQXJyYXkiLCJpc0FycmF5IiwidXNlQUlTdGF0ZSIsImxlbmd0aCIsInNldHRlciIsInVzZUNhbGxiYWNrIiwibmV3U3RhdGUiLCJzIiwidXNlQWN0aW9ucyIsImFjdGlvbnMiLCJ1c2VTeW5jVUlTdGF0ZSIsInN5bmNVSVN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_3___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$ACTION_0: () => (/* binding */ $$ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(rsc)/./node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jsondiffpatch */ \"(rsc)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"784eaeca1c316aa5d98fd936c53125000c396aeb\":\"$$ACTION_0\"} */ \n\n\n\n// rsc/utils.tsx\n\n\nfunction createResolvablePromise() {\n    let resolve, reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspensedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\nvar isFunction = (x)=>typeof x === \"function\";\nvar consumeStream = async (stream)=>{\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n};\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: state1,\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a = store.options).onSetAIState) == null ? void 0 : _b.call(_a, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/streamable.tsx\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.convertBase64ToUint8Array)(content);\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidDataContentError({\n        content\n    });\n}\n// core/prompt/convert-to-language-model-prompt.ts\nfunction convertToLanguageModelPrompt(prompt) {\n    const languageModelMessages = [];\n    if (prompt.system != null) {\n        languageModelMessages.push({\n            role: \"system\",\n            content: prompt.system\n        });\n    }\n    switch(prompt.type){\n        case \"prompt\":\n            {\n                languageModelMessages.push({\n                    role: \"user\",\n                    content: [\n                        {\n                            type: \"text\",\n                            text: prompt.prompt\n                        }\n                    ]\n                });\n                break;\n            }\n        case \"messages\":\n            {\n                languageModelMessages.push(...prompt.messages.map((message)=>{\n                    switch(message.role){\n                        case \"user\":\n                            {\n                                if (typeof message.content === \"string\") {\n                                    return {\n                                        role: \"user\",\n                                        content: [\n                                            {\n                                                type: \"text\",\n                                                text: message.content\n                                            }\n                                        ]\n                                    };\n                                }\n                                return {\n                                    role: \"user\",\n                                    content: message.content.map((part)=>{\n                                        var _a;\n                                        switch(part.type){\n                                            case \"text\":\n                                                {\n                                                    return part;\n                                                }\n                                            case \"image\":\n                                                {\n                                                    if (part.image instanceof URL) {\n                                                        return {\n                                                            type: \"image\",\n                                                            image: part.image,\n                                                            mimeType: part.mimeType\n                                                        };\n                                                    }\n                                                    const imageUint8 = convertDataContentToUint8Array(part.image);\n                                                    return {\n                                                        type: \"image\",\n                                                        image: imageUint8,\n                                                        mimeType: (_a = part.mimeType) != null ? _a : detectImageMimeType(imageUint8)\n                                                    };\n                                                }\n                                        }\n                                    })\n                                };\n                            }\n                        case \"assistant\":\n                            {\n                                if (typeof message.content === \"string\") {\n                                    return {\n                                        role: \"assistant\",\n                                        content: [\n                                            {\n                                                type: \"text\",\n                                                text: message.content\n                                            }\n                                        ]\n                                    };\n                                }\n                                return {\n                                    role: \"assistant\",\n                                    content: message.content\n                                };\n                            }\n                        case \"tool\":\n                            {\n                                return message;\n                            }\n                    }\n                }));\n                break;\n            }\n        default:\n            {\n                const _exhaustiveCheck = prompt;\n                throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n            }\n    }\n    return languageModelMessages;\n}\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    return prompt.prompt != null ? {\n        type: \"prompt\",\n        prompt: prompt.prompt,\n        messages: void 0,\n        system: prompt.system\n    } : {\n        type: \"messages\",\n        prompt: void 0,\n        messages: prompt.messages,\n        // only possible case bc of checks above\n        system: prompt.system\n    };\n}\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({ maxTokens, temperature, topP, presencePenalty, frequencyPenalty, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        presencePenalty,\n        frequencyPenalty,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/util/convert-zod-to-json-schema.ts\n\nfunction convertZodToJSONSchema(zodSchema) {\n    return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(zodSchema);\n}\n// core/util/retry-with-exponential-backoff.ts\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n    return new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n    const streamPart = streamParts.find((part)=>part.name === type);\n    if (!streamPart) {\n        throw new Error(`Invalid stream part type: ${type}`);\n    }\n    return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_9__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a;\n            await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a = choice.delta) == null ? void 0 : _a.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = createChunkDecoder();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode(formatStreamPart(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode(formatStreamPart(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/streamable.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspensedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    return {\n        /**\n     * The value of the streamable UI. This can be returned from a Server Action and received by the client.\n     */ value: row,\n        /**\n     * This method updates the current UI node. It takes a new UI node and replaces the old one.\n     */ update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to append a new UI node to the end of the old one.\n     * Once appended a new UI node, the previous UI node cannot be updated anymore.\n     *\n     * @example\n     * ```jsx\n     * const ui = createStreamableUI(<div>hello</div>)\n     * ui.append(<div>world</div>)\n     *\n     * // The UI node will be:\n     * // <>\n     * //   <div>hello</div>\n     * //   <div>world</div>\n     * // </>\n     * ```\n     */ append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to signal that there is an error in the UI stream.\n     * It will be thrown on the client side and caught by the nearest error boundary component.\n     */ error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n        },\n        /**\n     * This method marks the UI node as finalized. You can either call it without any parameters or with a new UI node as the final state.\n     * Once called, the UI node cannot be updated or appended anymore.\n     *\n     * This method is always **required** to be called, otherwise the response will be stuck in a loading state.\n     */ done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n        }\n    };\n}\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    return {\n        /**\n     * @internal This is an internal lock to prevent the value from being\n     * updated by the user.\n     */ set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        /**\n     * The value of the streamable. This can be returned from a Server Action and\n     * received by the client. To read the streamed values, use the\n     * `readStreamableValue` or `useStreamableValue` APIs.\n     */ get value () {\n            return createWrapped(true);\n        },\n        /**\n     * This method updates the current value with a new one.\n     */ update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to append a delta string to the current value. It\n     * requires the current value of the streamable to be a string.\n     *\n     * @example\n     * ```jsx\n     * const streamable = createStreamableValue('hello');\n     * streamable.append(' world');\n     *\n     * // The value will be 'hello world'\n     * ```\n     */ append (value) {\n            assertStream(\".append()\");\n            if (typeof currentValue !== \"string\" && typeof currentValue !== \"undefined\") {\n                throw new Error(`.append(): The current value is not a string. Received: ${typeof currentValue}`);\n            }\n            if (typeof value !== \"string\") {\n                throw new Error(`.append(): The value is not a string. Received: ${typeof value}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            if (typeof currentValue === \"string\") {\n                currentPatchValue = [\n                    0,\n                    value\n                ];\n                currentValue = currentValue + value;\n            } else {\n                currentPatchValue = void 0;\n                currentValue = value;\n            }\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to signal that there is an error in the value stream.\n     * It will be thrown on the client side when consumed via\n     * `readStreamableValue` or `useStreamableValue`.\n     */ error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n        },\n        /**\n     * This method marks the value as finalized. You can either call it without\n     * any parameters or with a new value as the final state.\n     * Once called, the value cannot be updated or appended anymore.\n     *\n     * This method is always **required** to be called, otherwise the response\n     * will be stuck in a loading state.\n     */ done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return;\n            }\n            resolvable.resolve({});\n        }\n    };\n}\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name, { description, parameters }])=>{\n        return {\n            name,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a = options.functions) == null ? void 0 : _a[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a = options.tools) == null ? void 0 : _a[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, system, prompt, messages, maxRetries, abortSignal, initial, text, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(...args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n    });\n    const result = await retry(()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool])=>({\n                        type: \"function\",\n                        name,\n                        description: tool.description,\n                        parameters: convertZodToJSONSchema(tool.parameters)\n                    }))\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: convertToLanguageModelPrompt(validatedPrompt),\n            abortSignal\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            handleRender([\n                                {\n                                    content,\n                                    done: false,\n                                    delta: value.textDelta\n                                }\n                            ], textRender, ui);\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            handleRender([\n                                parseResult.value,\n                                {\n                                    toolName,\n                                    toolCallId: value.toolCallId\n                                }\n                            ], tool.generate, ui);\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {}\n                }\n            }\n            if (hasToolCall) {\n                await finished;\n                ui.done();\n            } else {\n                handleRender([\n                    {\n                        content,\n                        done: true\n                    }\n                ], textRender, ui);\n                await finished;\n                ui.done();\n            }\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/provider.tsx\n\n\n\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(\"784eaeca1c316aa5d98fd936c53125000c396aeb\", $$ACTION_0);\nasync function $$ACTION_0({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n}\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name in actions){\n        wrappedActions[name] = wrapAction(actions[name], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_3__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a = props.initialUIState) != null ? _a : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_10__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNlcnZlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDSDs7QUNEQztBQStCeEI7QUE3QkQsU0FBU007SUFDZCxJQUFJQyxTQUE2QkM7SUFDakMsTUFBTUMsVUFBVSxJQUFJQyxRQUFXLENBQUNDLEtBQUtDO1FBQ25DTCxVQUFVSTtRQUNWSCxTQUFTSTtJQUNYO0lBQ0EsT0FBTztRQUNMSDtRQUNBRjtRQUNBQztJQUNGO0FBQ0Y7QUFHQSxJQUFNSyxJQUFJO0lBQ1AsT0FBTyxFQUNOQyxDQUFBO0lBQ0FDLENBQUEsRUFDRjtRQUlFLE1BQU1DLFFBQVEsTUFBTUQ7UUFDcEIsSUFBSUMsTUFBTUMsSUFBQSxFQUFNO1lBQ2QsT0FBT0QsTUFBTUUsS0FBQTtRQUNmO1FBRUEsSUFBSUYsTUFBTUcsTUFBQSxFQUFRO1lBQ2hCLE9BQ0UsZ0JBQUFkLHVEQUFBQSxDQUFBRix1REFBQUEsRUFBQTtnQkFDR2lCLFVBQUE7b0JBQUFOO29CQUNELGdCQUFBVixzREFBQUEsQ0FBQ0YsMkNBQVFBLEVBQVI7d0JBQVNtQixVQUFVTCxNQUFNRSxLQUFBO3dCQUN4QkUsVUFBQSxnQkFBQWhCLHNEQUFBQSxDQUFDUyxHQUFBOzRCQUFFQyxHQUFHRSxNQUFNRSxLQUFBOzRCQUFPSCxHQUFHQyxNQUFNTSxJQUFBO3dCQUFBO29CQUFNO2lCQUNwQztZQUFBO1FBR047UUFFQSxPQUNFLGdCQUFBbEIsc0RBQUFBLENBQUNGLDJDQUFRQSxFQUFSO1lBQVNtQixVQUFVTCxNQUFNRSxLQUFBO1lBQ3hCRSxVQUFBLGdCQUFBaEIsc0RBQUFBLENBQUNTLEdBQUE7Z0JBQUVDLEdBQUdFLE1BQU1FLEtBQUE7Z0JBQU9ILEdBQUdDLE1BQU1NLElBQUE7WUFBQTtRQUFNO0lBR3hDO0NBSUYsQ0FBRSxFQUFDO0FBRUksU0FBU0MscUJBQXFCQyxZQUFBO0lBQ25DLE1BQU0sRUFBRWYsT0FBQSxF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ZUFDdkJOLFdBQVdNLGNBQWMsQ0FBQyxLQUMxQjtJQUVKLE1BQU1HLEtBQTRDLE9BQU1DO1FBaEgxRCxJQUFBcFYsSUFBQUM7UUFpSEksSUFBSSx1TUFBY3FVLEVBQU87WUFJdkIsTUFBTSxJQUFJM1YsTUFDUjtRQUVKO1FBRUEsSUFBSTBXLFVBQUEsQ0FBVXJWLEtBQUFvVixNQUFNTCxjQUFBLEtBQU4sT0FBQS9VLEtBQXdCK1U7UUFDdEMsSUFBSU8sVUFBQSxDQUFVclYsS0FBQW1WLE1BQU1OLGNBQUEsS0FBTixPQUFBN1UsS0FBd0I2VTtRQUN0QyxJQUFJUyxlQUFlO1FBRW5CLElBQUlMLG9CQUFvQjtZQUN0QixNQUFNLENBQUNNLGlCQUFpQkMsV0FBVSxHQUFJLE1BQU1QLG1CQUFtQkk7WUFDL0QsSUFBSUcsZUFBZSxRQUFXO2dCQUM1QkYsZUFBZUM7Z0JBQ2ZILFVBQVVJO1lBQ1o7UUFDRjtRQUVBLE9BQ0UsZ0JBQUFoWixzREFBQUEsQ0FBQzhYLGdFQUFrQkEsRUFBbEI7WUFDQ1U7WUFDQUM7WUFDQUgsZ0JBQWdCTTtZQUNoQlAsZ0JBQWdCUTtZQUNoQkkscUJBQXFCSDtZQUVwQjlYLFVBQUEyWCxNQUFNM1gsUUFBQTtRQUFBO0lBR2I7SUFFQSxPQUFPMFg7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9haS1zdGF0ZS50c3g/MzgwMCIsIndlYnBhY2s6Ly8vLi4vdXRpbHMudHN4PzdhMmUiLCJ3ZWJwYWNrOi8vLy4uL3N0cmVhbWFibGUudHN4PzY5MWYiLCJ3ZWJwYWNrOi8vLy4uLy4uL2NvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHM/OTU0NSIsIndlYnBhY2s6Ly8vLi4vLi4vY29yZS9wcm9tcHQvZGF0YS1jb250ZW50LnRzP2U5MmYiLCJ3ZWJwYWNrOi8vLy4uLy4uL2NvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzPzcxNzQiLCJ3ZWJwYWNrOi8vLy4uLy4uL2NvcmUvcHJvbXB0L2dldC12YWxpZGF0ZWQtcHJvbXB0LnRzPzU3OGUiLCJ3ZWJwYWNrOi8vLy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncy50cz9kNThjIiwid2VicGFjazovLy8uLi8uLi9jb3JlL3V0aWwvY29udmVydC16b2QtdG8tanNvbi1zY2hlbWEudHM/MDBmZiIsIndlYnBhY2s6Ly8vLi4vLi4vY29yZS91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50cz9mMGQwIiwid2VicGFjazovLy8uLi8uLi9jb3JlL3V0aWwvZGVsYXkudHM/YTFlNyIsIndlYnBhY2s6Ly8vLi4vLi4vc2hhcmVkL3N0cmVhbS1wYXJ0cy50cz9jNGE4Iiwid2VicGFjazovLy8uLi8uLi9zaGFyZWQvdXRpbHMudHM/ZjhjZiIsIndlYnBhY2s6Ly8vLi4vLi4vc3RyZWFtcy9haS1zdHJlYW0udHM/NDg1NCIsIndlYnBhY2s6Ly8vLi4vLi4vc3RyZWFtcy9zdHJlYW0tZGF0YS50cz82NzMwIiwid2VicGFjazovLy8uLi8uLi9zdHJlYW1zL29wZW5haS1zdHJlYW0udHM/YjJiZCIsIndlYnBhY2s6Ly8vLi4vY29uc3RhbnRzLnRzP2FiNzIiLCJ3ZWJwYWNrOi8vLy4uL3N0cmVhbS11aS9zdHJlYW0tdWkudHN4PzFjY2EiLCJ3ZWJwYWNrOi8vLy4uL3Byb3ZpZGVyLnRzeD8zMGViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlIH0gZnJvbSAnYXN5bmNfaG9va3MnO1xuaW1wb3J0ICogYXMganNvbmRpZmZwYXRjaCBmcm9tICdqc29uZGlmZnBhdGNoJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlLCBpc0Z1bmN0aW9uIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7XG4gIEFJUHJvdmlkZXIsXG4gIEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zLFxuICBJbmZlckFJU3RhdGUsXG4gIE11dGFibGVBSVN0YXRlLFxuICBWYWx1ZU9yVXBkYXRlcixcbn0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgbXVsdGlwbGUgQUkgcmVxdWVzdHMgZ2V0IGluIGNvbmN1cnJlbnRseSwgZm9yIGRpZmZlcmVudFxuLy8gQUkgaW5zdGFuY2VzLiBTbyBBTFMgaXMgbmVjZXNzYXJ5IGhlcmUgZm9yIGEgc2ltcGxlciBBUEkuXG5jb25zdCBhc3luY0FJU3RhdGVTdG9yYWdlID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlPHtcbiAgY3VycmVudFN0YXRlOiBhbnk7XG4gIG9yaWdpbmFsU3RhdGU6IGFueTtcbiAgc2VhbGVkOiBib29sZWFuO1xuICBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucztcbiAgbXV0YXRpb25EZWx0YVByb21pc2U/OiBQcm9taXNlPGFueT47XG4gIG11dGF0aW9uRGVsdGFSZXNvbHZlPzogKHY6IGFueSkgPT4gdm9pZDtcbn0+KCk7XG5cbmZ1bmN0aW9uIGdldEFJU3RhdGVTdG9yZU9yVGhyb3cobWVzc2FnZTogc3RyaW5nKSB7XG4gIGNvbnN0IHN0b3JlID0gYXN5bmNBSVN0YXRlU3RvcmFnZS5nZXRTdG9yZSgpO1xuICBpZiAoIXN0b3JlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiBzdG9yZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhBSVN0YXRlPFMsIFQ+KFxuICB7IHN0YXRlLCBvcHRpb25zIH06IHsgc3RhdGU6IFM7IG9wdGlvbnM6IEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zIH0sXG4gIGZuOiAoKSA9PiBULFxuKTogVCB7XG4gIHJldHVybiBhc3luY0FJU3RhdGVTdG9yYWdlLnJ1bihcbiAgICB7XG4gICAgICBjdXJyZW50U3RhdGU6IHN0YXRlLFxuICAgICAgb3JpZ2luYWxTdGF0ZTogc3RhdGUsXG4gICAgICBzZWFsZWQ6IGZhbHNlLFxuICAgICAgb3B0aW9ucyxcbiAgICB9LFxuICAgIGZuLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KCdJbnRlcm5hbCBlcnJvciBvY2N1cnJlZC4nKTtcbiAgcmV0dXJuIHN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlO1xufVxuXG4vLyBJbnRlcm5hbCBtZXRob2QuIFRoaXMgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIEFJIEFjdGlvbiBoYXMgYmVlbiByZXR1cm5lZFxuLy8gYW5kIHlvdSBjYW4gbm8gbG9uZ2VyIGNhbGwgYGdldE11dGFibGVBSVN0YXRlKClgIGluc2lkZSBhbnkgYXN5bmMgY2FsbGJhY2tzXG4vLyBjcmVhdGVkIGJ5IHRoYXQgQWN0aW9uLlxuZXhwb3J0IGZ1bmN0aW9uIHNlYWxNdXRhYmxlQUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KCdJbnRlcm5hbCBlcnJvciBvY2N1cnJlZC4nKTtcbiAgc3RvcmUuc2VhbGVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgQUkgc3RhdGUuXG4gKiBJZiBga2V5YCBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQga2V5IGluIHRoZVxuICogQUkgc3RhdGUsIGlmIGl0J3MgYW4gb2JqZWN0LiBJZiBpdCdzIG5vdCBhbiBvYmplY3QsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKlxuICogQGV4YW1wbGUgY29uc3Qgc3RhdGUgPSBnZXRBSVN0YXRlKCkgLy8gR2V0IHRoZSBlbnRpcmUgQUkgc3RhdGVcbiAqIEBleGFtcGxlIGNvbnN0IGZpZWxkID0gZ2V0QUlTdGF0ZSgna2V5JykgLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUga2V5XG4gKi9cbmZ1bmN0aW9uIGdldEFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpOiBJbmZlckFJU3RhdGU8QUksIGFueT47XG5mdW5jdGlvbiBnZXRBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIGtleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuKTogSW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldO1xuZnVuY3Rpb24gZ2V0QUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICAuLi5hcmdzOiBbXSB8IFtrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pl1cbikge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coXG4gICAgJ2BnZXRBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYW4gQUkgQWN0aW9uLicsXG4gICk7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2FuJ3QgZ2V0IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgKX1cIiBmaWVsZCBmcm9tIHRoZSBBSSBzdGF0ZSBiZWNhdXNlIGl0J3Mgbm90IGFuIG9iamVjdC5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZVtrZXkgYXMga2V5b2YgdHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZV07XG4gIH1cblxuICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbXV0YWJsZSBBSSBzdGF0ZS4gTm90ZSB0aGF0IHlvdSBtdXN0IGNhbGwgYC5jbG9zZSgpYCB3aGVuIGZpbmlzaGluZ1xuICogdXBkYXRpbmcgdGhlIEFJIHN0YXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IHN0YXRlID0gZ2V0TXV0YWJsZUFJU3RhdGUoKVxuICogc3RhdGUudXBkYXRlKHsgLi4uc3RhdGUuZ2V0KCksIGtleTogJ3ZhbHVlJyB9KVxuICogc3RhdGUudXBkYXRlKChjdXJyZW50U3RhdGUpID0+ICh7IC4uLmN1cnJlbnRTdGF0ZSwga2V5OiAndmFsdWUnIH0pKVxuICogc3RhdGUuZG9uZSgpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCBzdGF0ZSA9IGdldE11dGFibGVBSVN0YXRlKClcbiAqIHN0YXRlLmRvbmUoeyAuLi5zdGF0ZS5nZXQoKSwga2V5OiAndmFsdWUnIH0pIC8vIERvbmUgd2l0aCBhIG5ldyBzdGF0ZVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldE11dGFibGVBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKTogTXV0YWJsZUFJU3RhdGU8XG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55PlxuPjtcbmZ1bmN0aW9uIGdldE11dGFibGVBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIGtleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuKTogTXV0YWJsZUFJU3RhdGU8SW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldPjtcbmZ1bmN0aW9uIGdldE11dGFibGVBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIC4uLmFyZ3M6IFtdIHwgW2tleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIHR5cGUgQUlTdGF0ZSA9IEluZmVyQUlTdGF0ZTxBSSwgYW55PjtcbiAgdHlwZSBBSVN0YXRlV2l0aEtleSA9IHR5cGVvZiBhcmdzIGV4dGVuZHMgW2tleToga2V5b2YgQUlTdGF0ZV1cbiAgICA/IEFJU3RhdGVbKHR5cGVvZiBhcmdzKVswXV1cbiAgICA6IEFJU3RhdGU7XG4gIHR5cGUgTmV3U3RhdGVPclVwZGF0ZXIgPSBWYWx1ZU9yVXBkYXRlcjxBSVN0YXRlV2l0aEtleT47XG5cbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KFxuICAgICdgZ2V0TXV0YWJsZUFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhbiBBSSBBY3Rpb24uJyxcbiAgKTtcblxuICBpZiAoc3RvcmUuc2VhbGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgZ2V0TXV0YWJsZUFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIGJlZm9yZSByZXR1cm5pbmcgZnJvbSBhbiBBSSBBY3Rpb24uIFBsZWFzZSBtb3ZlIGl0IHRvIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIEFjdGlvbidzIGZ1bmN0aW9uIGJvZHkuXCIsXG4gICAgKTtcbiAgfVxuXG4gIGlmICghc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2UpIHtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2UgPSBwcm9taXNlO1xuICAgIHN0b3JlLm11dGF0aW9uRGVsdGFSZXNvbHZlID0gcmVzb2x2ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvVXBkYXRlKG5ld1N0YXRlOiBOZXdTdGF0ZU9yVXBkYXRlciwgZG9uZTogYm9vbGVhbikge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBjYW4ndCBtb2RpZnkgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgKX1cIiBmaWVsZCBvZiB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZSkpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dID0gbmV3U3RhdGUoc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlKHN0b3JlLmN1cnJlbnRTdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dID0gbmV3U3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9yZS5vcHRpb25zLm9uU2V0QUlTdGF0ZT8uKHtcbiAgICAgIGtleTogYXJncy5sZW5ndGggPiAwID8gYXJnc1swXSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0YXRlOiBzdG9yZS5jdXJyZW50U3RhdGUsXG4gICAgICBkb25lLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbXV0YWJsZVN0YXRlID0ge1xuICAgIGdldDogKCkgPT4ge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgICAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgWW91IGNhbid0IGdldCB0aGUgXCIke1N0cmluZyhcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgKX1cIiBmaWVsZCBmcm9tIHRoZSBBSSBzdGF0ZSBiZWNhdXNlIGl0J3Mgbm90IGFuIG9iamVjdC5gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZVtrZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlIGFzIEFJU3RhdGU7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShuZXdBSVN0YXRlOiBOZXdTdGF0ZU9yVXBkYXRlcikge1xuICAgICAgZG9VcGRhdGUobmV3QUlTdGF0ZSwgZmFsc2UpO1xuICAgIH0sXG4gICAgZG9uZTogZnVuY3Rpb24gZG9uZSguLi5kb25lQXJnczogW10gfCBbTmV3U3RhdGVPclVwZGF0ZXJdKSB7XG4gICAgICBpZiAoZG9uZUFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBkb1VwZGF0ZShkb25lQXJnc1swXSBhcyBOZXdTdGF0ZU9yVXBkYXRlciwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbHRhID0ganNvbmRpZmZwYXRjaC5kaWZmKHN0b3JlLm9yaWdpbmFsU3RhdGUsIHN0b3JlLmN1cnJlbnRTdGF0ZSk7XG4gICAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUmVzb2x2ZSEoZGVsdGEpO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIG11dGFibGVTdGF0ZTtcbn1cblxuZXhwb3J0IHsgZ2V0QUlTdGF0ZSwgZ2V0TXV0YWJsZUFJU3RhdGUgfTtcbiIsImltcG9ydCBSZWFjdCwgeyBTdXNwZW5zZSB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPFQgPSBhbnk+KCkge1xuICBsZXQgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkLCByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmU6IHJlc29sdmUhLFxuICAgIHJlamVjdDogcmVqZWN0ISxcbiAgfTtcbn1cblxuLy8gVXNlIHRoZSBuYW1lIGBSYCBmb3IgYFJvd2AgYXMgaXQgd2lsbCBiZSBzaG9ydGVyIGluIHRoZSBSU0MgcGF5bG9hZC5cbmNvbnN0IFIgPSBbXG4gIChhc3luYyAoe1xuICAgIGMsIC8vIGN1cnJlbnRcbiAgICBuLCAvLyBuZXh0XG4gIH06IHtcbiAgICBjOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgbjogUHJvbWlzZTxhbnk+O1xuICB9KSA9PiB7XG4gICAgY29uc3QgY2h1bmsgPSBhd2FpdCBuO1xuICAgIGlmIChjaHVuay5kb25lKSB7XG4gICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGNodW5rLmFwcGVuZCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICB7Y31cbiAgICAgICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2NodW5rLnZhbHVlfT5cbiAgICAgICAgICAgIDxSIGM9e2NodW5rLnZhbHVlfSBuPXtjaHVuay5uZXh0fSAvPlxuICAgICAgICAgIDwvU3VzcGVuc2U+XG4gICAgICAgIDwvPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtjaHVuay52YWx1ZX0+XG4gICAgICAgIDxSIGM9e2NodW5rLnZhbHVlfSBuPXtjaHVuay5uZXh0fSAvPlxuICAgICAgPC9TdXNwZW5zZT5cbiAgICApO1xuICB9KSBhcyB1bmtub3duIGFzIFJlYWN0LkZDPHtcbiAgICBjOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgbjogUHJvbWlzZTxhbnk+O1xuICB9Pixcbl1bMF07XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdXNwZW5zZWRDaHVuayhpbml0aWFsVmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkge1xuICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcblxuICByZXR1cm4ge1xuICAgIHJvdzogKFxuICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtpbml0aWFsVmFsdWV9PlxuICAgICAgICA8UiBjPXtpbml0aWFsVmFsdWV9IG49e3Byb21pc2V9IC8+XG4gICAgICA8L1N1c3BlbnNlPlxuICAgICksXG4gICAgcmVzb2x2ZSxcbiAgICByZWplY3QsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHg6IHVua25vd24pOiB4IGlzIEZ1bmN0aW9uID0+XG4gIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgY29uc3VtZVN0cmVhbSA9IGFzeW5jIChzdHJlYW06IFJlYWRhYmxlU3RyZWFtKSA9PiB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIGJyZWFrO1xuICB9XG59O1xuIiwiaW1wb3J0IHR5cGUgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdHlwZSBPcGVuQUkgZnJvbSAnb3BlbmFpJztcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tICd6b2QtdG8tanNvbi1zY2hlbWEnO1xuXG4vLyBUT0RPOiBUaGlzIG5lZWRzIHRvIGJlIGV4dGVybmFsaXplZC5cbmltcG9ydCB7IE9wZW5BSVN0cmVhbSB9IGZyb20gJy4uL3N0cmVhbXMnO1xuXG5pbXBvcnQge1xuICBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUsXG4gIERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FLFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSxcbiAgY3JlYXRlU3VzcGVuc2VkQ2h1bmssXG4gIGNvbnN1bWVTdHJlYW0sXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBTdHJlYW1hYmxlUGF0Y2gsIFN0cmVhbWFibGVWYWx1ZSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIENyZWF0ZSBhIHBpZWNlIG9mIGNoYW5nYWJsZSBVSSB0aGF0IGNhbiBiZSBzdHJlYW1lZCB0byB0aGUgY2xpZW50LlxuICogT24gdGhlIGNsaWVudCBzaWRlLCBpdCBjYW4gYmUgcmVuZGVyZWQgYXMgYSBub3JtYWwgUmVhY3Qgbm9kZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtYWJsZVVJKGluaXRpYWxWYWx1ZT86IFJlYWN0LlJlYWN0Tm9kZSkge1xuICBsZXQgY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gIGxldCB7IHJvdywgcmVzb2x2ZSwgcmVqZWN0IH0gPSBjcmVhdGVTdXNwZW5zZWRDaHVuayhpbml0aWFsVmFsdWUpO1xuXG4gIGZ1bmN0aW9uIGFzc2VydFN0cmVhbShtZXRob2Q6IHN0cmluZykge1xuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnOiBVSSBzdHJlYW0gaXMgYWxyZWFkeSBjbG9zZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHdhcm5pbmdUaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcbiAgZnVuY3Rpb24gd2FyblVuY2xvc2VkU3RyZWFtKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICB3YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1RoZSBzdHJlYW1hYmxlIFVJIGhhcyBiZWVuIHNsb3cgdG8gdXBkYXRlLiBUaGlzIG1heSBiZSBhIGJ1ZyBvciBhIHBlcmZvcm1hbmNlIGlzc3VlIG9yIHlvdSBmb3Jnb3QgdG8gY2FsbCBgLmRvbmUoKWAuJyxcbiAgICAgICAgKTtcbiAgICAgIH0sIERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FKTtcbiAgICB9XG4gIH1cbiAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUgVUkuIFRoaXMgY2FuIGJlIHJldHVybmVkIGZyb20gYSBTZXJ2ZXIgQWN0aW9uIGFuZCByZWNlaXZlZCBieSB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIHZhbHVlOiByb3csXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCBVSSBub2RlLiBJdCB0YWtlcyBhIG5ldyBVSSBub2RlIGFuZCByZXBsYWNlcyB0aGUgb2xkIG9uZS5cbiAgICAgKi9cbiAgICB1cGRhdGUodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcudXBkYXRlKCknKTtcblxuICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB1cGRhdGUgdGhlIHZhbHVlIGlmIGl0J3MgcmVmZXJlbnRpYWxseSBlcXVhbC5cbiAgICAgIGlmICh2YWx1ZSA9PT0gY3VycmVudFZhbHVlKSB7XG4gICAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG5cbiAgICAgIHJlc29sdmUoeyB2YWx1ZTogY3VycmVudFZhbHVlLCBkb25lOiBmYWxzZSwgbmV4dDogcmVzb2x2YWJsZS5wcm9taXNlIH0pO1xuICAgICAgcmVzb2x2ZSA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlamVjdCA9IHJlc29sdmFibGUucmVqZWN0O1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gYXBwZW5kIGEgbmV3IFVJIG5vZGUgdG8gdGhlIGVuZCBvZiB0aGUgb2xkIG9uZS5cbiAgICAgKiBPbmNlIGFwcGVuZGVkIGEgbmV3IFVJIG5vZGUsIHRoZSBwcmV2aW91cyBVSSBub2RlIGNhbm5vdCBiZSB1cGRhdGVkIGFueW1vcmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzeFxuICAgICAqIGNvbnN0IHVpID0gY3JlYXRlU3RyZWFtYWJsZVVJKDxkaXY+aGVsbG88L2Rpdj4pXG4gICAgICogdWkuYXBwZW5kKDxkaXY+d29ybGQ8L2Rpdj4pXG4gICAgICpcbiAgICAgKiAvLyBUaGUgVUkgbm9kZSB3aWxsIGJlOlxuICAgICAqIC8vIDw+XG4gICAgICogLy8gICA8ZGl2PmhlbGxvPC9kaXY+XG4gICAgICogLy8gICA8ZGl2PndvcmxkPC9kaXY+XG4gICAgICogLy8gPC8+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXBwZW5kKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmFwcGVuZCgpJyk7XG5cbiAgICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG5cbiAgICAgIHJlc29sdmUoeyB2YWx1ZSwgZG9uZTogZmFsc2UsIGFwcGVuZDogdHJ1ZSwgbmV4dDogcmVzb2x2YWJsZS5wcm9taXNlIH0pO1xuICAgICAgcmVzb2x2ZSA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlamVjdCA9IHJlc29sdmFibGUucmVqZWN0O1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2lnbmFsIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIFVJIHN0cmVhbS5cbiAgICAgKiBJdCB3aWxsIGJlIHRocm93biBvbiB0aGUgY2xpZW50IHNpZGUgYW5kIGNhdWdodCBieSB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeSBjb21wb25lbnQuXG4gICAgICovXG4gICAgZXJyb3IoZXJyb3I6IGFueSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZXJyb3IoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbWFya3MgdGhlIFVJIG5vZGUgYXMgZmluYWxpemVkLiBZb3UgY2FuIGVpdGhlciBjYWxsIGl0IHdpdGhvdXQgYW55IHBhcmFtZXRlcnMgb3Igd2l0aCBhIG5ldyBVSSBub2RlIGFzIHRoZSBmaW5hbCBzdGF0ZS5cbiAgICAgKiBPbmNlIGNhbGxlZCwgdGhlIFVJIG5vZGUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsd2F5cyAqKnJlcXVpcmVkKiogdG8gYmUgY2FsbGVkLCBvdGhlcndpc2UgdGhlIHJlc3BvbnNlIHdpbGwgYmUgc3R1Y2sgaW4gYSBsb2FkaW5nIHN0YXRlLlxuICAgICAqL1xuICAgIGRvbmUoLi4uYXJnczogW10gfCBbUmVhY3QuUmVhY3ROb2RlXSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZG9uZSgpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlKHsgdmFsdWU6IGFyZ3NbMF0sIGRvbmU6IHRydWUgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoeyB2YWx1ZTogY3VycmVudFZhbHVlLCBkb25lOiB0cnVlIH0pO1xuICAgIH0sXG4gIH07XG59XG5cbmNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DSyA9IFN5bWJvbCgnc3RyZWFtYWJsZS52YWx1ZS5sb2NrJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgd3JhcHBlZCwgY2hhbmdhYmxlIHZhbHVlIHRoYXQgY2FuIGJlIHN0cmVhbWVkIHRvIHRoZSBjbGllbnQuXG4gKiBPbiB0aGUgY2xpZW50IHNpZGUsIHRoZSB2YWx1ZSBjYW4gYmUgYWNjZXNzZWQgdmlhIHRoZSByZWFkU3RyZWFtYWJsZVZhbHVlKCkgQVBJLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVmFsdWU8VCA9IGFueSwgRSA9IGFueT4oXG4gIGluaXRpYWxWYWx1ZT86IFQgfCBSZWFkYWJsZVN0cmVhbTxUPixcbikge1xuICBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID1cbiAgICBpbml0aWFsVmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSB8fFxuICAgICh0eXBlb2YgaW5pdGlhbFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgaW5pdGlhbFZhbHVlICE9PSBudWxsICYmXG4gICAgICAnZ2V0UmVhZGVyJyBpbiBpbml0aWFsVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBpbml0aWFsVmFsdWUuZ2V0UmVhZGVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAnbG9ja2VkJyBpbiBpbml0aWFsVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBpbml0aWFsVmFsdWUubG9ja2VkID09PSAnYm9vbGVhbicpO1xuXG4gIGlmICghaXNSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQsIEU+KGluaXRpYWxWYWx1ZSk7XG4gIH1cblxuICBjb25zdCBzdHJlYW1hYmxlVmFsdWUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQsIEU+KCk7XG5cbiAgLy8gU2luY2UgdGhlIHN0cmVhbWFibGUgdmFsdWUgd2lsbCBiZSBmcm9tIGEgcmVhZGFibGUgc3RyZWFtLCBpdCdzIG5vdCBhbGxvd2VkXG4gIC8vIHRvIHVwZGF0ZSB0aGUgdmFsdWUgbWFudWFsbHkgYXMgdGhhdCBpbnRyb2R1Y2VzIHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgLy8gdW5leHBlY3RlZCBiZWhhdmlvci5cbiAgLy8gV2UgbG9jayB0aGUgdmFsdWUgdG8gcHJldmVudCBhbnkgdXBkYXRlcyBmcm9tIHRoZSB1c2VyLlxuICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IHRydWU7XG5cbiAgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29uc3VtZSB0aGUgcmVhZGFibGUgc3RyZWFtIGFuZCB1cGRhdGUgdGhlIHZhbHVlLlxuICAgICAgY29uc3QgcmVhZGVyID0gaW5pdGlhbFZhbHVlLmdldFJlYWRlcigpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5sb2NrIHRoZSB2YWx1ZSB0byBhbGxvdyB1cGRhdGVzLlxuICAgICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHN0cmVhbWFibGVWYWx1ZS5hcHBlbmQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbWFibGVWYWx1ZS51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvY2sgdGhlIHZhbHVlIGFnYWluLlxuICAgICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gZmFsc2U7XG4gICAgICBzdHJlYW1hYmxlVmFsdWUuZG9uZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gZmFsc2U7XG4gICAgICBzdHJlYW1hYmxlVmFsdWUuZXJyb3IoZSk7XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiBzdHJlYW1hYmxlVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGw8VCA9IGFueSwgRSA9IGFueT4oaW5pdGlhbFZhbHVlPzogVCkge1xuICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gIGxldCBsb2NrZWQgPSBmYWxzZTtcbiAgbGV0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTxTdHJlYW1hYmxlVmFsdWU8VCwgRT4+KCk7XG5cbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGV0IGN1cnJlbnRFcnJvcjogRSB8IHVuZGVmaW5lZDtcbiAgbGV0IGN1cnJlbnRQcm9taXNlOiB0eXBlb2YgcmVzb2x2YWJsZS5wcm9taXNlIHwgdW5kZWZpbmVkID1cbiAgICByZXNvbHZhYmxlLnByb21pc2U7XG4gIGxldCBjdXJyZW50UGF0Y2hWYWx1ZTogU3RyZWFtYWJsZVBhdGNoO1xuXG4gIGZ1bmN0aW9uIGFzc2VydFN0cmVhbShtZXRob2Q6IHN0cmluZykge1xuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnOiBWYWx1ZSBzdHJlYW0gaXMgYWxyZWFkeSBjbG9zZWQuJyk7XG4gICAgfVxuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgbWV0aG9kICsgJzogVmFsdWUgc3RyZWFtIGlzIGxvY2tlZCBhbmQgY2Fubm90IGJlIHVwZGF0ZWQuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHdhcm5pbmdUaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcbiAgZnVuY3Rpb24gd2FyblVuY2xvc2VkU3RyZWFtKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICB3YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1RoZSBzdHJlYW1hYmxlIFVJIGhhcyBiZWVuIHNsb3cgdG8gdXBkYXRlLiBUaGlzIG1heSBiZSBhIGJ1ZyBvciBhIHBlcmZvcm1hbmNlIGlzc3VlIG9yIHlvdSBmb3Jnb3QgdG8gY2FsbCBgLmRvbmUoKWAuJyxcbiAgICAgICAgKTtcbiAgICAgIH0sIERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FKTtcbiAgICB9XG4gIH1cbiAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlV3JhcHBlZChpbml0aWFsQ2h1bms/OiBib29sZWFuKTogU3RyZWFtYWJsZVZhbHVlPFQsIEU+IHtcbiAgICAvLyBUaGlzIG1ha2VzIHRoZSBwYXlsb2FkIG11Y2ggc21hbGxlciBpZiB0aGVyZSdyZSBtdXRhdGl2ZSB1cGRhdGVzIGJlZm9yZSB0aGUgZmlyc3QgcmVhZC5cbiAgICBsZXQgaW5pdDogUGFydGlhbDxTdHJlYW1hYmxlVmFsdWU8VCwgRT4+O1xuXG4gICAgaWYgKGN1cnJlbnRFcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbml0ID0geyBlcnJvcjogY3VycmVudEVycm9yIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50UGF0Y2hWYWx1ZSAmJiAhaW5pdGlhbENodW5rKSB7XG4gICAgICAgIGluaXQgPSB7IGRpZmY6IGN1cnJlbnRQYXRjaFZhbHVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0ID0geyBjdXJyOiBjdXJyZW50VmFsdWUgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFByb21pc2UpIHtcbiAgICAgIGluaXQubmV4dCA9IGN1cnJlbnRQcm9taXNlO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsQ2h1bmspIHtcbiAgICAgIGluaXQudHlwZSA9IFNUUkVBTUFCTEVfVkFMVUVfVFlQRTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgaW50ZXJuYWwgYGN1cnJlbnRWYWx1ZWAgYW5kIGBjdXJyZW50UGF0Y2hWYWx1ZWAgaWYgbmVlZGVkLlxuICBmdW5jdGlvbiB1cGRhdGVWYWx1ZVN0YXRlcyh2YWx1ZTogVCkge1xuICAgIC8vIElmIHdlIGNhbiBvbmx5IHNlbmQgYSBwYXRjaCBvdmVyIHRoZSB3aXJlLCBpdCdzIGJldHRlciB0byBkbyBzby5cbiAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IFswLCB2YWx1ZS5zbGljZShjdXJyZW50VmFsdWUubGVuZ3RoKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIFRoaXMgaXMgYW4gaW50ZXJuYWwgbG9jayB0byBwcmV2ZW50IHRoZSB2YWx1ZSBmcm9tIGJlaW5nXG4gICAgICogdXBkYXRlZCBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBzZXQgW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10oc3RhdGU6IGJvb2xlYW4pIHtcbiAgICAgIGxvY2tlZCA9IHN0YXRlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlLiBUaGlzIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgU2VydmVyIEFjdGlvbiBhbmRcbiAgICAgKiByZWNlaXZlZCBieSB0aGUgY2xpZW50LiBUbyByZWFkIHRoZSBzdHJlYW1lZCB2YWx1ZXMsIHVzZSB0aGVcbiAgICAgKiBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgb3IgYHVzZVN0cmVhbWFibGVWYWx1ZWAgQVBJcy5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlZCh0cnVlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGN1cnJlbnQgdmFsdWUgd2l0aCBhIG5ldyBvbmUuXG4gICAgICovXG4gICAgdXBkYXRlKHZhbHVlOiBUKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy51cGRhdGUoKScpO1xuXG4gICAgICBjb25zdCByZXNvbHZlUHJldmlvdXMgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcblxuICAgICAgdXBkYXRlVmFsdWVTdGF0ZXModmFsdWUpO1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgICByZXNvbHZlUHJldmlvdXMoY3JlYXRlV3JhcHBlZCgpKTtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGFwcGVuZCBhIGRlbHRhIHN0cmluZyB0byB0aGUgY3VycmVudCB2YWx1ZS4gSXRcbiAgICAgKiByZXF1aXJlcyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc3RyZWFtYWJsZSB0byBiZSBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganN4XG4gICAgICogY29uc3Qgc3RyZWFtYWJsZSA9IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgnaGVsbG8nKTtcbiAgICAgKiBzdHJlYW1hYmxlLmFwcGVuZCgnIHdvcmxkJyk7XG4gICAgICpcbiAgICAgKiAvLyBUaGUgdmFsdWUgd2lsbCBiZSAnaGVsbG8gd29ybGQnXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXBwZW5kKHZhbHVlOiBUKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5hcHBlbmQoKScpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgIT09ICd1bmRlZmluZWQnXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAuYXBwZW5kKCk6IFRoZSBjdXJyZW50IHZhbHVlIGlzIG5vdCBhIHN0cmluZy4gUmVjZWl2ZWQ6ICR7dHlwZW9mIGN1cnJlbnRWYWx1ZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAuYXBwZW5kKCk6IFRoZSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuIFJlY2VpdmVkOiAke3R5cGVvZiB2YWx1ZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNvbHZlUHJldmlvdXMgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcblxuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gWzAsIHZhbHVlXTtcbiAgICAgICAgKGN1cnJlbnRWYWx1ZSBhcyBzdHJpbmcpID0gY3VycmVudFZhbHVlICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgICAgcmVzb2x2ZVByZXZpb3VzKGNyZWF0ZVdyYXBwZWQoKSk7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzaWduYWwgdGhhdCB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgdmFsdWUgc3RyZWFtLlxuICAgICAqIEl0IHdpbGwgYmUgdGhyb3duIG9uIHRoZSBjbGllbnQgc2lkZSB3aGVuIGNvbnN1bWVkIHZpYVxuICAgICAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYC5cbiAgICAgKi9cbiAgICBlcnJvcihlcnJvcjogYW55KSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5lcnJvcigpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRFcnJvciA9IGVycm9yO1xuICAgICAgY3VycmVudFByb21pc2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh7IGVycm9yIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbWFya3MgdGhlIHZhbHVlIGFzIGZpbmFsaXplZC4gWW91IGNhbiBlaXRoZXIgY2FsbCBpdCB3aXRob3V0XG4gICAgICogYW55IHBhcmFtZXRlcnMgb3Igd2l0aCBhIG5ldyB2YWx1ZSBhcyB0aGUgZmluYWwgc3RhdGUuXG4gICAgICogT25jZSBjYWxsZWQsIHRoZSB2YWx1ZSBjYW5ub3QgYmUgdXBkYXRlZCBvciBhcHBlbmRlZCBhbnltb3JlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYWx3YXlzICoqcmVxdWlyZWQqKiB0byBiZSBjYWxsZWQsIG90aGVyd2lzZSB0aGUgcmVzcG9uc2VcbiAgICAgKiB3aWxsIGJlIHN0dWNrIGluIGEgbG9hZGluZyBzdGF0ZS5cbiAgICAgKi9cbiAgICBkb25lKC4uLmFyZ3M6IFtdIHwgW1RdKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5kb25lKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgY3VycmVudFByb21pc2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICB1cGRhdGVWYWx1ZVN0YXRlcyhhcmdzWzBdKTtcbiAgICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKGNyZWF0ZVdyYXBwZWQoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHt9KTtcbiAgICB9LFxuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdHJlYW1hYmxlVUksIGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSB9O1xuXG50eXBlIFN0cmVhbWFibGUgPSBSZWFjdE5vZGUgfCBQcm9taXNlPFJlYWN0Tm9kZT47XG50eXBlIFJlbmRlcmVyPFQ+ID0gKFxuICBwcm9wczogVCxcbikgPT5cbiAgfCBTdHJlYW1hYmxlXG4gIHwgR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+XG4gIHwgQXN5bmNHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD47XG5cbi8qKlxuICogYHJlbmRlcmAgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc3RyZWFtYWJsZSBVSSBmcm9tIHNvbWUgTExNcy5cbiAqIFRoaXMgQVBJIG9ubHkgc3VwcG9ydHMgT3BlbkFJJ3MgR1BUIG1vZGVscyB3aXRoIEZ1bmN0aW9uIENhbGxpbmcgYW5kIEFzc2lzdGFudHMgVG9vbHMsXG4gKiBwbGVhc2UgdXNlIGBzdHJlYW1VSWAgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBvdGhlciBwcm92aWRlcnMuXG4gKlxuICogQGRlcHJlY2F0ZWQgSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIGBzdHJlYW1VSWAgQVBJIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQUkgU0RLIENvcmUgQVBJc1xuICogYW5kIGZ1dHVyZSBmZWF0dXJlcy4gVGhpcyBBUEkgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXI8XG4gIFRTIGV4dGVuZHMge1xuICAgIFtuYW1lOiBzdHJpbmddOiB6LlNjaGVtYTtcbiAgfSA9IHt9LFxuICBGUyBleHRlbmRzIHtcbiAgICBbbmFtZTogc3RyaW5nXTogei5TY2hlbWE7XG4gIH0gPSB7fSxcbj4ob3B0aW9uczoge1xuICAvKipcbiAgICogVGhlIG1vZGVsIG5hbWUgdG8gdXNlLiBNdXN0IGJlIE9wZW5BSSBTREsgY29tcGF0aWJsZS4gVG9vbHMgYW5kIEZ1bmN0aW9ucyBhcmUgb25seSBzdXBwb3J0ZWRcbiAgICogR1BUIG1vZGVscyAoMy41LzQpLCBPcGVuQUkgQXNzaXN0YW50cywgTWlzdHJhbCBzbWFsbCBhbmQgbGFyZ2UsIGFuZCBGaXJld29ya3MgZmlyZWZ1bmN0aW9uLXYxLlxuICAgKlxuICAgKiBAZXhhbXBsZSBcImdwdC0zLjUtdHVyYm9cIlxuICAgKi9cbiAgbW9kZWw6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwcm92aWRlciBpbnN0YW5jZSB0byB1c2UuIEN1cnJlbnRseSB0aGUgb25seSBwcm92aWRlciBhdmFpbGFibGUgaXMgT3BlbkFJLlxuICAgKiBUaGlzIG5lZWRzIHRvIG1hdGNoIHRoZSBtb2RlbCBuYW1lLlxuICAgKi9cbiAgcHJvdmlkZXI6IE9wZW5BSTtcbiAgbWVzc2FnZXM6IFBhcmFtZXRlcnM8XG4gICAgdHlwZW9mIE9wZW5BSS5wcm90b3R5cGUuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGVcbiAgPlswXVsnbWVzc2FnZXMnXTtcbiAgdGV4dD86IFJlbmRlcmVyPHtcbiAgICAvKipcbiAgICAgKiBUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc28gZmFyLlxuICAgICAqL1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgbmV3IGFwcGVuZGVkIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzaW5jZSB0aGUgbGFzdCBgdGV4dGAgY2FsbC5cbiAgICAgKi9cbiAgICBkZWx0YTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG1vZGVsIGlzIGRvbmUgZ2VuZXJhdGluZyB0ZXh0LlxuICAgICAqIElmIGB0cnVlYCwgdGhlIGBjb250ZW50YCB3aWxsIGJlIHRoZSBmaW5hbCBvdXRwdXQgYW5kIHRoaXMgY2FsbCB3aWxsIGJlIHRoZSBsYXN0LlxuICAgICAqL1xuICAgIGRvbmU6IGJvb2xlYW47XG4gIH0+O1xuICB0b29scz86IHtcbiAgICBbbmFtZSBpbiBrZXlvZiBUU106IHtcbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAgICAgcGFyYW1ldGVyczogVFNbbmFtZV07XG4gICAgICByZW5kZXI6IFJlbmRlcmVyPHouaW5mZXI8VFNbbmFtZV0+PjtcbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbnM/OiB7XG4gICAgW25hbWUgaW4ga2V5b2YgRlNdOiB7XG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICAgIHBhcmFtZXRlcnM6IEZTW25hbWVdO1xuICAgICAgcmVuZGVyOiBSZW5kZXJlcjx6LmluZmVyPEZTW25hbWVdPj47XG4gICAgfTtcbiAgfTtcbiAgaW5pdGlhbD86IFJlYWN0Tm9kZTtcbiAgdGVtcGVyYXR1cmU/OiBudW1iZXI7XG59KTogUmVhY3ROb2RlIHtcbiAgY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkob3B0aW9ucy5pbml0aWFsKTtcblxuICAvLyBUaGUgZGVmYXVsdCB0ZXh0IHJlbmRlcmVyIGp1c3QgcmV0dXJucyB0aGUgY29udGVudCBhcyBzdHJpbmcuXG4gIGNvbnN0IHRleHQgPSBvcHRpb25zLnRleHRcbiAgICA/IG9wdGlvbnMudGV4dFxuICAgIDogKHsgY29udGVudCB9OiB7IGNvbnRlbnQ6IHN0cmluZyB9KSA9PiBjb250ZW50O1xuXG4gIGNvbnN0IGZ1bmN0aW9ucyA9IG9wdGlvbnMuZnVuY3Rpb25zXG4gICAgPyBPYmplY3QuZW50cmllcyhvcHRpb25zLmZ1bmN0aW9ucykubWFwKFxuICAgICAgICAoW25hbWUsIHsgZGVzY3JpcHRpb24sIHBhcmFtZXRlcnMgfV0pID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogem9kVG9Kc29uU2NoZW1hKHBhcmFtZXRlcnMpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICApXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgdG9vbHMgPSBvcHRpb25zLnRvb2xzXG4gICAgPyBPYmplY3QuZW50cmllcyhvcHRpb25zLnRvb2xzKS5tYXAoXG4gICAgICAgIChbbmFtZSwgeyBkZXNjcmlwdGlvbiwgcGFyYW1ldGVycyB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nIGFzIGNvbnN0LFxuICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHpvZFRvSnNvblNjaGVtYShwYXJhbWV0ZXJzKSBhcyBSZWNvcmQ8XG4gICAgICAgICAgICAgICAgc3RyaW5nLFxuICAgICAgICAgICAgICAgIHVua25vd25cbiAgICAgICAgICAgICAgPixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICA6IHVuZGVmaW5lZDtcblxuICBpZiAoZnVuY3Rpb25zICYmIHRvb2xzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2FuJ3QgaGF2ZSBib3RoIGZ1bmN0aW9ucyBhbmQgdG9vbHMgZGVmaW5lZC4gUGxlYXNlIGNob29zZSBvbmUgb3IgdGhlIG90aGVyLlwiLFxuICAgICk7XG4gIH1cblxuICBsZXQgZmluaXNoZWQ6IFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWQ7XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVuZGVyKFxuICAgIGFyZ3M6IGFueSxcbiAgICByZW5kZXJlcjogdW5kZWZpbmVkIHwgUmVuZGVyZXI8YW55PixcbiAgICByZXM6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVN0cmVhbWFibGVVST4sXG4gICkge1xuICAgIGlmICghcmVuZGVyZXIpIHJldHVybjtcblxuICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTx2b2lkPigpO1xuXG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICBmaW5pc2hlZCA9IGZpbmlzaGVkLnRoZW4oKCkgPT4gcmVzb2x2YWJsZS5wcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoZWQgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSByZW5kZXJlcihhcmdzKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgfHxcbiAgICAgICh2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICd0aGVuJyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICApIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhd2FpdCAodmFsdWUgYXMgUHJvbWlzZTxSZWFjdC5SZWFjdE5vZGU+KTtcbiAgICAgIHJlcy51cGRhdGUobm9kZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlXG4gICAgKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlIGFzIEFzeW5jR2VuZXJhdG9yPFxuICAgICAgICBSZWFjdC5SZWFjdE5vZGUsXG4gICAgICAgIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICAgICAgdm9pZFxuICAgICAgPjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWUgYXMgR2VuZXJhdG9yPFJlYWN0LlJlYWN0Tm9kZSwgUmVhY3QuUmVhY3ROb2RlLCB2b2lkPjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGl0Lm5leHQoKTtcbiAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH1cbiAgfVxuXG4gIChhc3luYyAoKSA9PiB7XG4gICAgbGV0IGhhc0Z1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGNvbnRlbnQgPSAnJztcblxuICAgIGNvbnN1bWVTdHJlYW0oXG4gICAgICBPcGVuQUlTdHJlYW0oXG4gICAgICAgIChhd2FpdCBvcHRpb25zLnByb3ZpZGVyLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgICAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgICAgLi4uKGZ1bmN0aW9uc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25zLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAuLi4odG9vbHNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSkpIGFzIGFueSxcbiAgICAgICAge1xuICAgICAgICAgIC4uLihmdW5jdGlvbnNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGFzeW5jIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChmdW5jdGlvbkNhbGxQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICBoYXNGdW5jdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFBheWxvYWQuYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZ1bmN0aW9ucz8uW2Z1bmN0aW9uQ2FsbFBheWxvYWQubmFtZSBhcyBhbnldXG4gICAgICAgICAgICAgICAgICAgICAgPy5yZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAuLi4odG9vbHNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGFzeW5jIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKHRvb2xDYWxsUGF5bG9hZDogYW55KSB7XG4gICAgICAgICAgICAgICAgICBoYXNGdW5jdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFdlIG1pZ2h0IG5lZWQgUHJvbWlzZS5hbGwgaGVyZT9cbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29sQ2FsbFBheWxvYWQudG9vbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2wuZnVuYy5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy50b29scz8uW3Rvb2wuZnVuYy5uYW1lIGFzIGFueV0/LnJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICBvblRleHQoY2h1bmspIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gY2h1bms7XG4gICAgICAgICAgICBoYW5kbGVSZW5kZXIoeyBjb250ZW50LCBkb25lOiBmYWxzZSwgZGVsdGE6IGNodW5rIH0sIHRleHQsIHVpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFzeW5jIG9uRmluYWwoKSB7XG4gICAgICAgICAgICBpZiAoaGFzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgICAgICAgIHVpLmRvbmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGVSZW5kZXIoeyBjb250ZW50LCBkb25lOiB0cnVlIH0sIHRleHQsIHVpKTtcbiAgICAgICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgdWkuZG9uZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICApLFxuICAgICk7XG4gIH0pKCk7XG5cbiAgcmV0dXJuIHVpLnZhbHVlO1xufVxuIiwiY29uc3QgbWltZVR5cGVTaWduYXR1cmVzID0gW1xuICB7IG1pbWVUeXBlOiAnaW1hZ2UvZ2lmJyBhcyBjb25zdCwgYnl0ZXM6IFsweDQ3LCAweDQ5LCAweDQ2XSB9LFxuICB7IG1pbWVUeXBlOiAnaW1hZ2UvcG5nJyBhcyBjb25zdCwgYnl0ZXM6IFsweDg5LCAweDUwLCAweDRlLCAweDQ3XSB9LFxuICB7IG1pbWVUeXBlOiAnaW1hZ2UvanBlZycgYXMgY29uc3QsIGJ5dGVzOiBbMHhmZiwgMHhkOF0gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL3dlYnAnIGFzIGNvbnN0LCBieXRlczogWzB4NTIsIDB4NDksIDB4NDYsIDB4NDZdIH0sXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0SW1hZ2VNaW1lVHlwZShcbiAgaW1hZ2U6IFVpbnQ4QXJyYXksXG4pOiAnaW1hZ2UvanBlZycgfCAnaW1hZ2UvcG5nJyB8ICdpbWFnZS9naWYnIHwgJ2ltYWdlL3dlYnAnIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChjb25zdCB7IGJ5dGVzLCBtaW1lVHlwZSB9IG9mIG1pbWVUeXBlU2lnbmF0dXJlcykge1xuICAgIGlmIChcbiAgICAgIGltYWdlLmxlbmd0aCA+PSBieXRlcy5sZW5ndGggJiZcbiAgICAgIGJ5dGVzLmV2ZXJ5KChieXRlLCBpbmRleCkgPT4gaW1hZ2VbaW5kZXhdID09PSBieXRlKVxuICAgICkge1xuICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbn0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5cbi8qKlxuRGF0YSBjb250ZW50LiBDYW4gZWl0aGVyIGJlIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLCBhIFVpbnQ4QXJyYXksIGFuIEFycmF5QnVmZmVyLCBvciBhIEJ1ZmZlci5cbiAqL1xuZXhwb3J0IHR5cGUgRGF0YUNvbnRlbnQgPSBzdHJpbmcgfCBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIgfCBCdWZmZXI7XG5cbi8qKlxuQ29udmVydHMgZGF0YSBjb250ZW50IHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50OiBEYXRhQ29udGVudCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cblxuICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChjb250ZW50KTtcbn1cblxuLyoqXG5Db252ZXJ0cyBkYXRhIGNvbnRlbnQgdG8gYSBVaW50OEFycmF5LlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShcbiAgY29udGVudDogRGF0YUNvbnRlbnQsXG4pOiBVaW50OEFycmF5IHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cblxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHsgY29udGVudCB9KTtcbn1cbiIsImltcG9ydCB7XG4gIExhbmd1YWdlTW9kZWxWMUltYWdlUGFydCxcbiAgTGFuZ3VhZ2VNb2RlbFYxTWVzc2FnZSxcbiAgTGFuZ3VhZ2VNb2RlbFYxUHJvbXB0LFxuICBMYW5ndWFnZU1vZGVsVjFUZXh0UGFydCxcbn0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBkZXRlY3RJbWFnZU1pbWVUeXBlIH0gZnJvbSAnLi4vdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUnO1xuaW1wb3J0IHsgY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5IH0gZnJvbSAnLi9kYXRhLWNvbnRlbnQnO1xuaW1wb3J0IHsgVmFsaWRhdGVkUHJvbXB0IH0gZnJvbSAnLi9nZXQtdmFsaWRhdGVkLXByb21wdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KFxuICBwcm9tcHQ6IFZhbGlkYXRlZFByb21wdCxcbik6IExhbmd1YWdlTW9kZWxWMVByb21wdCB7XG4gIGNvbnN0IGxhbmd1YWdlTW9kZWxNZXNzYWdlczogTGFuZ3VhZ2VNb2RlbFYxUHJvbXB0ID0gW107XG5cbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCkge1xuICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHsgcm9sZTogJ3N5c3RlbScsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfSk7XG4gIH1cblxuICBzd2l0Y2ggKHByb21wdC50eXBlKSB7XG4gICAgY2FzZSAncHJvbXB0Jzoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6ICd0ZXh0JywgdGV4dDogcHJvbXB0LnByb21wdCB9XSxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnbWVzc2FnZXMnOiB7XG4gICAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaChcbiAgICAgICAgLi4ucHJvbXB0Lm1lc3NhZ2VzLm1hcCgobWVzc2FnZSk6IExhbmd1YWdlTW9kZWxWMU1lc3NhZ2UgPT4ge1xuICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5yb2xlKSB7XG4gICAgICAgICAgICBjYXNlICd1c2VyJzoge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogJ3RleHQnLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoXG4gICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICAgICAgICApOiBMYW5ndWFnZU1vZGVsVjFUZXh0UGFydCB8IExhbmd1YWdlTW9kZWxWMUltYWdlUGFydCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQuaW1hZ2UgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBwYXJ0LmltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVVpbnQ4ID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LmltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlVWludDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQubWltZVR5cGUgPz8gZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZVVpbnQ4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ2Fzc2lzdGFudCc6IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogJ3RleHQnLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB7IHJvbGU6ICdhc3Npc3RhbnQnLCBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAndG9vbCc6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrOiBuZXZlciA9IHByb21wdDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJvbXB0IHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzO1xufVxuIiwiaW1wb3J0IHsgSW52YWxpZFByb21wdEVycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBDb3JlTWVzc2FnZSB9IGZyb20gJy4vbWVzc2FnZSc7XG5pbXBvcnQgeyBQcm9tcHQgfSBmcm9tICcuL3Byb21wdCc7XG5cbmV4cG9ydCB0eXBlIFZhbGlkYXRlZFByb21wdCA9XG4gIHwge1xuICAgICAgdHlwZTogJ3Byb21wdCc7XG4gICAgICBwcm9tcHQ6IHN0cmluZztcbiAgICAgIG1lc3NhZ2VzOiB1bmRlZmluZWQ7XG4gICAgICBzeXN0ZW0/OiBzdHJpbmc7XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6ICdtZXNzYWdlcyc7XG4gICAgICBwcm9tcHQ6IHVuZGVmaW5lZDtcbiAgICAgIG1lc3NhZ2VzOiBDb3JlTWVzc2FnZVtdO1xuICAgICAgc3lzdGVtPzogc3RyaW5nO1xuICAgIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWxpZGF0ZWRQcm9tcHQocHJvbXB0OiBQcm9tcHQpOiBWYWxpZGF0ZWRQcm9tcHQge1xuICBpZiAocHJvbXB0LnByb21wdCA9PSBudWxsICYmIHByb21wdC5tZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiAncHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZCcsXG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiAncHJvbXB0IGFuZCBtZXNzYWdlcyBjYW5ub3QgYmUgZGVmaW5lZCBhdCB0aGUgc2FtZSB0aW1lJyxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwcm9tcHQucHJvbXB0ICE9IG51bGxcbiAgICA/IHtcbiAgICAgICAgdHlwZTogJ3Byb21wdCcsXG4gICAgICAgIHByb21wdDogcHJvbXB0LnByb21wdCxcbiAgICAgICAgbWVzc2FnZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgfVxuICAgIDoge1xuICAgICAgICB0eXBlOiAnbWVzc2FnZXMnLFxuICAgICAgICBwcm9tcHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbWVzc2FnZXM6IHByb21wdC5tZXNzYWdlcyEsIC8vIG9ubHkgcG9zc2libGUgY2FzZSBiYyBvZiBjaGVja3MgYWJvdmVcbiAgICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgfTtcbn1cbiIsImltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBDYWxsU2V0dGluZ3MgfSBmcm9tICcuL2NhbGwtc2V0dGluZ3MnO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBjYWxsIHNldHRpbmdzIGFuZCBzZXRzIGRlZmF1bHQgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUNhbGxTZXR0aW5ncyh7XG4gIG1heFRva2VucyxcbiAgdGVtcGVyYXR1cmUsXG4gIHRvcFAsXG4gIHByZXNlbmNlUGVuYWx0eSxcbiAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgc2VlZCxcbiAgbWF4UmV0cmllcyxcbn06IENhbGxTZXR0aW5ncyk6IENhbGxTZXR0aW5ncyB7XG4gIGlmIChtYXhUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhUb2tlbnMnLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiAnbWF4VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF4VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnbWF4VG9rZW5zJyxcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogJ21heFRva2VucyBtdXN0IGJlID49IDEnLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAndGVtcGVyYXR1cmUnLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6ICd0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b3BQICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcFAgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICd0b3BQJyxcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6ICd0b3BQIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdwcmVzZW5jZVBlbmFsdHknLFxuICAgICAgICB2YWx1ZTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiAncHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgICAgICB2YWx1ZTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogJ2ZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdzZWVkJyxcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6ICdzZWVkIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhSZXRyaWVzJyxcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhSZXRyaWVzIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFJldHJpZXMnLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogJ21heFJldHJpZXMgbXVzdCBiZSA+PSAwJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF4VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSA/PyAwLFxuICAgIHRvcFAsXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc2VlZCxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzID8/IDIsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBKU09OU2NoZW1hNyB9IGZyb20gJ2pzb24tc2NoZW1hJztcbmltcG9ydCAqIGFzIHogZnJvbSAnem9kJztcbmltcG9ydCB6b2RUb0pzb25TY2hlbWEgZnJvbSAnem9kLXRvLWpzb24tc2NoZW1hJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRab2RUb0pTT05TY2hlbWEoXG4gIHpvZFNjaGVtYTogei5TY2hlbWE8dW5rbm93bj4sXG4pOiBKU09OU2NoZW1hNyB7XG4gIC8vIHdlIGFzc3VtZSB0aGF0IHpvZFRvSnNvblNjaGVtYSB3aWxsIHJldHVybiBhIHZhbGlkIEpTT05TY2hlbWE3XG4gIHJldHVybiB6b2RUb0pzb25TY2hlbWEoem9kU2NoZW1hKSBhcyBKU09OU2NoZW1hNztcbn1cbiIsImltcG9ydCB7IEFQSUNhbGxFcnJvciwgUmV0cnlFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAnLi9kZWxheSc7XG5cbmV4cG9ydCB0eXBlIFJldHJ5RnVuY3Rpb24gPSA8T1VUUFVUPihcbiAgZm46ICgpID0+IFByb21pc2VMaWtlPE9VVFBVVD4sXG4pID0+IFByb21pc2VMaWtlPE9VVFBVVD47XG5cbi8qKlxuVGhlIGByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmZgIHN0cmF0ZWd5IHJldHJpZXMgYSBmYWlsZWQgQVBJIGNhbGwgd2l0aCBhbiBleHBvbmVudGlhbCBiYWNrb2ZmLlxuWW91IGNhbiBjb25maWd1cmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMsIHRoZSBpbml0aWFsIGRlbGF5LCBhbmQgdGhlIGJhY2tvZmYgZmFjdG9yLlxuICovXG5leHBvcnQgY29uc3QgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID1cbiAgKHtcbiAgICBtYXhSZXRyaWVzID0gMixcbiAgICBpbml0aWFsRGVsYXlJbk1zID0gMjAwMCxcbiAgICBiYWNrb2ZmRmFjdG9yID0gMixcbiAgfSA9IHt9KTogUmV0cnlGdW5jdGlvbiA9PlxuICBhc3luYyA8T1VUUFVUPihmOiAoKSA9PiBQcm9taXNlTGlrZTxPVVRQVVQ+KSA9PlxuICAgIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgICAgIGJhY2tvZmZGYWN0b3IsXG4gICAgfSk7XG5cbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmY8T1VUUFVUPihcbiAgZjogKCkgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPixcbiAge1xuICAgIG1heFJldHJpZXMsXG4gICAgZGVsYXlJbk1zLFxuICAgIGJhY2tvZmZGYWN0b3IsXG4gIH06IHsgbWF4UmV0cmllczogbnVtYmVyOyBkZWxheUluTXM6IG51bWJlcjsgYmFja29mZkZhY3RvcjogbnVtYmVyIH0sXG4gIGVycm9yczogdW5rbm93bltdID0gW10sXG4pOiBQcm9taXNlPE9VVFBVVD4ge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCByZXRyeSB3aGVuIHRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkXG4gICAgfVxuXG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCB3cmFwIHRoZSBlcnJvciB3aGVuIHJldHJpZXMgYXJlIGRpc2FibGVkXG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcblxuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246ICdtYXhSZXRyaWVzRXhjZWVkZWQnLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9ycyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgIEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikgJiZcbiAgICAgIGVycm9yLmlzUmV0cnlhYmxlID09PSB0cnVlICYmXG4gICAgICB0cnlOdW1iZXIgPD0gbWF4UmV0cmllc1xuICAgICkge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yOyAvLyBkb24ndCB3cmFwIHRoZSBlcnJvciB3aGVuIGEgbm9uLXJldHJ5YWJsZSBlcnJvciBvY2N1cnMgb24gdGhlIGZpcnN0IHRyeVxuICAgIH1cblxuICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzIHdpdGggbm9uLXJldHJ5YWJsZSBlcnJvcjogJyR7ZXJyb3JNZXNzYWdlfSdgLFxuICAgICAgcmVhc29uOiAnZXJyb3JOb3RSZXRyeWFibGUnLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnMsXG4gICAgfSk7XG4gIH1cbn1cbiIsImV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5SW5NcykpO1xufVxuIiwiaW1wb3J0IHtcbiAgQXNzaXN0YW50TWVzc2FnZSxcbiAgRGF0YU1lc3NhZ2UsXG4gIEZ1bmN0aW9uQ2FsbCxcbiAgSlNPTlZhbHVlLFxuICBUb29sQ2FsbCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTdHJlYW1TdHJpbmcgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBTdHJlYW1QYXJ0PENPREUgZXh0ZW5kcyBzdHJpbmcsIE5BTUUgZXh0ZW5kcyBzdHJpbmcsIFRZUEU+IHtcbiAgY29kZTogQ09ERTtcbiAgbmFtZTogTkFNRTtcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7IHR5cGU6IE5BTUU7IHZhbHVlOiBUWVBFIH07XG59XG5cbmNvbnN0IHRleHRTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCcwJywgJ3RleHQnLCBzdHJpbmc+ID0ge1xuICBjb2RlOiAnMCcsXG4gIG5hbWU6ICd0ZXh0JyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAndGV4dCcsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnMScsXG4gICdmdW5jdGlvbl9jYWxsJyxcbiAgeyBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGwgfVxuPiA9IHtcbiAgY29kZTogJzEnLFxuICBuYW1lOiAnZnVuY3Rpb25fY2FsbCcsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ2Z1bmN0aW9uX2NhbGwnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09ICdvYmplY3QnIHx8XG4gICAgICB2YWx1ZS5mdW5jdGlvbl9jYWxsID09IG51bGwgfHxcbiAgICAgICEoJ25hbWUnIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8XG4gICAgICAhKCdhcmd1bWVudHMnIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdmdW5jdGlvbl9jYWxsJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIHsgZnVuY3Rpb25fY2FsbDogRnVuY3Rpb25DYWxsIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGRhdGFTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCcyJywgJ2RhdGEnLCBBcnJheTxKU09OVmFsdWU+PiA9IHtcbiAgY29kZTogJzInLFxuICBuYW1lOiAnZGF0YScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdkYXRhJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGVycm9yU3RyZWFtUGFydDogU3RyZWFtUGFydDwnMycsICdlcnJvcicsIHN0cmluZz4gPSB7XG4gIGNvZGU6ICczJyxcbiAgbmFtZTogJ2Vycm9yJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJlcnJvclwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ2Vycm9yJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNCcsXG4gICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gIEFzc2lzdGFudE1lc3NhZ2Vcbj4gPSB7XG4gIGNvZGU6ICc0JyxcbiAgbmFtZTogJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgnaWQnIGluIHZhbHVlKSB8fFxuICAgICAgISgncm9sZScgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdjb250ZW50JyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5pZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5yb2xlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdmFsdWUucm9sZSAhPT0gJ2Fzc2lzdGFudCcgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8XG4gICAgICAhdmFsdWUuY29udGVudC5ldmVyeShcbiAgICAgICAgaXRlbSA9PlxuICAgICAgICAgIGl0ZW0gIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICd0eXBlJyBpbiBpdGVtICYmXG4gICAgICAgICAgaXRlbS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgICAndGV4dCcgaW4gaXRlbSAmJlxuICAgICAgICAgIGl0ZW0udGV4dCAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0udGV4dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAndmFsdWUnIGluIGl0ZW0udGV4dCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtLnRleHQudmFsdWUgPT09ICdzdHJpbmcnLFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgQXNzaXN0YW50TWVzc2FnZSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNScsXG4gICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAge1xuICAgIHRocmVhZElkOiBzdHJpbmc7XG4gICAgbWVzc2FnZUlkOiBzdHJpbmc7XG4gIH1cbj4gPSB7XG4gIGNvZGU6ICc1JyxcbiAgbmFtZTogJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCd0aHJlYWRJZCcgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdtZXNzYWdlSWQnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGRhdGFNZXNzYWdlU3RyZWFtUGFydDogU3RyZWFtUGFydDwnNicsICdkYXRhX21lc3NhZ2UnLCBEYXRhTWVzc2FnZT4gPSB7XG4gIGNvZGU6ICc2JyxcbiAgbmFtZTogJ2RhdGFfbWVzc2FnZScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3JvbGUnIGluIHZhbHVlKSB8fFxuICAgICAgISgnZGF0YScgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUucm9sZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHZhbHVlLnJvbGUgIT09ICdkYXRhJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJkYXRhX21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInJvbGVcIiBhbmQgXCJkYXRhXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdkYXRhX21lc3NhZ2UnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIERhdGFNZXNzYWdlLFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCB0b29sQ2FsbFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc3JyxcbiAgJ3Rvb2xfY2FsbHMnLFxuICB7IHRvb2xfY2FsbHM6IFRvb2xDYWxsW10gfVxuPiA9IHtcbiAgY29kZTogJzcnLFxuICBuYW1lOiAndG9vbF9jYWxscycsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3Rvb2xfY2FsbHMnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRvb2xfY2FsbHMgIT09ICdvYmplY3QnIHx8XG4gICAgICB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLnRvb2xfY2FsbHMpIHx8XG4gICAgICB2YWx1ZS50b29sX2NhbGxzLnNvbWUoXG4gICAgICAgIHRjID0+XG4gICAgICAgICAgdGMgPT0gbnVsbCB8fFxuICAgICAgICAgIHR5cGVvZiB0YyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAhKCdpZCcgaW4gdGMpIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmlkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICEoJ3R5cGUnIGluIHRjKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy50eXBlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICEoJ2Z1bmN0aW9uJyBpbiB0YykgfHxcbiAgICAgICAgICB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICEoJ2FyZ3VtZW50cycgaW4gdGMuZnVuY3Rpb24pIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uLm5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gJ3N0cmluZycsXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0b29sX2NhbGxzJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIHsgdG9vbF9jYWxsczogVG9vbENhbGxbXSB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnOCcsXG4gICdtZXNzYWdlX2Fubm90YXRpb25zJyxcbiAgQXJyYXk8SlNPTlZhbHVlPlxuPiA9IHtcbiAgY29kZTogJzgnLFxuICBuYW1lOiAnbWVzc2FnZV9hbm5vdGF0aW9ucycsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdtZXNzYWdlX2Fubm90YXRpb25zJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IHN0cmVhbVBhcnRzID0gW1xuICB0ZXh0U3RyZWFtUGFydCxcbiAgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgZGF0YVN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG5dIGFzIGNvbnN0O1xuXG4vLyB1bmlvbiB0eXBlIG9mIGFsbCBzdHJlYW0gcGFydHNcbnR5cGUgU3RyZWFtUGFydHMgPVxuICB8IHR5cGVvZiB0ZXh0U3RyZWFtUGFydFxuICB8IHR5cGVvZiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGRhdGFTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGVycm9yU3RyZWFtUGFydFxuICB8IHR5cGVvZiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydFxuICB8IHR5cGVvZiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIHRvb2xDYWxsU3RyZWFtUGFydFxuICB8IHR5cGVvZiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0O1xuLyoqXG4gKiBNYXBzIHRoZSB0eXBlIG9mIGEgc3RyZWFtIHBhcnQgdG8gaXRzIHZhbHVlIHR5cGUuXG4gKi9cbnR5cGUgU3RyZWFtUGFydFZhbHVlVHlwZSA9IHtcbiAgW1AgaW4gU3RyZWFtUGFydHMgYXMgUFsnbmFtZSddXTogUmV0dXJuVHlwZTxQWydwYXJzZSddPlsndmFsdWUnXTtcbn07XG5cbmV4cG9ydCB0eXBlIFN0cmVhbVBhcnRUeXBlID1cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiB0ZXh0U3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGRhdGFTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGVycm9yU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIHRvb2xDYWxsU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LnBhcnNlPjtcblxuZXhwb3J0IGNvbnN0IHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogVGhlIG1hcCBvZiBwcmVmaXhlcyBmb3IgZGF0YSBpbiB0aGUgc3RyZWFtXG4gKlxuICogLSAwOiBUZXh0IGZyb20gdGhlIExMTSByZXNwb25zZVxuICogLSAxOiAoT3BlbkFJKSBmdW5jdGlvbl9jYWxsIHJlc3BvbnNlc1xuICogLSAyOiBjdXN0b20gSlNPTiBhZGRlZCBieSB0aGUgdXNlciB1c2luZyBgRGF0YWBcbiAqIC0gNjogKE9wZW5BSSkgdG9vbF9jYWxsIHJlc3BvbnNlc1xuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBcbiAqIDA6VmVyY2VsXG4gKiAwOidzXG4gKiAwOiBBSVxuICogMDogQUlcbiAqIDA6IFNES1xuICogMDogaXMgZ3JlYXRcbiAqIDA6IVxuICogMjogeyBcInNvbWVKc29uXCI6IFwidmFsdWVcIiB9XG4gKiAxOiB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCJnZXRfY3VycmVudF93ZWF0aGVyXCIsIFwiYXJndW1lbnRzXCI6IFwie1xcXFxuXFxcXFwibG9jYXRpb25cXFxcXCI6IFxcXFxcIkNoYXJsb3R0ZXN2aWxsZSwgVmlyZ2luaWFcXFxcXCIsXFxcXG5cXFxcXCJmb3JtYXRcXFxcXCI6IFxcXFxcImNlbHNpdXNcXFxcXCJcXFxcbn1cIn19XG4gKiA2OiB7XCJ0b29sX2NhbGxcIjoge1wiaWRcIjogXCJ0b29sXzBcIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiZ2V0X2N1cnJlbnRfd2VhdGhlclwiLCBcImFyZ3VtZW50c1wiOiBcIntcXFxcblxcXFxcImxvY2F0aW9uXFxcXFwiOiBcXFxcXCJDaGFybG90dGVzdmlsbGUsIFZpcmdpbmlhXFxcXFwiLFxcXFxuXFxcXFwiZm9ybWF0XFxcXFwiOiBcXFxcXCJjZWxzaXVzXFxcXFwiXFxcXG59XCJ9fX1cbiAqYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Lm5hbWVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGUsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgdmFsaWRDb2RlcyA9IHN0cmVhbVBhcnRzLm1hcChwYXJ0ID0+IHBhcnQuY29kZSk7XG5cbi8qKlxuUGFyc2VzIGEgc3RyZWFtIHBhcnQgZnJvbSBhIHN0cmluZy5cblxuQHBhcmFtIGxpbmUgVGhlIHN0cmluZyB0byBwYXJzZS5cbkByZXR1cm5zIFRoZSBwYXJzZWQgc3RyZWFtIHBhcnQuXG5AdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBzdHJpbmcgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlU3RyZWFtUGFydCA9IChsaW5lOiBzdHJpbmcpOiBTdHJlYW1QYXJ0VHlwZSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcblxuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuJyk7XG4gIH1cblxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuXG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXggYXMga2V5b2YgdHlwZW9mIHN0cmVhbVBhcnRzQnlDb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cblxuICBjb25zdCBjb2RlID0gcHJlZml4IGFzIGtleW9mIHR5cGVvZiBzdHJlYW1QYXJ0c0J5Q29kZTtcblxuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlOiBKU09OVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG5cbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuXG4vKipcblByZXBlbmRzIGEgc3RyaW5nIHdpdGggYSBwcmVmaXggZnJvbSB0aGUgYFN0cmVhbUNodW5rUHJlZml4ZXNgLCBKU09OLWlmaWVzIGl0LFxuYW5kIGFwcGVuZHMgYSBuZXcgbGluZS5cblxuSXQgZW5zdXJlcyB0eXBlLXNhZmV0eSBmb3IgdGhlIHBhcnQgdHlwZSBhbmQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTdHJlYW1QYXJ0PFQgZXh0ZW5kcyBrZXlvZiBTdHJlYW1QYXJ0VmFsdWVUeXBlPihcbiAgdHlwZTogVCxcbiAgdmFsdWU6IFN0cmVhbVBhcnRWYWx1ZVR5cGVbVF0sXG4pOiBTdHJlYW1TdHJpbmcge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZChwYXJ0ID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG5cbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiBgJHtzdHJlYW1QYXJ0LmNvZGV9OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVxcbmA7XG59XG4iLCJpbXBvcnQge1xuICBTdHJlYW1QYXJ0VHlwZSxcbiAgU3RyZWFtU3RyaW5nUHJlZml4ZXMsXG4gIHBhcnNlU3RyZWFtUGFydCxcbn0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuXG5leHBvcnQgKiBmcm9tICcuL2dlbmVyYXRlLWlkJztcblxuLy8gVE9ETyByZW1vdmUgKGJyZWFraW5nIGNoYW5nZSlcbmV4cG9ydCB7IGdlbmVyYXRlSWQgYXMgbmFub2lkIH0gZnJvbSAnLi9nZW5lcmF0ZS1pZCc7XG5cbi8vIEV4cG9ydCBzdHJlYW0gZGF0YSB1dGlsaXRpZXMgZm9yIGN1c3RvbSBzdHJlYW0gaW1wbGVtZW50YXRpb25zLFxuLy8gYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZS5cbmV4cG9ydCB0eXBlIHsgU3RyZWFtUGFydCB9IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcbmV4cG9ydCB7IGZvcm1hdFN0cmVhbVBhcnQsIHBhcnNlU3RyZWFtUGFydCB9IGZyb20gJy4vc3RyZWFtLXBhcnRzJztcbmV4cG9ydCB7IHJlYWREYXRhU3RyZWFtIH0gZnJvbSAnLi9yZWFkLWRhdGEtc3RyZWFtJztcblxuLy8gc2ltcGxlIGRlY29kZXIgc2lnbmF0dXJlczpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcigpOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IHN0cmluZztcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleDogZmFsc2UsXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IHN0cmluZztcbi8vIGNvbXBsZXggZGVjb2RlciBzaWduYXR1cmU6XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg6IHRydWUsXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IFN0cmVhbVBhcnRUeXBlW107XG4vLyBjb21iaW5lZCBzaWduYXR1cmUgZm9yIHdoZW4gdGhlIGNsaWVudCBjYWxscyB0aGlzIGZ1bmN0aW9uIHdpdGggYSBib29sZWFuOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4PzogYm9vbGVhbixcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gU3RyZWFtUGFydFR5cGVbXSB8IHN0cmluZztcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4PzogYm9vbGVhbikge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gICAgICBpZiAoIWNodW5rKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXJcbiAgICAgIC5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZSAhPT0gJycpOyAvLyBzcGxpdHRpbmcgbGVhdmVzIGFuIGVtcHR5IHN0cmluZyBhdCB0aGUgZW5kXG5cbiAgICByZXR1cm4gZGVjb2RlZC5tYXAocGFyc2VTdHJlYW1QYXJ0KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUNodW5rRGVjb2RlciB9O1xuXG5leHBvcnQgY29uc3QgaXNTdHJlYW1TdHJpbmdFcXVhbFRvVHlwZSA9IChcbiAgdHlwZToga2V5b2YgdHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzLFxuICB2YWx1ZTogc3RyaW5nLFxuKTogdmFsdWUgaXMgU3RyZWFtU3RyaW5nID0+XG4gIHZhbHVlLnN0YXJ0c1dpdGgoYCR7U3RyZWFtU3RyaW5nUHJlZml4ZXNbdHlwZV19OmApICYmIHZhbHVlLmVuZHNXaXRoKCdcXG4nKTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtU3RyaW5nID1cbiAgYCR7KHR5cGVvZiBTdHJlYW1TdHJpbmdQcmVmaXhlcylba2V5b2YgdHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzXX06JHtzdHJpbmd9XFxuYDtcbiIsImltcG9ydCB7XG4gIGNyZWF0ZVBhcnNlcixcbiAgdHlwZSBFdmVudFNvdXJjZVBhcnNlcixcbiAgdHlwZSBQYXJzZWRFdmVudCxcbiAgdHlwZSBSZWNvbm5lY3RJbnRlcnZhbCxcbn0gZnJvbSAnZXZlbnRzb3VyY2UtcGFyc2VyJztcbmltcG9ydCB7IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyB9IGZyb20gJy4vb3BlbmFpLXN0cmVhbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25DYWxsUGF5bG9hZCB7XG4gIG5hbWU6IHN0cmluZztcbiAgYXJndW1lbnRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGxQYXlsb2FkIHtcbiAgdG9vbHM6IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHR5cGU6ICdmdW5jdGlvbic7XG4gICAgZnVuYzoge1xuICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgYXJndW1lbnRzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICB9O1xuICB9W107XG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGFuZCBoZWxwZXIgY2FsbGJhY2sgbWV0aG9kcyBmb3IgQUlTdHJlYW0gc3RyZWFtIGxpZmVjeWNsZSBldmVudHMuXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zIHtcbiAgLyoqIGBvblN0YXJ0YDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGluaXRpYWxpemVkLiAqL1xuICBvblN0YXJ0PzogKCkgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25Db21wbGV0aW9uYDogQ2FsbGVkIGZvciBlYWNoIHRva2VuaXplZCBtZXNzYWdlLiAqL1xuICBvbkNvbXBsZXRpb24/OiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvbkZpbmFsYDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGNsb3NlZCB3aXRoIHRoZSBmaW5hbCBjb21wbGV0aW9uIG1lc3NhZ2UuICovXG4gIG9uRmluYWw/OiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvblRva2VuYDogQ2FsbGVkIGZvciBlYWNoIHRva2VuaXplZCBtZXNzYWdlLiAqL1xuICBvblRva2VuPzogKHRva2VuOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uVGV4dGA6IENhbGxlZCBmb3IgZWFjaCB0ZXh0IGNodW5rLiAqL1xuICBvblRleHQ/OiAodGV4dDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgZmxhZyBpcyBubyBsb25nZXIgdXNlZCBhbmQgb25seSByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAqIFlvdSBjYW4gcmVtb3ZlIGl0IGZyb20geW91ciBjb2RlLlxuICAgKi9cbiAgZXhwZXJpbWVudGFsX3N0cmVhbURhdGE/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSBBSVN0cmVhbVBhcnNlci5cbiAqIEBpbnRlcmZhY2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBldmVudCAtIFRoZSBldmVudCAodHlwZSkgZnJvbSB0aGUgc2VydmVyIHNpZGUgZXZlbnQgc3RyZWFtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFJU3RyZWFtUGFyc2VyT3B0aW9ucyB7XG4gIGV2ZW50Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEN1c3RvbSBwYXJzZXIgZm9yIEFJU3RyZWFtIGRhdGEuXG4gKiBAaW50ZXJmYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBkYXRhIHRvIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSB7QUlTdHJlYW1QYXJzZXJPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBwYXJzZXIuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdm9pZH0gVGhlIHBhcnNlZCBkYXRhIG9yIHZvaWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlTdHJlYW1QYXJzZXIge1xuICAoZGF0YTogc3RyaW5nLCBvcHRpb25zOiBBSVN0cmVhbVBhcnNlck9wdGlvbnMpOlxuICAgIHwgc3RyaW5nXG4gICAgfCB2b2lkXG4gICAgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBUcmFuc2Zvcm1TdHJlYW0gdGhhdCBwYXJzZXMgZXZlbnRzIGZyb20gYW4gRXZlbnRTb3VyY2Ugc3RyZWFtIHVzaW5nIGEgY3VzdG9tIHBhcnNlci5cbiAqIEBwYXJhbSB7QUlTdHJlYW1QYXJzZXJ9IGN1c3RvbVBhcnNlciAtIEZ1bmN0aW9uIHRvIGhhbmRsZSBldmVudCBkYXRhLlxuICogQHJldHVybnMge1RyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBzdHJpbmc+fSBUcmFuc2Zvcm1TdHJlYW0gcGFyc2luZyBldmVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKFxuICBjdXN0b21QYXJzZXI/OiBBSVN0cmVhbVBhcnNlcixcbik6IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBzdHJpbmcgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9PiB7XG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBldmVudFNvdXJjZVBhcnNlcjogRXZlbnRTb3VyY2VQYXJzZXI7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyID0gY3JlYXRlUGFyc2VyKFxuICAgICAgICAoZXZlbnQ6IFBhcnNlZEV2ZW50IHwgUmVjb25uZWN0SW50ZXJ2YWwpID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoJ2RhdGEnIGluIGV2ZW50ICYmXG4gICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09ICdldmVudCcgJiZcbiAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9PT0gJ1tET05FXScpIHx8XG4gICAgICAgICAgICAvLyBSZXBsaWNhdGUgZG9lc24ndCBzZW5kIFtET05FXSBidXQgZG9lcyBzZW5kIGEgJ2RvbmUnIGV2ZW50XG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vcmVwbGljYXRlLmNvbS9kb2NzL3N0cmVhbWluZ1xuICAgICAgICAgICAgKGV2ZW50IGFzIGFueSkuZXZlbnQgPT09ICdkb25lJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ2RhdGEnIGluIGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gY3VzdG9tUGFyc2VyXG4gICAgICAgICAgICAgID8gY3VzdG9tUGFyc2VyKGV2ZW50LmRhdGEsIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudC5ldmVudCxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICA6IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSkgY29udHJvbGxlci5lbnF1ZXVlKHBhcnNlZE1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIuZmVlZCh0ZXh0RGVjb2Rlci5kZWNvZGUoY2h1bmspKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSB0aGF0IGVuY29kZXMgaW5wdXQgbWVzc2FnZXMgYW5kIGludm9rZXMgb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogVGhlIHRyYW5zZm9ybSBzdHJlYW0gdXNlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIHRvIGV4ZWN1dGUgY3VzdG9tIGxvZ2ljIGF0IGRpZmZlcmVudCBzdGFnZXMgb2YgdGhlIHN0cmVhbSdzIGxpZmVjeWNsZS5cbiAqIC0gYG9uU3RhcnRgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgaW5pdGlhbGl6ZWQuXG4gKiAtIGBvblRva2VuYDogQ2FsbGVkIGZvciBlYWNoIHRva2VuaXplZCBtZXNzYWdlLlxuICogLSBgb25Db21wbGV0aW9uYDogQ2FsbGVkIGV2ZXJ5IHRpbWUgYW4gQUlTdHJlYW0gY29tcGxldGlvbiBtZXNzYWdlIGlzIHJlY2VpdmVkLiBUaGlzIGNhbiBvY2N1ciBtdWx0aXBsZSB0aW1lcyB3aGVuIHVzaW5nIGUuZy4gT3BlbkFJIGZ1bmN0aW9uc1xuICogLSBgb25GaW5hbGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBjbG9zZWQgd2l0aCB0aGUgZmluYWwgY29tcGxldGlvbiBtZXNzYWdlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gcHJvY2VzcyBhIHN0cmVhbSBvZiBtZXNzYWdlcyBhbmQgcGVyZm9ybSBzcGVjaWZpYyBhY3Rpb25zIGR1cmluZyB0aGUgc3RyZWFtJ3MgbGlmZWN5Y2xlLlxuICpcbiAqIEBwYXJhbSB7QUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zfSBbY2FsbGJhY2tzXSAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1TdHJlYW08c3RyaW5nLCBVaW50OEFycmF5Pn0gQSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgZW5jb2RlcyBpbnB1dCBtZXNzYWdlcyBhcyBVaW50OEFycmF5IGFuZCBhbGxvd3MgdGhlIGV4ZWN1dGlvbiBvZiBjdXN0b20gbG9naWMgdGhyb3VnaCBjYWxsYmFja3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGNhbGxiYWNrcyA9IHtcbiAqICAgb25TdGFydDogYXN5bmMgKCkgPT4gY29uc29sZS5sb2coJ1N0cmVhbSBzdGFydGVkJyksXG4gKiAgIG9uVG9rZW46IGFzeW5jICh0b2tlbikgPT4gY29uc29sZS5sb2coYFRva2VuOiAke3Rva2VufWApLFxuICogICBvbkNvbXBsZXRpb246IGFzeW5jIChjb21wbGV0aW9uKSA9PiBjb25zb2xlLmxvZyhgQ29tcGxldGlvbjogJHtjb21wbGV0aW9ufWApXG4gKiAgIG9uRmluYWw6IGFzeW5jICgpID0+IGRhdGEuY2xvc2UoKVxuICogfTtcbiAqIGNvbnN0IHRyYW5zZm9ybWVyID0gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICBjYjogQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zIHwgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIHwgdW5kZWZpbmVkLFxuKTogVHJhbnNmb3JtU3RyZWFtPHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0sIFVpbnQ4QXJyYXk+IHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9ICcnO1xuICBjb25zdCBjYWxsYmFja3MgPSBjYiB8fCB7fTtcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uU3RhcnQpIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgfSxcblxuICAgIGFzeW5jIHRyYW5zZm9ybShtZXNzYWdlLCBjb250cm9sbGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gbWVzc2FnZSA6IG1lc3NhZ2UuY29udGVudDtcblxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShjb250ZW50KSk7XG5cbiAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBjb250ZW50O1xuXG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKGNvbnRlbnQpO1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRleHQgJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRleHQobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGZsdXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgaXNPcGVuQUlDYWxsYmFja3MgPSBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhjYWxsYmFja3MpO1xuICAgICAgLy8gSWYgaXQncyBPcGVuQUlDYWxsYmFja3MsIGl0IGhhcyBhbiBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgd2hpY2ggbWVhbnMgdGhhdCB0aGUgY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXJcbiAgICAgIC8vIHdpbGwgaGFuZGxlIGNhbGxpbmcgb25Db21wbGV0ZS5cbiAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmICFpc09wZW5BSUNhbGxiYWNrcykge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyhcbiAgY2FsbGJhY2tzOiBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgfCBPcGVuQUlTdHJlYW1DYWxsYmFja3MsXG4pOiBjYWxsYmFja3MgaXMgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIHtcbiAgcmV0dXJuICdleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwnIGluIGNhbGxiYWNrcztcbn1cbi8qKlxuICogUmV0dXJucyBhIHN0YXRlZnVsIGZ1bmN0aW9uIHRoYXQsIHdoZW4gaW52b2tlZCwgdHJpbXMgbGVhZGluZyB3aGl0ZXNwYWNlXG4gKiBmcm9tIHRoZSBpbnB1dCB0ZXh0LiBUaGUgdHJpbW1pbmcgb25seSBvY2N1cnMgb24gdGhlIGZpcnN0IGludm9jYXRpb24sIGVuc3VyaW5nIHRoYXRcbiAqIHN1YnNlcXVlbnQgY2FsbHMgZG8gbm90IGFsdGVyIHRoZSBpbnB1dCB0ZXh0LiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgaW4gc2NlbmFyaW9zXG4gKiB3aGVyZSBhIHRleHQgc3RyZWFtIGlzIGJlaW5nIHByb2Nlc3NlZCBhbmQgb25seSB0aGUgaW5pdGlhbCB3aGl0ZXNwYWNlIHNob3VsZCBiZSByZW1vdmVkLlxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKHN0cmluZyk6IHN0cmluZ30gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc3RyaW5nIGFzIGlucHV0IGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gKiB3aXRoIGxlYWRpbmcgd2hpdGVzcGFjZSByZW1vdmVkIGlmIGl0IGlzIHRoZSBmaXJzdCBpbnZvY2F0aW9uOyBvdGhlcndpc2UsIGl0IHJldHVybnMgdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgdHJpbVN0YXJ0ID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAqIGNvbnN0IG91dHB1dDEgPSB0cmltU3RhcnQoXCIgICB0ZXh0XCIpOyAvLyBcInRleHRcIlxuICogY29uc3Qgb3V0cHV0MiA9IHRyaW1TdGFydChcIiAgIHRleHRcIik7IC8vIFwiICAgdGV4dFwiXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTogKHRleHQ6IHN0cmluZykgPT4gc3RyaW5nIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuXG4gIHJldHVybiAodGV4dDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICBpZiAoaXNTdHJlYW1TdGFydCkge1xuICAgICAgdGV4dCA9IHRleHQudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dCkgaXNTdHJlYW1TdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgUmVhZGFibGVTdHJlYW0gY3JlYXRlZCBmcm9tIHRoZSByZXNwb25zZSwgcGFyc2VkIGFuZCBoYW5kbGVkIHdpdGggY3VzdG9tIGxvZ2ljLlxuICogVGhlIHN0cmVhbSBnb2VzIHRocm91Z2ggdHdvIHRyYW5zZm9ybWF0aW9uIHN0YWdlcywgZmlyc3QgcGFyc2luZyB0aGUgZXZlbnRzIGFuZCB0aGVuXG4gKiBpbnZva2luZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzLlxuICpcbiAqIEZvciAyeHggSFRUUCByZXNwb25zZXM6XG4gKiAtIFRoZSBmdW5jdGlvbiBjb250aW51ZXMgd2l0aCBzdGFuZGFyZCBzdHJlYW0gcHJvY2Vzc2luZy5cbiAqXG4gKiBGb3Igbm9uLTJ4eCBIVFRQIHJlc3BvbnNlczpcbiAqIC0gSWYgdGhlIHJlc3BvbnNlIGJvZHkgaXMgZGVmaW5lZCwgaXQgYXN5bmNocm9ub3VzbHkgZXh0cmFjdHMgYW5kIGRlY29kZXMgdGhlIHJlc3BvbnNlIGJvZHkuXG4gKiAtIEl0IHRoZW4gY3JlYXRlcyBhIGN1c3RvbSBSZWFkYWJsZVN0cmVhbSB0byBwcm9wYWdhdGUgYSBkZXRhaWxlZCBlcnJvciBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlLlxuICogQHBhcmFtIHtBSVN0cmVhbVBhcnNlcn0gY3VzdG9tUGFyc2VyIC0gVGhlIGN1c3RvbSBwYXJzZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9uc30gY2FsbGJhY2tzIC0gVGhlIGNhbGxiYWNrcy5cbiAqIEByZXR1cm4ge1JlYWRhYmxlU3RyZWFtfSBUaGUgQUlTdHJlYW0uXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHJlc3BvbnNlIGlzIG5vdCBPSy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEFJU3RyZWFtKFxuICByZXNwb25zZTogUmVzcG9uc2UsXG4gIGN1c3RvbVBhcnNlcj86IEFJU3RyZWFtUGFyc2VyLFxuICBjYWxsYmFja3M/OiBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMsXG4pOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PiB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JUZXh0fWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcignUmVzcG9uc2UgZXJyb3I6IE5vIHJlc3BvbnNlIGJvZHknKSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXNwb25zZUJvZHlTdHJlYW0gPSByZXNwb25zZS5ib2R5IHx8IGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKTtcblxuICByZXR1cm4gcmVzcG9uc2VCb2R5U3RyZWFtXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSlcbiAgICAucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSk7XG59XG5cbi8vIG91dHB1dHMgbGluZXMgbGlrZVxuLy8gMDogY2h1bmtcbi8vIDA6IG1vcmUgY2h1bmtcbi8vIDE6IGEgZmN0IGNhbGxcbi8vIHo6IGFkZGVkIGRhdGEgZnJvbSBEYXRhXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBSZWFkYWJsZVN0cmVhbSB0aGF0IGltbWVkaWF0ZWx5IGNsb3NlcyB1cG9uIGNyZWF0aW9uLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGFzIGEgZmFsbGJhY2sgZm9yIGNyZWF0aW5nIGEgUmVhZGFibGVTdHJlYW0gd2hlbiB0aGUgcmVzcG9uc2UgYm9keSBpcyBudWxsIG9yIHVuZGVmaW5lZCxcbiAqIGVuc3VyaW5nIHRoYXQgdGhlIHN1YnNlcXVlbnQgcGlwZWxpbmUgcHJvY2Vzc2luZyBkb2Vzbid0IGZhaWwgZHVlIHRvIGEgbGFjayBvZiBhIHN0cmVhbS5cbiAqXG4gKiBAcmV0dXJucyB7UmVhZGFibGVTdHJlYW19IEFuIGVtcHR5IGFuZCBjbG9zZWQgUmVhZGFibGVTdHJlYW0gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKTogUmVhZGFibGVTdHJlYW0ge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBSZWFkYWJsZVN0cmVhbS5mcm9tKGFzeW5jSXRlcmFibGUpLCB3aGljaCBpc24ndCBkb2N1bWVudGVkIGluIE1ETiBhbmQgaXNuJ3QgaW1wbGVtZW50ZWQgaW4gbm9kZS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvc3RyZWFtcy9jb21taXQvOGQ3YTBiZjI2ZWIyY2MyM2U4ODRkZGJhYWM3YzFkYTRiOTFjZjJiY1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZTxUPihpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUPikge1xuICBsZXQgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbTxUPih7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSkgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgZWxzZSBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWwocmVhc29uKSB7XG4gICAgICBhd2FpdCBpdC5yZXR1cm4/LihyZWFzb24pO1xuICAgIH0sXG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgZm9ybWF0U3RyZWFtUGFydCB9IGZyb20gJy4uL3NoYXJlZC9zdHJlYW0tcGFydHMnO1xuaW1wb3J0IHsgSlNPTlZhbHVlIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuLyoqXG4gKiBBIHN0cmVhbSB3cmFwcGVyIHRvIHNlbmQgY3VzdG9tIEpTT04tZW5jb2RlZCBkYXRhIGJhY2sgdG8gdGhlIGNsaWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbURhdGEge1xuICBwcml2YXRlIGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICBwcml2YXRlIGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFVpbnQ4QXJyYXk+IHwgbnVsbCA9XG4gICAgbnVsbDtcbiAgcHVibGljIHN0cmVhbTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+O1xuXG4gIC8vIGNsb3NpbmcgdGhlIHN0cmVhbSBpcyBzeW5jaHJvbm91cywgYnV0IHdlIHdhbnQgdG8gcmV0dXJuIGEgcHJvbWlzZVxuICAvLyBpbiBjYXNlIHdlJ3JlIGRvaW5nIGFzeW5jIHdvcmtcbiAgcHJpdmF0ZSBpc0Nsb3NlZFByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0Nsb3NlZFByb21pc2VSZXNvbHZlcjogdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpID0gdW5kZWZpbmVkO1xuICBwcml2YXRlIGlzQ2xvc2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gYXJyYXkgdG8gc3RvcmUgYXBwZW5kZWQgZGF0YVxuICBwcml2YXRlIGRhdGE6IEpTT05WYWx1ZVtdID0gW107XG4gIHByaXZhdGUgbWVzc2FnZUFubm90YXRpb25zOiBKU09OVmFsdWVbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaXNDbG9zZWRQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZVJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuc3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBzdGFydDogYXN5bmMgY29udHJvbGxlciA9PiB7XG4gICAgICAgIHNlbGYuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgLy8gYWRkIGJ1ZmZlcmVkIGRhdGEgdG8gdGhlIHN0cmVhbVxuICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IHNlbGYuZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KCdkYXRhJywgc2VsZi5kYXRhKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlbGYuZGF0YSA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlZE1lc3NhZ2VBbm5vdGF0aW9ucyA9IHNlbGYuZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KCdtZXNzYWdlX2Fubm90YXRpb25zJywgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZE1lc3NhZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgLy8gU2hvdyBhIHdhcm5pbmcgZHVyaW5nIGRldiBpZiB0aGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZyBhZnRlciAzIHNlY29uZHMuXG4gICAgICAgIGNvbnN0IHdhcm5pbmdUaW1lb3V0ID1cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50J1xuICAgICAgICAgICAgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAnVGhlIGRhdGEgc3RyZWFtIGlzIGhhbmdpbmcuIERpZCB5b3UgZm9yZ2V0IHRvIGNsb3NlIGl0IHdpdGggYGRhdGEuY2xvc2UoKWA/JyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9LCAzMDAwKVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIGF3YWl0IHNlbGYuaXNDbG9zZWRQcm9taXNlO1xuXG4gICAgICAgIGlmICh3YXJuaW5nVGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoJ2RhdGEnLCBzZWxmLmRhdGEpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkRGF0YSA9IHNlbGYuZW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KCdtZXNzYWdlX2Fubm90YXRpb25zJywgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZVJlc29sdmVyPy4oKTtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGFwcGVuZCh2YWx1ZTogSlNPTlZhbHVlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICB9XG5cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWU6IEpTT05WYWx1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIHRoaXMubWVzc2FnZUFubm90YXRpb25zLnB1c2godmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogQSBUcmFuc2Zvcm1TdHJlYW0gZm9yIExMTXMgdGhhdCBkbyBub3QgaGF2ZSB0aGVpciBvd24gdHJhbnNmb3JtIHN0cmVhbSBoYW5kbGVycyBtYW5hZ2luZyBlbmNvZGluZyAoZS5nLiBPcGVuQUlTdHJlYW0gaGFzIG9uZSBmb3IgZnVuY3Rpb24gY2FsbCBoYW5kbGluZykuXG4gKiBUaGlzIGFzc3VtZXMgZXZlcnkgY2h1bmsgaXMgYSAndGV4dCcgY2h1bmsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIG1lc3NhZ2UpKSk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuQGRlcHJlY2F0ZWQgVXNlIGBTdHJlYW1EYXRhYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEgZXh0ZW5kcyBTdHJlYW1EYXRhIHt9XG4iLCJpbXBvcnQgeyBmb3JtYXRTdHJlYW1QYXJ0IH0gZnJvbSAnLi4vc2hhcmVkL3N0cmVhbS1wYXJ0cyc7XG5pbXBvcnQge1xuICBDcmVhdGVNZXNzYWdlLFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgVG9vbENhbGwsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVDaHVua0RlY29kZXIgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMnO1xuXG5pbXBvcnQge1xuICBBSVN0cmVhbSxcbiAgdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIsXG4gIHR5cGUgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zLFxuICBGdW5jdGlvbkNhbGxQYXlsb2FkLFxuICByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlLFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgVG9vbENhbGxQYXlsb2FkLFxufSBmcm9tICcuL2FpLXN0cmVhbSc7XG5pbXBvcnQgeyBBenVyZUNoYXRDb21wbGV0aW9ucyB9IGZyb20gJy4vYXp1cmUtb3BlbmFpLXR5cGVzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciB9IGZyb20gJy4vc3RyZWFtLWRhdGEnO1xuXG5leHBvcnQgdHlwZSBPcGVuQUlTdHJlYW1DYWxsYmFja3MgPSBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgJiB7XG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTA2MTMnLFxuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICBmdW5jdGlvbnMsXG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbDogYXN5bmMgKGZ1bmN0aW9uQ2FsbFBheWxvYWQsIGNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgICAvLyAuLi4gcnVuIHlvdXIgY3VzdG9tIGxvZ2ljIGhlcmVcbiAgICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG15RnVuY3Rpb24oZnVuY3Rpb25DYWxsUGF5bG9hZClcbiAgICpcbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0wNjEzJyxcbiAgICogICAgICAgc3RyZWFtOiB0cnVlLFxuICAgKiAgICAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwiZnVuY3Rpb25cIiBjYWxsIG1lc3NhZ2VzXG4gICAqICAgICAgIG1lc3NhZ2VzOiBbLi4ubWVzc2FnZXMsIC4uLmNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKHJlc3VsdCldLFxuICAgKiAgICAgICBmdW5jdGlvbnMsXG4gICAqICAgICB9KVxuICAgKiAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw/OiAoXG4gICAgZnVuY3Rpb25DYWxsUGF5bG9hZDogRnVuY3Rpb25DYWxsUGF5bG9hZCxcbiAgICBjcmVhdGVGdW5jdGlvbkNhbGxNZXNzYWdlczogKFxuICAgICAgZnVuY3Rpb25DYWxsUmVzdWx0OiBKU09OVmFsdWUsXG4gICAgKSA9PiBDcmVhdGVNZXNzYWdlW10sXG4gICkgPT4gUHJvbWlzZTxcbiAgICBSZXNwb25zZSB8IHVuZGVmaW5lZCB8IHZvaWQgfCBzdHJpbmcgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgPjtcbiAgLyoqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICogICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMTEwNicsIC8vIG9yIGdwdC00LTExMDYtcHJldmlld1xuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICB0b29scyxcbiAgICogICB0b29sX2Nob2ljZTogXCJhdXRvXCIsIC8vIGF1dG8gaXMgZGVmYXVsdCwgYnV0IHdlJ2xsIGJlIGV4cGxpY2l0XG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOiBhc3luYyAodG9vbENhbGxQYXlsb2FkLCBhcHBlbmRUb29sQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgIGxldCBtZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID0gW11cbiAgICogICAgLy8gICBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSB0b29sIGNhbGxzLCBzbyB3ZSBuZWVkIHRvIGl0ZXJhdGUgdGhyb3VnaCB0aGVtXG4gICAqICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29sQ2FsbFBheWxvYWQudG9vbHMpIHtcbiAgICogICAgIC8vIC4uLiBydW4geW91ciBjdXN0b20gbG9naWMgaGVyZVxuICAgKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbXlGdW5jdGlvbih0b29sLmZ1bmN0aW9uKVxuICAgKiAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwidG9vbFwiIGNhbGwgbWVzc2FnZXNcbiAgICogICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSh7dG9vbF9jYWxsX2lkOnRvb2wuaWQsIGZ1bmN0aW9uX25hbWU6dG9vbC5mdW5jdGlvbi5uYW1lLCB0b29sX2NhbGxfcmVzdWx0OnJlc3VsdH0pXG4gICAqICAgIH1cbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0xMTA2JywgLy8gb3IgZ3B0LTQtMTEwNi1wcmV2aWV3XG4gICAqICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICAgICAgLy8gQXBwZW5kIHRoZSByZXN1bHRzIG1lc3NhZ2VzLCBjYWxsaW5nIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSB3aXRob3V0XG4gICAqICAgICAgIC8vIGFueSBhcmd1bWVudHMgd2lsbCBqc3V0IHJldHVybiB0aGUgYWNjdW11bGF0ZWQgbWVzc2FnZXNcbiAgICogICAgICAgbWVzc2FnZXM6IFsuLi5tZXNzYWdlcywgLi4uYXBwZW5kVG9vbENhbGxNZXNzYWdlKCldLFxuICAgKiAgICAgICB0b29scyxcbiAgICogICAgICAgIHRvb2xfY2hvaWNlOiBcImF1dG9cIiwgLy8gYXV0byBpcyBkZWZhdWx0LCBidXQgd2UnbGwgYmUgZXhwbGljaXRcbiAgICogICAgIH0pXG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsPzogKFxuICAgIHRvb2xDYWxsUGF5bG9hZDogVG9vbENhbGxQYXlsb2FkLFxuICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZTogKHJlc3VsdD86IHtcbiAgICAgIHRvb2xfY2FsbF9pZDogc3RyaW5nO1xuICAgICAgZnVuY3Rpb25fbmFtZTogc3RyaW5nO1xuICAgICAgdG9vbF9jYWxsX3Jlc3VsdDogSlNPTlZhbHVlO1xuICAgIH0pID0+IENyZWF0ZU1lc3NhZ2VbXSxcbiAgKSA9PiBQcm9taXNlPFxuICAgIFJlc3BvbnNlIHwgdW5kZWZpbmVkIHwgdm9pZCB8IHN0cmluZyB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlc1xuICA+O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iLzA3YjM1MDRlMWM0MGZkOTI5ZjRhYWUxNjUxYjgzYWZjMTllM2JhZjgvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzI0wyOC1MNDBcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rIHtcbiAgaWQ6IHN0cmluZztcbiAgY2hvaWNlczogQXJyYXk8Q2hhdENvbXBsZXRpb25DaHVua0Nob2ljZT47XG4gIGNyZWF0ZWQ6IG51bWJlcjtcbiAgbW9kZWw6IHN0cmluZztcbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMNDMtTDQ5XG4vLyBVcGRhdGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC9mMTBjNzU3ZDgzMWQ5MDQwN2JhNDdiNDY1OWQ5Y2QzNGIxYTM1YjFkXG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rQ2hvaWNlIHtcbiAgZGVsdGE6IENob2ljZURlbHRhO1xuICBmaW5pc2hfcmVhc29uOlxuICAgIHwgJ3N0b3AnXG4gICAgfCAnbGVuZ3RoJ1xuICAgIHwgJ3Rvb2xfY2FsbHMnXG4gICAgfCAnY29udGVudF9maWx0ZXInXG4gICAgfCAnZnVuY3Rpb25fY2FsbCdcbiAgICB8IG51bGw7XG4gIGluZGV4OiBudW1iZXI7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMMTIzLUwxMzlcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIENob2ljZURlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgY2h1bmsgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAqIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IEZ1bmN0aW9uQ2FsbDtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICByb2xlPzogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICd0b29sJztcblxuICB0b29sX2NhbGxzPzogQXJyYXk8RGVsdGFUb29sQ2FsbD47XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIERlbHRhVG9vbENhbGwge1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB0aGUgbW9kZWwgY2FsbGVkLlxuICAgKi9cbiAgZnVuY3Rpb24/OiBUb29sQ2FsbEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZT86ICdmdW5jdGlvbic7XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIFRvb2xDYWxsRnVuY3Rpb24ge1xuICAvKipcbiAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAqL1xuICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvM2VjNDNlZTc5MGEyZWI2YTBjY2RkNWYyNWZhYTIzMjUxYjBmOWI4ZS9zcmMvcmVzb3VyY2VzL2NvbXBsZXRpb25zLnRzI0wyOEMxLUw2NEMxXG4gKiBDb21wbGV0aW9ucyBBUEkuIFN0cmVhbWVkIGFuZCBub24tc3RyZWFtZWQgcmVzcG9uc2VzIGFyZSB0aGUgc2FtZS5cbiAqL1xuaW50ZXJmYWNlIENvbXBsZXRpb24ge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBjb21wbGV0aW9uIGNob2ljZXMgdGhlIG1vZGVsIGdlbmVyYXRlZCBmb3IgdGhlIGlucHV0IHByb21wdC5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENvbXBsZXRpb25DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgY29tcGxldGlvbiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgZm9yIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcInRleHRfY29tcGxldGlvblwiXG4gICAqL1xuICBvYmplY3Q6IHN0cmluZztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlPzogQ29tcGxldGlvblVzYWdlO1xufVxuXG5pbnRlcmZhY2UgQ29tcGxldGlvbkNob2ljZSB7XG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBvciBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZC5cbiAgICovXG4gIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICBpbmRleDogbnVtYmVyO1xuXG4gIC8vIGVkaXRlZDogUmVtb3ZlZCBDb21wbGV0aW9uQ2hvaWNlLmxvZ1Byb2JzIGFuZCByZXBsYWNlZCB3aXRoIGFueVxuICBsb2dwcm9iczogYW55IHwgbnVsbDtcblxuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvblVzYWdlIHtcbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnZW5lcmF0ZWQgY29tcGxldGlvbi5cbiAgICovXG4gIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSByZXF1ZXN0IChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICovXG4gIHRvdGFsX3Rva2VuczogbnVtYmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwYXJzZXIgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgdGhlIE9wZW5BSSBzdHJlYW0gZGF0YS5cbiAqIFRoZSBwYXJzZXIgZXh0cmFjdHMgYW5kIHRyaW1zIHRleHQgY29udGVudCBmcm9tIHRoZSBKU09OIGRhdGEuIFRoaXMgcGFyc2VyXG4gKiBjYW4gaGFuZGxlIGRhdGEgZm9yIGNoYXQgb3IgY29tcGxldGlvbiBtb2RlbHMuXG4gKlxuICogQHJldHVybiB7KGRhdGE6IHN0cmluZykgPT4gc3RyaW5nIHwgdm9pZHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfX1cbiAqIEEgcGFyc2VyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBKU09OIHN0cmluZyBhcyBpbnB1dCBhbmQgcmV0dXJucyB0aGUgZXh0cmFjdGVkIHRleHQgY29udGVudCxcbiAqIGEgY29tcGxleCBvYmplY3Qgd2l0aCBpc1RleHQ6IGZhbHNlIGZvciBmdW5jdGlvbi90b29sIGNhbGxzLCBvciBub3RoaW5nLlxuICovXG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpOiAoXG4gIGRhdGE6IHN0cmluZyxcbikgPT4gc3RyaW5nIHwgdm9pZCB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0ge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIGRhdGEgPT4gZXh0cmFjdChKU09OLnBhcnNlKGRhdGEpIGFzIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzKTtcbn1cblxuLyoqXG4gKiBSZWFkcyBjaHVua3MgZnJvbSBPcGVuQUkncyBuZXcgU3RyZWFtYWJsZSBpbnRlcmZhY2UsIHdoaWNoIGlzIGVzc2VudGlhbGx5XG4gKiB0aGUgc2FtZSBhcyB0aGUgb2xkIFJlc3BvbnNlIGJvZHkgaW50ZXJmYWNlIHdpdGggYW4gaW5jbHVkZWQgU1NFIHBhcnNlclxuICogZG9pbmcgdGhlIHBhcnNpbmcgZm9yIHVzLlxuICovXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW06IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcykge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcblxuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAvLyBjb252ZXJ0IGNodW5rIGlmIGl0IGlzIGFuIEF6dXJlIGNoYXQgY29tcGxldGlvbi4gQXp1cmUgZG9lcyBub3QgZXhwb3NlIGFsbFxuICAgIC8vIHByb3BlcnRpZXMgaW4gdGhlIGludGVyZmFjZXMsIGFuZCBhbHNvIHVzZXMgY2FtZWxDYXNlIGluc3RlYWQgb2Ygc25ha2VfY2FzZVxuICAgIGlmICgncHJvbXB0RmlsdGVyUmVzdWx0cycgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IChjaHVuayBhcyBhbnkpLm9iamVjdCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiAoY2h1bmsgYXMgYW55KS5tb2RlbCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKGNob2ljZSA9PiAoe1xuICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICBjb250ZW50OiBjaG9pY2UuZGVsdGE/LmNvbnRlbnQsXG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaG9pY2UuZGVsdGE/LmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgIHJvbGU6IGNob2ljZS5kZWx0YT8ucm9sZSBhcyBhbnksXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBjaG9pY2UuZGVsdGE/LnRvb2xDYWxscz8ubGVuZ3RoXG4gICAgICAgICAgICAgID8gY2hvaWNlLmRlbHRhPy50b29sQ2FsbHM/Lm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlLFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24gYXMgYW55LFxuICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXgsXG4gICAgICAgIH0pKSxcbiAgICAgIH0gc2F0aXNmaWVzIENoYXRDb21wbGV0aW9uQ2h1bms7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuXG4gICAgaWYgKHRleHQpIHlpZWxkIHRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKTogKFxuICBjaHVuazogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4pID0+IHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0gfCB2b2lkIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luOiBib29sZWFuO1xuICByZXR1cm4ganNvbiA9PiB7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSBqc29uLmNob2ljZXNbMF0/LmRlbHRhO1xuICAgICAgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/Lm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCIke2RlbHRhLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIke3Rvb2xDYWxsLmZ1bmN0aW9uPy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7dG9vbENhbGwuZnVuY3Rpb24/Lm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/LmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cyhkZWx0YS5mdW5jdGlvbl9jYWxsPy5hcmd1bWVudHMpLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoZGVsdGEudG9vbF9jYWxscz8uWzBdPy5mdW5jdGlvbj8uYXJndW1lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICAoanNvbi5jaG9pY2VzWzBdPy5maW5pc2hfcmVhc29uID09PSAnZnVuY3Rpb25fY2FsbCcgfHxcbiAgICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICdzdG9wJylcbiAgICAgICkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTsgLy8gUmVzZXQgdGhlIGZsYWdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19JyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICd0b29sX2NhbGxzJ1xuICAgICAgKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlOyAvLyBSZXNldCB0aGUgZmxhZ1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX1dfScsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50XG4gICAgICAgID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnRcbiAgICAgICAgOiBpc0NvbXBsZXRpb24oanNvbilcbiAgICAgICAgPyBqc29uLmNob2ljZXNbMF0udGV4dFxuICAgICAgICA6ICcnLFxuICAgICk7XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bms6IHN0cmluZykge1xuICAgIGxldCBlc2NhcGVkUGFydGlhbEpzb24gPSBhcmd1bWVudENodW5rXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAvLyBSZXBsYWNlIGJhY2tzbGFzaGVzIGZpcnN0IHRvIHByZXZlbnQgZG91YmxlIGVzY2FwaW5nXG4gICAgICAucmVwbGFjZSgvXFwvL2csICdcXFxcLycpIC8vIEVzY2FwZSBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpIC8vIEVzY2FwZSBkb3VibGUgcXVvdGVzXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpIC8vIEVzY2FwZSBuZXcgbGluZXNcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgLy8gRXNjYXBlIGNhcnJpYWdlIHJldHVybnNcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgLy8gRXNjYXBlIHRhYnNcbiAgICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJyk7IC8vIEVzY2FwZSBmb3JtIGZlZWRzXG5cbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cblxuY29uc3QgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgJ2ludGVybmFsX29wZW5haV9mbl9tZXNzYWdlcycsXG4pO1xuXG50eXBlIEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyA9XG4gIHwgQXN5bmNJdGVyYWJsZTxDaGF0Q29tcGxldGlvbkNodW5rPlxuICB8IEFzeW5jSXRlcmFibGU8Q29tcGxldGlvbj5cbiAgfCBBc3luY0l0ZXJhYmxlPEF6dXJlQ2hhdENvbXBsZXRpb25zPjtcblxudHlwZSBFeHRyYWN0VHlwZTxUPiA9IFQgZXh0ZW5kcyBBc3luY0l0ZXJhYmxlPGluZmVyIFU+ID8gVSA6IG5ldmVyO1xuXG50eXBlIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzID1cbiAgRXh0cmFjdFR5cGU8QXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzPjtcblxuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKFxuICBkYXRhOiBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbik6IGRhdGEgaXMgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIHJldHVybiAoXG4gICAgJ2Nob2ljZXMnIGluIGRhdGEgJiZcbiAgICBkYXRhLmNob2ljZXMgJiZcbiAgICBkYXRhLmNob2ljZXNbMF0gJiZcbiAgICAnZGVsdGEnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YTogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMpOiBkYXRhIGlzIENvbXBsZXRpb24ge1xuICByZXR1cm4gKFxuICAgICdjaG9pY2VzJyBpbiBkYXRhICYmXG4gICAgZGF0YS5jaG9pY2VzICYmXG4gICAgZGF0YS5jaG9pY2VzWzBdICYmXG4gICAgJ3RleHQnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gT3BlbkFJU3RyZWFtKFxuICByZXM6IFJlc3BvbnNlIHwgQXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzLFxuICBjYWxsYmFja3M/OiBPcGVuQUlTdHJlYW1DYWxsYmFja3MsXG4pOiBSZWFkYWJsZVN0cmVhbSB7XG4gIC8vIEFubm90YXRlIHRoZSBpbnRlcm5hbCBgbWVzc2FnZXNgIHByb3BlcnR5IGZvciByZWN1cnNpdmUgZnVuY3Rpb24gY2FsbHNcbiAgY29uc3QgY2I6XG4gICAgfCB1bmRlZmluZWRcbiAgICB8IChPcGVuQUlTdHJlYW1DYWxsYmFja3MgJiB7XG4gICAgICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXT86IENyZWF0ZU1lc3NhZ2VbXTtcbiAgICAgIH0pID0gY2FsbGJhY2tzO1xuXG4gIGxldCBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+O1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlKHJlcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gICAgICAgIGNiPy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2I/LmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgICAgICBvbkZpbmFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgICAgfSxcbiAgICAgICksXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBBSVN0cmVhbShcbiAgICAgIHJlcyxcbiAgICAgIHBhcnNlT3BlbkFJU3RyZWFtKCksXG4gICAgICBjYj8uZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiPy5leHBlcmltZW50YWxfb25Ub29sQ2FsbFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgICAgb25GaW5hbDogdW5kZWZpbmVkLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICB9LFxuICAgICk7XG4gIH1cblxuICBpZiAoY2IgJiYgKGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICBjb25zdCBmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciA9IGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNiKTtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihcbiAgY2FsbGJhY2tzOiBPcGVuQUlTdHJlYW1DYWxsYmFja3MgJiB7XG4gICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdPzogQ3JlYXRlTWVzc2FnZVtdO1xuICB9LFxuKTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+IHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWU7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSAnJztcbiAgbGV0IGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9ICcnO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG5cbiAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2VzOiBDcmVhdGVNZXNzYWdlW10gPVxuICAgIGNhbGxiYWNrc1tfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXSB8fCBbXTtcblxuICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2RlKGNodW5rKTtcbiAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSArPSBtZXNzYWdlO1xuXG4gICAgICBjb25zdCBzaG91bGRIYW5kbGVBc0Z1bmN0aW9uID1cbiAgICAgICAgaXNGaXJzdENodW5rICYmXG4gICAgICAgIChtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSB8fFxuICAgICAgICAgIG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKTtcblxuICAgICAgaWYgKHNob3VsZEhhbmRsZUFzRnVuY3Rpb24pIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFN0cmVhbSBhcyBub3JtYWxcbiAgICAgIGlmICghaXNGdW5jdGlvblN0cmVhbWluZ0luKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIG1lc3NhZ2UpKSxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWlzRmlyc3RDaHVuayAmJlxuICAgICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICAgIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8XG4gICAgICAgICAgICBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpXG4gICAgICAgICkge1xuICAgICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIG1lc3NhZ2UgdG8gdGhlIGxpc3RcbiAgICAgICAgICBsZXQgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM6IENyZWF0ZU1lc3NhZ2VbXSA9IFtcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgIF07XG5cbiAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZTpcbiAgICAgICAgICAgIHwgUmVzcG9uc2VcbiAgICAgICAgICAgIHwgdW5kZWZpbmVkXG4gICAgICAgICAgICB8IHZvaWRcbiAgICAgICAgICAgIHwgc3RyaW5nXG4gICAgICAgICAgICB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlc1xuICAgICAgICAgICAgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgLy8gVGhpcyBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIGNoZWNrIHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IGJ1dCBUUyBjb21wbGFpbnNcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgaXMgdXNpbmcgdGhlIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBjYWxsYmFjaywgdGhleSBzaG91bGQgbm90IGJlIHVzaW5nIHRvb2xzXG4gICAgICAgICAgICAvLyBpZiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgaXMgbm90IGRlZmluZWQgYnkgdGltZSB3ZSBnZXQgaGVyZSB3ZSBtdXN0IGhhdmUgZ290dGVuIGEgdG9vbCByZXNwb25zZVxuICAgICAgICAgICAgLy8gYW5kIHRoZSB1c2VyIGhhZCBkZWZpbmVkIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsXG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mdW5jdGlvbl9jYWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICdleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHMnLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNQYXlsb2FkID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNQYXlsb2FkLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXF1ZXN0IGFuZCByZXN1bHQgbWVzc2FnZXMgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHBheWxvYWQuZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIC8vIFJldHVybiBpdCB0byB0aGUgdXNlclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsczogVG9vbENhbGxQYXlsb2FkID0ge1xuICAgICAgICAgICAgICB0b29sczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHBheWxvYWQudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICB0b29sQ2FsbHMudG9vbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHRvb2wuaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICBmdW5jOiB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiB0b29sLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04ucGFyc2UodG9vbC5mdW5jdGlvbi5hcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlSW5kZXggPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbChcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0b29sX2NhbGxfaWQsIGZ1bmN0aW9uX25hbWUsIHRvb2xfY2FsbF9yZXN1bHQgfSA9XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVxdWVzdCBhbmQgcmVzdWx0IG1lc3NhZ2VzIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLm5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwZW5kIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBpZiBpdCdzIHRoZSBmaXJzdCByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgIC4uLihyZXNwb25zZUluZGV4ID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyBhcyBjb25zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsczogcGF5bG9hZC50b29sX2NhbGxzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRjOiBUb29sQ2FsbCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGMuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyBhbiBvYmplY3QgdG8gdGhlIHVzZXIsIGJ1dCBhcyB0aGUgQVBJIGV4cGVjdHMgYSBzdHJpbmcsIHdlIG5lZWQgdG8gc3RyaW5naWZ5IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Yy5mdW5jdGlvbi5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVzdWx0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAndG9vbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodG9vbF9jYWxsX3Jlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGl0IHRvIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsbGluZyBleHBlcmltZW50YWxfb25Ub29sQ2FsbDonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZ1bmN0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIGRpZG4ndCBkbyBhbnl0aGluZyB3aXRoIHRoZSBmdW5jdGlvbiBjYWxsIG9uIHRoZSBzZXJ2ZXIgYW5kIHdhbnRzXG4gICAgICAgICAgICAvLyB0byBlaXRoZXIgZG8gbm90aGluZyBvciBydW4gaXQgb24gdGhlIGNsaWVudFxuICAgICAgICAgICAgLy8gc28gd2UganVzdCByZXR1cm4gdGhlIGZ1bmN0aW9uIGNhbGwgYXMgYSBtZXNzYWdlXG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsID8gJ2Z1bmN0aW9uX2NhbGwnIDogJ3Rvb2xfY2FsbHMnLFxuICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgdG8gcHJldmVudCBkb3VibGUtZW5jb2Rpbmc6XG4gICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIHJldHVybmVkIGEgc3RyaW5nLCBzbyB3ZSBqdXN0IHJldHVybiBpdCBhcyBhIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ3RleHQnLCBmdW5jdGlvblJlc3BvbnNlKSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gZnVuY3Rpb25SZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseTpcblxuICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBvblN0YXJ0IG9yIG9uQ29tcGxldGUgcmVjdXJzaXZlbHlcbiAgICAgICAgICAvLyBzbyB3ZSByZW1vdmUgdGhlbSBmcm9tIHRoZSBjYWxsYmFja3NcbiAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9haS9pc3N1ZXMvMzUxXG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRDYWxsYmFja3M6IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIC4uLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIG9uU3RhcnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCBvbkZpbmFsIHRvIGJlIGNhbGxlZCB0aGUgX2xhc3RfIHRpbWVcbiAgICAgICAgICBjYWxsYmFja3Mub25GaW5hbCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGNvbnN0IG9wZW5BSVN0cmVhbSA9IE9wZW5BSVN0cmVhbShmdW5jdGlvblJlc3BvbnNlLCB7XG4gICAgICAgICAgICAuLi5maWx0ZXJlZENhbGxiYWNrcyxcbiAgICAgICAgICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXTogbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgfSBhcyBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMpO1xuXG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gb3BlbkFJU3RyZWFtLmdldFJlYWRlcigpO1xuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufVxuIiwiZXhwb3J0IGNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSA9IFN5bWJvbC5mb3IoJ3VpLnN0cmVhbWFibGUudmFsdWUnKTtcbmV4cG9ydCBjb25zdCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSA9IDE1ICogMTAwMDtcbiIsImltcG9ydCB7XG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIExhbmd1YWdlTW9kZWxWMSxcbiAgTm9TdWNoVG9vbEVycm9yLFxufSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuXG5pbXBvcnQgeyBDYWxsU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3Byb21wdC9jYWxsLXNldHRpbmdzJztcbmltcG9ydCB7IFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3Byb21wdCc7XG5pbXBvcnQgeyBjcmVhdGVTdHJlYW1hYmxlVUkgfSBmcm9tICcuLi9zdHJlYW1hYmxlJztcbmltcG9ydCB7IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYnO1xuaW1wb3J0IHsgZ2V0VmFsaWRhdGVkUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvZ2V0LXZhbGlkYXRlZC1wcm9tcHQnO1xuaW1wb3J0IHsgY29udmVydFpvZFRvSlNPTlNjaGVtYSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbC9jb252ZXJ0LXpvZC10by1qc29uLXNjaGVtYSc7XG5pbXBvcnQgeyBwcmVwYXJlQ2FsbFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzJztcbmltcG9ydCB7IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQgfSBmcm9tICcuLi8uLi9jb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdCc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcblxudHlwZSBTdHJlYW1hYmxlID0gUmVhY3ROb2RlIHwgUHJvbWlzZTxSZWFjdE5vZGU+O1xuXG50eXBlIFJlbmRlcmVyPFQgZXh0ZW5kcyBBcnJheTxhbnk+PiA9IChcbiAgLi4uYXJnczogVFxuKSA9PlxuICB8IFN0cmVhbWFibGVcbiAgfCBHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD5cbiAgfCBBc3luY0dlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPjtcblxudHlwZSBSZW5kZXJUb29sPFBBUkFNRVRFUlMgZXh0ZW5kcyB6LlpvZFR5cGVBbnkgPSBhbnk+ID0ge1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgcGFyYW1ldGVyczogUEFSQU1FVEVSUztcbiAgZ2VuZXJhdGU/OiBSZW5kZXJlcjxcbiAgICBbXG4gICAgICB6LmluZmVyPFBBUkFNRVRFUlM+LFxuICAgICAge1xuICAgICAgICB0b29sTmFtZTogc3RyaW5nO1xuICAgICAgICB0b29sQ2FsbElkOiBzdHJpbmc7XG4gICAgICB9LFxuICAgIF1cbiAgPjtcbn07XG5cbnR5cGUgUmVuZGVyVGV4dCA9IFJlbmRlcmVyPFxuICBbXG4gICAge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc28gZmFyLlxuICAgICAgICovXG4gICAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuZXcgYXBwZW5kZWQgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNpbmNlIHRoZSBsYXN0IGB0ZXh0YCBjYWxsLlxuICAgICAgICovXG4gICAgICBkZWx0YTogc3RyaW5nO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBpcyBkb25lIGdlbmVyYXRpbmcgdGV4dC5cbiAgICAgICAqIElmIGB0cnVlYCwgdGhlIGBjb250ZW50YCB3aWxsIGJlIHRoZSBmaW5hbCBvdXRwdXQgYW5kIHRoaXMgY2FsbCB3aWxsIGJlIHRoZSBsYXN0LlxuICAgICAgICovXG4gICAgICBkb25lOiBib29sZWFuO1xuICAgIH0sXG4gIF1cbj47XG5cbnR5cGUgUmVuZGVyUmVzdWx0ID0ge1xuICB2YWx1ZTogUmVhY3ROb2RlO1xufSAmIEF3YWl0ZWQ8UmV0dXJuVHlwZTxMYW5ndWFnZU1vZGVsVjFbJ2RvU3RyZWFtJ10+PjtcblxuY29uc3QgZGVmYXVsdFRleHRSZW5kZXJlcjogUmVuZGVyVGV4dCA9ICh7IGNvbnRlbnQgfTogeyBjb250ZW50OiBzdHJpbmcgfSkgPT5cbiAgY29udGVudDtcblxuLyoqXG4gKiBgc3RyZWFtVUlgIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0cmVhbWFibGUgVUkgZnJvbSBMTE1zLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RyZWFtVUk8XG4gIFRPT0xTIGV4dGVuZHMgeyBbbmFtZTogc3RyaW5nXTogei5ab2RUeXBlQW55IH0gPSB7fSxcbj4oe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGluaXRpYWwsXG4gIHRleHQsXG4gIC4uLnNldHRpbmdzXG59OiBDYWxsU2V0dGluZ3MgJlxuICBQcm9tcHQgJiB7XG4gICAgLyoqXG4gICAgICogVGhlIGxhbmd1YWdlIG1vZGVsIHRvIHVzZS5cbiAgICAgKi9cbiAgICBtb2RlbDogTGFuZ3VhZ2VNb2RlbFYxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRvb2xzIHRoYXQgdGhlIG1vZGVsIGNhbiBjYWxsLiBUaGUgbW9kZWwgbmVlZHMgdG8gc3VwcG9ydCBjYWxsaW5nIHRvb2xzLlxuICAgICAqL1xuICAgIHRvb2xzPzoge1xuICAgICAgW25hbWUgaW4ga2V5b2YgVE9PTFNdOiBSZW5kZXJUb29sPFRPT0xTW25hbWVdPjtcbiAgICB9O1xuXG4gICAgdGV4dD86IFJlbmRlclRleHQ7XG4gICAgaW5pdGlhbD86IFJlYWN0Tm9kZTtcbiAgfSk6IFByb21pc2U8UmVuZGVyUmVzdWx0PiB7XG4gIC8vIFRPRE86IFJlbW92ZSB0aGVzZSBlcnJvcnMgYWZ0ZXIgdGhlIGV4cGVyaW1lbnRhbCBwaGFzZS5cbiAgaWYgKHR5cGVvZiBtb2RlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYG1vZGVsYCBjYW5ub3QgYmUgYSBzdHJpbmcgaW4gYHN0cmVhbVVJYC4gVXNlIHRoZSBhY3R1YWwgbW9kZWwgaW5zdGFuY2UgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKCdmdW5jdGlvbnMnIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2BmdW5jdGlvbnNgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYHN0cmVhbVVJYCwgdXNlIGB0b29sc2AgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKCdwcm92aWRlcicgaW4gc2V0dGluZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYHByb3ZpZGVyYCBpcyBubyBsb25nZXIgbmVlZGVkIGluIGBzdHJlYW1VSWAuIFVzZSBgbW9kZWxgIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICh0b29scykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHRvb2xdIG9mIE9iamVjdC5lbnRyaWVzKHRvb2xzKSkge1xuICAgICAgaWYgKCdyZW5kZXInIGluIHRvb2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUb29sIGRlZmluaXRpb24gaW4gYHN0cmVhbVVJYCBzaG91bGQgbm90IGhhdmUgYHJlbmRlcmAgcHJvcGVydHkuIFVzZSBgZ2VuZXJhdGVgIGluc3RlYWQuIEZvdW5kIGluIHRvb2w6ICcgK1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSShpbml0aWFsKTtcblxuICAvLyBUaGUgZGVmYXVsdCB0ZXh0IHJlbmRlcmVyIGp1c3QgcmV0dXJucyB0aGUgY29udGVudCBhcyBzdHJpbmcuXG4gIGNvbnN0IHRleHRSZW5kZXIgPSB0ZXh0IHx8IGRlZmF1bHRUZXh0UmVuZGVyZXI7XG5cbiAgbGV0IGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlbmRlcihcbiAgICBhcmdzOiBbcGF5bG9hZDogYW55XSB8IFtwYXlsb2FkOiBhbnksIG9wdGlvbnM6IGFueV0sXG4gICAgcmVuZGVyZXI6IHVuZGVmaW5lZCB8IFJlbmRlcmVyPGFueT4sXG4gICAgcmVzOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTdHJlYW1hYmxlVUk+LFxuICApIHtcbiAgICBpZiAoIXJlbmRlcmVyKSByZXR1cm47XG5cbiAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8dm9pZD4oKTtcblxuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgZmluaXNoZWQgPSBmaW5pc2hlZC50aGVuKCgpID0+IHJlc29sdmFibGUucHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaGVkID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gcmVuZGVyZXIoLi4uYXJncyk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlIHx8XG4gICAgICAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndGhlbicgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICBjb25zdCBub2RlID0gYXdhaXQgKHZhbHVlIGFzIFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPik7XG4gICAgICByZXMudXBkYXRlKG5vZGUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiB2YWx1ZVxuICAgICkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZSBhcyBBc3luY0dlbmVyYXRvcjxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICBSZWFjdC5SZWFjdE5vZGUsXG4gICAgICAgIHZvaWRcbiAgICAgID47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlIGFzIEdlbmVyYXRvcjxSZWFjdC5SZWFjdE5vZGUsIFJlYWN0LlJlYWN0Tm9kZSwgdm9pZD47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KTtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoKCkgPT5cbiAgICBtb2RlbC5kb1N0cmVhbSh7XG4gICAgICBtb2RlOiB7XG4gICAgICAgIHR5cGU6ICdyZWd1bGFyJyxcbiAgICAgICAgdG9vbHM6XG4gICAgICAgICAgdG9vbHMgPT0gbnVsbFxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUsIHRvb2xdKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHRvb2wucGFyYW1ldGVycyksXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgIH0sXG4gICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgfSksXG4gICk7XG5cbiAgY29uc3QgW3N0cmVhbSwgZm9ya2VkU3RyZWFtXSA9IHJlc3VsdC5zdHJlYW0udGVlKCk7XG5cbiAgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29uc3VtZSB0aGUgZm9ya2VkIHN0cmVhbSBhc3luY2hvbm91c2x5LlxuXG4gICAgICBsZXQgY29udGVudCA9ICcnO1xuICAgICAgbGV0IGhhc1Rvb2xDYWxsID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IHJlYWRlciA9IGZvcmtlZFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcblxuICAgICAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICd0ZXh0LWRlbHRhJzoge1xuICAgICAgICAgICAgY29udGVudCArPSB2YWx1ZS50ZXh0RGVsdGE7XG4gICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgIFt7IGNvbnRlbnQsIGRvbmU6IGZhbHNlLCBkZWx0YTogdmFsdWUudGV4dERlbHRhIH1dLFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVyLFxuICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0b29sLWNhbGwtZGVsdGEnOiB7XG4gICAgICAgICAgICBoYXNUb29sQ2FsbCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0b29sLWNhbGwnOiB7XG4gICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IHZhbHVlLnRvb2xOYW1lIGFzIGtleW9mIFRPT0xTICYgc3RyaW5nO1xuXG4gICAgICAgICAgICBpZiAoIXRvb2xzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZTogdG9vbE5hbWUgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRvb2wgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgICBpZiAoIXRvb2wpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgICAgIHNjaGVtYTogdG9vbC5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZVJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgdG9vbEFyZ3M6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB2YWx1ZS50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIHRvb2wuZ2VuZXJhdGUsXG4gICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICB0aHJvdyB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdmaW5pc2gnOiB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNUb29sQ2FsbCkge1xuICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgdWkuZG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlUmVuZGVyKFt7IGNvbnRlbnQsIGRvbmU6IHRydWUgfV0sIHRleHRSZW5kZXIsIHVpKTtcbiAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgIHVpLmRvbmUoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRHVyaW5nIHRoZSBzdHJlYW0gcmVuZGVyaW5nLCB3ZSBkb24ndCB3YW50IHRvIHRocm93IHRoZSBlcnJvciB0byB0aGVcbiAgICAgIC8vIHBhcmVudCBzY29wZSBidXQgb25seSBsZXQgdGhlIFJlYWN0J3MgZXJyb3IgYm91bmRhcnkgdG8gY2F0Y2ggaXQuXG4gICAgICB1aS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucmVzdWx0LFxuICAgIHN0cmVhbSxcbiAgICB2YWx1ZTogdWkudmFsdWUsXG4gIH07XG59XG4iLCIvLyBUaGlzIGZpbGUgcHJvdmlkZXMgdGhlIEFJIGNvbnRleHQgdG8gYWxsIEFJIEFjdGlvbnMgdmlhIEFzeW5jTG9jYWxTdG9yYWdlLlxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJbnRlcm5hbEFJUHJvdmlkZXIgfSBmcm9tICcuL3JzYy1zaGFyZWQubWpzJztcbmltcG9ydCB7XG4gIHdpdGhBSVN0YXRlLFxuICBnZXRBSVN0YXRlRGVsdGFQcm9taXNlLFxuICBzZWFsTXV0YWJsZUFJU3RhdGUsXG59IGZyb20gJy4vYWktc3RhdGUnO1xuaW1wb3J0IHR5cGUge1xuICBTZXJ2ZXJXcmFwcGVkQWN0aW9ucyxcbiAgQUlBY3Rpb24sXG4gIEFJQWN0aW9ucyxcbiAgQUlQcm92aWRlcixcbiAgSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMsXG4gIE9uU2V0QUlTdGF0ZSxcbiAgT25HZXRVSVN0YXRlLFxufSBmcm9tICcuL3R5cGVzJztcblxuYXN5bmMgZnVuY3Rpb24gaW5uZXJBY3Rpb248VD4oXG4gIHtcbiAgICBhY3Rpb24sXG4gICAgb3B0aW9ucyxcbiAgfTogeyBhY3Rpb246IEFJQWN0aW9uOyBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyB9LFxuICBzdGF0ZTogVCxcbiAgLi4uYXJnczogdW5rbm93bltdXG4pIHtcbiAgJ3VzZSBzZXJ2ZXInO1xuICByZXR1cm4gYXdhaXQgd2l0aEFJU3RhdGUoXG4gICAge1xuICAgICAgc3RhdGUsXG4gICAgICBvcHRpb25zLFxuICAgIH0sXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgc2VhbE11dGFibGVBSVN0YXRlKCk7XG4gICAgICByZXR1cm4gW2dldEFJU3RhdGVEZWx0YVByb21pc2UoKSBhcyBQcm9taXNlPFQ+LCByZXN1bHRdO1xuICAgIH0sXG4gICk7XG59XG5cbmZ1bmN0aW9uIHdyYXBBY3Rpb248VCA9IHVua25vd24+KFxuICBhY3Rpb246IEFJQWN0aW9uLFxuICBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbikge1xuICByZXR1cm4gaW5uZXJBY3Rpb24uYmluZChudWxsLCB7IGFjdGlvbiwgb3B0aW9ucyB9KSBhcyBBSUFjdGlvbjxUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFJPFxuICBBSVN0YXRlID0gYW55LFxuICBVSVN0YXRlID0gYW55LFxuICBBY3Rpb25zIGV4dGVuZHMgQUlBY3Rpb25zID0ge30sXG4+KHtcbiAgYWN0aW9ucyxcbiAgaW5pdGlhbEFJU3RhdGUsXG4gIGluaXRpYWxVSVN0YXRlLFxuXG4gIG9uU2V0QUlTdGF0ZSxcbiAgb25HZXRVSVN0YXRlLFxufToge1xuICBhY3Rpb25zOiBBY3Rpb25zO1xuICBpbml0aWFsQUlTdGF0ZT86IEFJU3RhdGU7XG4gIGluaXRpYWxVSVN0YXRlPzogVUlTdGF0ZTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIEFJIHN0YXRlIGlzIHVwZGF0ZWQgYnkgYW4gQWN0aW9uLlxuICAgKiBZb3UgY2FuIHVzZSB0aGlzIHRvIHBlcnNpc3QgdGhlIEFJIHN0YXRlIHRvIGEgZGF0YWJhc2UsIG9yIHRvIHNlbmQgaXQgdG8gYVxuICAgKiBsb2dnaW5nIHNlcnZpY2UuXG4gICAqL1xuICBvblNldEFJU3RhdGU/OiBPblNldEFJU3RhdGU8QUlTdGF0ZT47XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZXRyaWV2ZSB0aGUgVUkgc3RhdGUgYmFzZWQgb24gdGhlIEFJIHN0YXRlLlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gcmVuZGVyIHRoZSBpbml0aWFsIFVJIHN0YXRlIGJhc2VkIG9uIGEgZ2l2ZW4gQUkgc3RhdGUsIG9yXG4gICAqIHRvIHN5bmMgdGhlIFVJIHN0YXRlIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIGFscmVhZHkgbG9hZGVkLlxuICAgKlxuICAgKiBJZiByZXR1cm5pbmcgYHVuZGVmaW5lZGAsIHRoZSBjbGllbnQgc2lkZSBVSSBzdGF0ZSB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgYW5ub3RhdGVkIHdpdGggdGhlIGBcInVzZSBzZXJ2ZXJcImAgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogb25HZXRVSVN0YXRlOiBhc3luYyAoKSA9PiB7XG4gICAqICAgJ3VzZSBzZXJ2ZXInO1xuICAgKlxuICAgKiAgIGNvbnN0IGN1cnJlbnRBSVN0YXRlID0gZ2V0QUlTdGF0ZSgpO1xuICAgKiAgIGNvbnN0IGV4dGVybmFsQUlTdGF0ZSA9IGF3YWl0IGxvYWRBSVN0YXRlRnJvbURhdGFiYXNlKCk7XG4gICAqXG4gICAqICAgaWYgKGN1cnJlbnRBSVN0YXRlID09PSBleHRlcm5hbEFJU3RhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAqXG4gICAqICAgLy8gVXBkYXRlIGN1cnJlbnQgQUkgc3RhdGUgYW5kIHJldHVybiB0aGUgbmV3IFVJIHN0YXRlXG4gICAqICAgY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gICAqICAgc3RhdGUuZG9uZShleHRlcm5hbEFJU3RhdGUpXG4gICAqXG4gICAqICAgcmV0dXJuIDxkaXY+Li4uPC9kaXY+O1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgb25HZXRVSVN0YXRlPzogT25HZXRVSVN0YXRlPFVJU3RhdGU+O1xufSkge1xuICAvLyBXcmFwIGFsbCBhY3Rpb25zIHdpdGggb3VyIEhvQy5cbiAgY29uc3Qgd3JhcHBlZEFjdGlvbnM6IFNlcnZlcldyYXBwZWRBY3Rpb25zID0ge307XG4gIGZvciAoY29uc3QgbmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgd3JhcHBlZEFjdGlvbnNbbmFtZV0gPSB3cmFwQWN0aW9uKGFjdGlvbnNbbmFtZV0sIHtcbiAgICAgIG9uU2V0QUlTdGF0ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHdyYXBwZWRTeW5jVUlTdGF0ZSA9IG9uR2V0VUlTdGF0ZVxuICAgID8gd3JhcEFjdGlvbihvbkdldFVJU3RhdGUsIHt9KVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IEFJOiBBSVByb3ZpZGVyPEFJU3RhdGUsIFVJU3RhdGUsIEFjdGlvbnM+ID0gYXN5bmMgcHJvcHMgPT4ge1xuICAgIGlmICgndXNlU3RhdGUnIGluIFJlYWN0KSB7XG4gICAgICAvLyBUaGlzIGZpbGUgbXVzdCBiZSBydW5uaW5nIG9uIHRoZSBSZWFjdCBTZXJ2ZXIgbGF5ZXIuXG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCBiZSB1c2luZyBgaW1wb3J0IFwic2VydmVyLW9ubHlcImAgaGVyZSBidXQgd2UgY2FuIGhhdmUgYVxuICAgICAgLy8gbW9yZSBjdXN0b21pemVkIGVycm9yIG1lc3NhZ2Ugd2l0aCB0aGlzIGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhpcyBjb21wb25lbnQgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgU2VydmVyIENvbXBvbmVudHMuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHVpU3RhdGUgPSBwcm9wcy5pbml0aWFsVUlTdGF0ZSA/PyBpbml0aWFsVUlTdGF0ZTtcbiAgICBsZXQgYWlTdGF0ZSA9IHByb3BzLmluaXRpYWxBSVN0YXRlID8/IGluaXRpYWxBSVN0YXRlO1xuICAgIGxldCBhaVN0YXRlRGVsdGEgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAod3JhcHBlZFN5bmNVSVN0YXRlKSB7XG4gICAgICBjb25zdCBbbmV3QUlTdGF0ZURlbHRhLCBuZXdVSVN0YXRlXSA9IGF3YWl0IHdyYXBwZWRTeW5jVUlTdGF0ZShhaVN0YXRlKTtcbiAgICAgIGlmIChuZXdVSVN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWlTdGF0ZURlbHRhID0gbmV3QUlTdGF0ZURlbHRhO1xuICAgICAgICB1aVN0YXRlID0gbmV3VUlTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEludGVybmFsQUlQcm92aWRlclxuICAgICAgICB3cmFwcGVkQWN0aW9ucz17d3JhcHBlZEFjdGlvbnN9XG4gICAgICAgIHdyYXBwZWRTeW5jVUlTdGF0ZT17d3JhcHBlZFN5bmNVSVN0YXRlfVxuICAgICAgICBpbml0aWFsVUlTdGF0ZT17dWlTdGF0ZX1cbiAgICAgICAgaW5pdGlhbEFJU3RhdGU9e2FpU3RhdGV9XG4gICAgICAgIGluaXRpYWxBSVN0YXRlUGF0Y2g9e2FpU3RhdGVEZWx0YX1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgPC9JbnRlcm5hbEFJUHJvdmlkZXI+XG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gQUk7XG59XG4iXSwibmFtZXMiOlsiQXN5bmNMb2NhbFN0b3JhZ2UiLCJqc29uZGlmZnBhdGNoIiwiU3VzcGVuc2UiLCJGcmFnbWVudCIsImpzeCIsImpzeHMiLCJjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlcyIsInJlaiIsIlIiLCJjIiwibiIsImNodW5rIiwiZG9uZSIsInZhbHVlIiwiYXBwZW5kIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsIm5leHQiLCJjcmVhdGVTdXNwZW5zZWRDaHVuayIsImluaXRpYWxWYWx1ZSIsInJvdyIsImlzRnVuY3Rpb24iLCJ4IiwiY29uc3VtZVN0cmVhbSIsInN0cmVhbSIsInJlYWRlciIsImdldFJlYWRlciIsInJlYWQiLCJhc3luY0FJU3RhdGVTdG9yYWdlIiwiZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyIsIm1lc3NhZ2UiLCJzdG9yZSIsImdldFN0b3JlIiwiRXJyb3IiLCJ3aXRoQUlTdGF0ZSIsInN0YXRlIiwib3B0aW9ucyIsImZuIiwicnVuIiwiY3VycmVudFN0YXRlIiwib3JpZ2luYWxTdGF0ZSIsInNlYWxlZCIsImdldEFJU3RhdGVEZWx0YVByb21pc2UiLCJtdXRhdGlvbkRlbHRhUHJvbWlzZSIsInNlYWxNdXRhYmxlQUlTdGF0ZSIsImdldEFJU3RhdGUiLCJhcmdzIiwibGVuZ3RoIiwia2V5IiwiU3RyaW5nIiwiZ2V0TXV0YWJsZUFJU3RhdGUiLCJtdXRhdGlvbkRlbHRhUmVzb2x2ZSIsImRvVXBkYXRlIiwibmV3U3RhdGUiLCJfYSIsIl9iIiwib25TZXRBSVN0YXRlIiwiY2FsbCIsIm11dGFibGVTdGF0ZSIsImdldCIsInVwZGF0ZSIsIm5ld0FJU3RhdGUiLCJkb25lQXJncyIsImRlbHRhIiwiZGlmZiIsInpvZFRvSnNvblNjaGVtYSIsIm1pbWVUeXBlU2lnbmF0dXJlcyIsIm1pbWVUeXBlIiwiYnl0ZXMiLCJkZXRlY3RJbWFnZU1pbWVUeXBlIiwiaW1hZ2UiLCJldmVyeSIsImJ5dGUiLCJpbmRleCIsIkludmFsaWREYXRhQ29udGVudEVycm9yIiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQiLCJjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkiLCJjb250ZW50IiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCIsInByb21wdCIsImxhbmd1YWdlTW9kZWxNZXNzYWdlcyIsInN5c3RlbSIsInB1c2giLCJyb2xlIiwidHlwZSIsInRleHQiLCJtZXNzYWdlcyIsIm1hcCIsInBhcnQiLCJVUkwiLCJpbWFnZVVpbnQ4IiwiX2V4aGF1c3RpdmVDaGVjayIsIkludmFsaWRQcm9tcHRFcnJvciIsImdldFZhbGlkYXRlZFByb21wdCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicHJlcGFyZUNhbGxTZXR0aW5ncyIsIm1heFRva2VucyIsInRlbXBlcmF0dXJlIiwidG9wUCIsInByZXNlbmNlUGVuYWx0eSIsImZyZXF1ZW5jeVBlbmFsdHkiLCJzZWVkIiwibWF4UmV0cmllcyIsIk51bWJlciIsImlzSW50ZWdlciIsInBhcmFtZXRlciIsImNvbnZlcnRab2RUb0pTT05TY2hlbWEiLCJ6b2RTY2hlbWEiLCJBUElDYWxsRXJyb3IiLCJSZXRyeUVycm9yIiwiZ2V0RXJyb3JNZXNzYWdlIiwiaXNBYm9ydEVycm9yIiwiZGVsYXkiLCJkZWxheUluTXMiLCJzZXRUaW1lb3V0IiwicmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiaW5pdGlhbERlbGF5SW5NcyIsImJhY2tvZmZGYWN0b3IiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImVycm9ycyIsImVycm9yIiwiZXJyb3JNZXNzYWdlIiwibmV3RXJyb3JzIiwidHJ5TnVtYmVyIiwicmVhc29uIiwiaXNBUElDYWxsRXJyb3IiLCJpc1JldHJ5YWJsZSIsInRleHRTdHJlYW1QYXJ0IiwiY29kZSIsIm5hbWUiLCJwYXJzZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCIsImlkIiwiaXRlbSIsImFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCIsInRocmVhZElkIiwibWVzc2FnZUlkIiwiZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0IiwidG9vbENhbGxTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInN0cmVhbVBhcnRzIiwic3RyZWFtUGFydHNCeUNvZGUiLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsInZhbGlkQ29kZXMiLCJwYXJzZVN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJzbGljZSIsImluY2x1ZGVzIiwidGV4dFZhbHVlIiwianNvblZhbHVlIiwiSlNPTiIsImZvcm1hdFN0cmVhbVBhcnQiLCJzdHJlYW1QYXJ0IiwiZmluZCIsInN0cmluZ2lmeSIsImNyZWF0ZUNodW5rRGVjb2RlciIsImNvbXBsZXgiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJkZWNvZGVkIiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiY3JlYXRlUGFyc2VyIiwiY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lciIsImN1c3RvbVBhcnNlciIsInRleHREZWNvZGVyIiwiZXZlbnRTb3VyY2VQYXJzZXIiLCJUcmFuc2Zvcm1TdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXIiLCJldmVudCIsImRhdGEiLCJ0ZXJtaW5hdGUiLCJwYXJzZWRNZXNzYWdlIiwiZW5xdWV1ZSIsInRyYW5zZm9ybSIsImZlZWQiLCJjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lciIsImNiIiwidGV4dEVuY29kZXIiLCJUZXh0RW5jb2RlciIsImFnZ3JlZ2F0ZWRSZXNwb25zZSIsImNhbGxiYWNrcyIsIm9uU3RhcnQiLCJlbmNvZGUiLCJvblRva2VuIiwib25UZXh0IiwiZmx1c2giLCJpc09wZW5BSUNhbGxiYWNrcyIsImlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIiwib25Db21wbGV0aW9uIiwib25GaW5hbCIsInRyaW1TdGFydE9mU3RyZWFtSGVscGVyIiwiaXNTdHJlYW1TdGFydCIsInRyaW1TdGFydCIsIkFJU3RyZWFtIiwicmVzcG9uc2UiLCJvayIsImJvZHkiLCJSZWFkYWJsZVN0cmVhbSIsImVycm9yVGV4dCIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJwaXBlVGhyb3VnaCIsImNsb3NlIiwicmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwicHVsbCIsImNhbmNlbCIsInJldHVybiIsImNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciIsImVuY29kZXIiLCJwYXJzZU9wZW5BSVN0cmVhbSIsImV4dHJhY3QiLCJjaHVua1RvVGV4dCIsInN0cmVhbWFibGUiLCJjcmVhdGVkIiwiZ2V0RGF0ZSIsIm9iamVjdCIsIm1vZGVsIiwiY2hvaWNlcyIsImNob2ljZSIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJmdW5jdGlvbkNhbGwiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsImZpbmlzaF9yZWFzb24iLCJmaW5pc2hSZWFzb24iLCJ0cmltU3RhcnRPZlN0cmVhbSIsImlzRnVuY3Rpb25TdHJlYW1pbmdJbiIsImpzb24iLCJfaCIsIl9pIiwiX2oiLCJfayIsIl9sIiwiX20iLCJfbiIsIl9vIiwiX3AiLCJfcSIsIl9yIiwiaXNDaGF0Q29tcGxldGlvbkNodW5rIiwiaXNUZXh0IiwiY2xlYW51cEFyZ3VtZW50cyIsImlzQ29tcGxldGlvbiIsImFyZ3VtZW50Q2h1bmsiLCJlc2NhcGVkUGFydGlhbEpzb24iLCJyZXBsYWNlIiwiX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCIsIk9wZW5BSVN0cmVhbSIsImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCIsImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIiwiZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIiLCJjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImlzRmlyc3RDaHVuayIsImFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSIsImZ1bmN0aW9uQ2FsbE1lc3NhZ2VzIiwic2hvdWxkSGFuZGxlQXNGdW5jdGlvbiIsInN0YXJ0c1dpdGgiLCJwYXlsb2FkIiwibmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJmdW5jdGlvblJlc3BvbnNlIiwiY29uc29sZSIsIndhcm4iLCJhcmd1bWVudHNQYXlsb2FkIiwicmVzdWx0IiwidG9vbHMiLCJ0b29sIiwiZnVuYyIsInJlc3BvbnNlSW5kZXgiLCJ0b29sX2NhbGxfaWQiLCJmdW5jdGlvbl9uYW1lIiwidG9vbF9jYWxsX3Jlc3VsdCIsImUiLCJmaWx0ZXJlZENhbGxiYWNrcyIsIm9wZW5BSVN0cmVhbSIsIlNUUkVBTUFCTEVfVkFMVUVfVFlQRSIsImZvciIsIkRFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FIiwiY3JlYXRlU3RyZWFtYWJsZVVJIiwiY3VycmVudFZhbHVlIiwiY2xvc2VkIiwiYXNzZXJ0U3RyZWFtIiwibWV0aG9kIiwid2FybmluZ1RpbWVvdXQiLCJ3YXJuVW5jbG9zZWRTdHJlYW0iLCJwcm9jZXNzIiwiY2xlYXJUaW1lb3V0IiwicmVzb2x2YWJsZSIsIlNUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DSyIsImNyZWF0ZVN0cmVhbWFibGVWYWx1ZSIsImlzUmVhZGFibGVTdHJlYW0iLCJsb2NrZWQiLCJjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsIiwic3RyZWFtYWJsZVZhbHVlIiwiY3VycmVudEVycm9yIiwiY3VycmVudFByb21pc2UiLCJjdXJyZW50UGF0Y2hWYWx1ZSIsImNyZWF0ZVdyYXBwZWQiLCJpbml0aWFsQ2h1bmsiLCJpbml0IiwiY3VyciIsInVwZGF0ZVZhbHVlU3RhdGVzIiwicmVzb2x2ZVByZXZpb3VzIiwicmVuZGVyIiwidWkiLCJpbml0aWFsIiwiZnVuY3Rpb25zIiwiT2JqZWN0IiwiZW50cmllcyIsImRlc2NyaXB0aW9uIiwicGFyYW1ldGVycyIsImZpbmlzaGVkIiwiaGFuZGxlUmVuZGVyIiwicmVuZGVyZXIiLCJ0aGVuIiwibm9kZSIsIml0ZXJhdG9yIiwiaGFzRnVuY3Rpb24iLCJwcm92aWRlciIsImNoYXQiLCJjb21wbGV0aW9ucyIsImNyZWF0ZSIsImZ1bmN0aW9uQ2FsbFBheWxvYWQiLCJ0b29sQ2FsbFBheWxvYWQiLCJJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIiwiTm9TdWNoVG9vbEVycm9yIiwic2FmZVBhcnNlSlNPTiIsImRlZmF1bHRUZXh0UmVuZGVyZXIiLCJzdHJlYW1VSSIsImFib3J0U2lnbmFsIiwic2V0dGluZ3MiLCJ0ZXh0UmVuZGVyIiwicmV0cnkiLCJ2YWxpZGF0ZWRQcm9tcHQiLCJkb1N0cmVhbSIsIm1vZGUiLCJpbnB1dEZvcm1hdCIsImZvcmtlZFN0cmVhbSIsInRlZSIsImhhc1Rvb2xDYWxsIiwidGV4dERlbHRhIiwidG9vbE5hbWUiLCJhdmFpbGFibGVUb29scyIsImtleXMiLCJwYXJzZVJlc3VsdCIsInNjaGVtYSIsInN1Y2Nlc3MiLCJ0b29sQXJncyIsImNhdXNlIiwidG9vbENhbGxJZCIsImdlbmVyYXRlIiwiUmVhY3QiLCJJbnRlcm5hbEFJUHJvdmlkZXIiLCJpbm5lckFjdGlvbiIsImFjdGlvbiIsIndyYXBBY3Rpb24iLCJiaW5kIiwiY3JlYXRlQUkiLCJhY3Rpb25zIiwiaW5pdGlhbEFJU3RhdGUiLCJpbml0aWFsVUlTdGF0ZSIsIm9uR2V0VUlTdGF0ZSIsIndyYXBwZWRBY3Rpb25zIiwid3JhcHBlZFN5bmNVSVN0YXRlIiwiQUkiLCJwcm9wcyIsInVpU3RhdGUiLCJhaVN0YXRlIiwiYWlTdGF0ZURlbHRhIiwibmV3QUlTdGF0ZURlbHRhIiwibmV3VUlTdGF0ZSIsImluaXRpYWxBSVN0YXRlUGF0Y2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ e0),
/* harmony export */   readStreamableValue: () => (/* binding */ e1),
/* harmony export */   useAIState: () => (/* binding */ e2),
/* harmony export */   useActions: () => (/* binding */ e3),
/* harmony export */   useStreamableValue: () => (/* binding */ e4),
/* harmony export */   useSyncUIState: () => (/* binding */ e5),
/* harmony export */   useUIState: () => (/* binding */ e6)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#InternalAIProvider`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#readStreamableValue`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useAIState`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useActions`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useStreamableValue`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useSyncUIState`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useUIState`);


/***/ })

};
;