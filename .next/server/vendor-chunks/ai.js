"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/shared-client/streamable.tsx\n\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/shared-client/streamable.tsx\nfunction hasReadableValueSignature(value) {\n    return !!(value && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE);\n}\nfunction assertStreamableValue(value) {\n    if (!hasReadableValueSignature(value)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n}\nfunction isStreamableValue(value) {\n    const hasSignature = hasReadableValueSignature(value);\n    if (!hasSignature && typeof value !== \"undefined\") {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction readStreamableValue(streamableValue) {\n    assertStreamableValue(streamableValue);\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let curr = row.curr;\n            let done = false;\n            let initial = true;\n            return {\n                async next () {\n                    if (done) return {\n                        value: curr,\n                        done: true\n                    };\n                    row = await row;\n                    if (typeof row.error !== \"undefined\") {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            switch(row.diff[0]){\n                                case 0:\n                                    if (typeof curr !== \"string\") {\n                                        throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                    } else {\n                                        curr = curr + row.diff[1];\n                                    }\n                                    break;\n                            }\n                        } else {\n                            curr = row.curr;\n                        }\n                        if (!row.next) {\n                            done = true;\n                            return {\n                                value: curr,\n                                done: false\n                            };\n                        }\n                    }\n                    if (!row.next) {\n                        return {\n                            value: curr,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (initial) {\n                        initial = false;\n                        if (typeof curr === \"undefined\") {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value: curr,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!isStreamableValue(streamableValue)) return;\n        let cancelled = false;\n        const iterator = readStreamableValue(streamableValue);\n        if (streamableValue.next) {\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                if (cancelled) return;\n                setPending(true);\n            });\n        }\n        (async ()=>{\n            try {\n                for await (const value of iterator){\n                    if (cancelled) return;\n                    (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                        if (cancelled) return;\n                        setCurr(value);\n                    });\n                }\n            } catch (e) {\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setError(e);\n                });\n            } finally{\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setPending(false);\n                });\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// rsc/utils.tsx\n\n\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nvar isFunction = (x)=>typeof x === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (resolvedInitialAIStatePatch) {\n            return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n        }\n        return initialAIState;\n    }, [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        aiStateRef.current = aiState[0];\n    }, [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.fromEntries(Object.entries(wrappedActions).map(([key, action])=>[\n                key,\n                async (...args)=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                    (async ()=>{\n                        const delta = await aiStateDelta;\n                        if (delta !== void 0) {\n                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                        }\n                    })();\n                    return result;\n                }\n            ])), [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!wrappedSyncUIState) {\n            return ()=>{};\n        }\n        return async ()=>{\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n            if (uiState2 !== void 0) {\n                setUIState(uiState2);\n            }\n            const delta = await aiStateDelta;\n            if (delta !== void 0) {\n                const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                setAIState(patchedAiState);\n            }\n        };\n    }, [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : (newState)=>{\n        if (isFunction(newState)) {\n            return state[1]((s)=>{\n                return {\n                    ...s,\n                    [key]: newState(s[key])\n                };\n            });\n        } else {\n            return state[1]({\n                ...state[0],\n                [key]: newState\n            });\n        }\n    }, [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNoYXJlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTJEOztBQ0FwRCxJQUFNRyx3QkFBd0JDLE9BQU9DLEdBQUEsQ0FBSTtBQUN6QyxJQUFNQyxzQ0FBc0MsS0FBSzs7QURHeEQsU0FBU0MsMEJBQTBCQyxLQUFBO0lBQ2pDLE9BQU8sQ0FBQyxDQUNOQSxDQUFBQSxTQUNBLE9BQU9BLFVBQVUsWUFDakIsVUFBVUEsU0FDVkEsTUFBTUMsSUFBQSxLQUFTTixxQkFBQTtBQUVuQjtBQUVBLFNBQVNPLHNCQUNQRixLQUFBO0lBRUEsSUFBSSxDQUFDRCwwQkFBMEJDLFFBQVE7UUFDckMsTUFBTSxJQUFJRyxNQUNSO0lBRUo7QUFDRjtBQUVBLFNBQVNDLGtCQUFrQkosS0FBQTtJQUN6QixNQUFNSyxlQUFlTiwwQkFBMEJDO0lBRS9DLElBQUksQ0FBQ0ssZ0JBQWdCLE9BQU9MLFVBQVUsYUFBYTtRQUNqRCxNQUFNLElBQUlHLE1BQ1I7SUFFSjtJQUVBLE9BQU9FO0FBQ1Q7QUFnQ08sU0FBU0Msb0JBQ2RDLGVBQUE7SUFFQUwsc0JBQXNCSztJQUV0QixPQUFPO1FBQ0wsQ0FBQ1gsT0FBT1ksYUFBYTtZQUNuQixJQUFJQyxNQUNGRjtZQUNGLElBQUlHLE9BQU9ELElBQUlDLElBQUE7WUFDZixJQUFJQyxPQUFPO1lBQ1gsSUFBSUMsVUFBVTtZQUVkLE9BQU87Z0JBQ0wsTUFBTUM7b0JBQ0osSUFBSUYsTUFBTSxPQUFPO3dCQUFFWCxPQUFPVTt3QkFBTUMsTUFBTTtvQkFBSztvQkFFM0NGLE1BQU0sTUFBTUE7b0JBRVosSUFBSSxPQUFPQSxJQUFJSyxLQUFBLEtBQVUsYUFBYTt3QkFDcEMsTUFBTUwsSUFBSUssS0FBQTtvQkFDWjtvQkFDQSxJQUFJLFVBQVVMLE9BQU9BLElBQUlNLElBQUEsRUFBTTt3QkFDN0IsSUFBSU4sSUFBSU0sSUFBQSxFQUFNOzRCQUNaLE9BQVFOLElBQUlNLElBQUEs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QUFBLENBQ25CLE9BQU82QixRQUFRLGNBQ1hXLEtBQUEsQ0FBTSxFQUFDLEdBQ1AsQ0FBQ1E7UUFDQyxJQUFJbkQsV0FBV21ELFdBQVc7WUFDeEIsT0FBT1IsS0FBQSxDQUFNLEVBQUMsQ0FBRSxDQUFBUztnQkFDZCxPQUFPO29CQUFFLEdBQUdBLENBQUE7b0JBQUcsQ0FBQ3BCLElBQUcsRUFBR21CLFNBQVNDLENBQUEsQ0FBRXBCLElBQUk7Z0JBQUU7WUFDekM7UUFDRixPQUFPO1lBQ0wsT0FBT1csS0FBQSxDQUFNLEVBQUMsQ0FBRTtnQkFBRSxHQUFHQSxLQUFBLENBQU0sRUFBQztnQkFBRyxDQUFDWCxJQUFHLEVBQUdtQjtZQUFTO1FBQ2pEO0lBQ0YsR0FDSjtRQUFDbkI7S0FBRztJQUdOLElBQUlFLEtBQUtjLE1BQUEsS0FBVyxHQUFHO1FBQ3JCLE9BQU9MO0lBQ1QsT0FBTztRQUNMLE9BQU87WUFBQ0EsS0FBQSxDQUFNLEVBQUMsQ0FBRVQsSUFBQSxDQUFLLEVBQUU7WUFBR2U7U0FBTTtJQUNuQztBQUNGO0FBRU8sU0FBU0k7SUFHZCxNQUFNQyxVQUFnQm5ELDZDQUFBLENBQWNHO0lBQ3BDLE9BQU9nRDtBQUNUO0FBRU8sU0FBU0M7SUFDZCxNQUFNQyxjQUFvQnJELDZDQUFBLENBQ3hCSTtJQUdGLElBQUlpRCxnQkFBZ0IsTUFBTTtRQUN4QixNQUFNLElBQUkxRixNQUFNO0lBQ2xCO0lBRUEsT0FBTzBGO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc2hhcmVkLWNsaWVudC9zdHJlYW1hYmxlLnRzeD9lMThiIiwid2VicGFjazovLy8uLi9jb25zdGFudHMudHM/YWI3MiIsIndlYnBhY2s6Ly8vLi4vc2hhcmVkLWNsaWVudC9jb250ZXh0LnRzeD9jYjNmIiwid2VicGFjazovLy8uLi91dGlscy50c3g/N2EyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24sIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHR5cGUgeyBTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmZ1bmN0aW9uIGhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBTdHJlYW1hYmxlVmFsdWUge1xuICByZXR1cm4gISEoXG4gICAgdmFsdWUgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgJ3R5cGUnIGluIHZhbHVlICYmXG4gICAgdmFsdWUudHlwZSA9PT0gU1RSRUFNQUJMRV9WQUxVRV9UWVBFXG4gICk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmVhbWFibGVWYWx1ZShcbiAgdmFsdWU6IHVua25vd24sXG4pOiBhc3NlcnRzIHZhbHVlIGlzIFN0cmVhbWFibGVWYWx1ZSB7XG4gIGlmICghaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW52YWxpZCB2YWx1ZTogdGhpcyBob29rIG9ubHkgYWNjZXB0cyB2YWx1ZXMgY3JlYXRlZCB2aWEgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZWAuJyxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RyZWFtYWJsZVZhbHVlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU3RyZWFtYWJsZVZhbHVlIHtcbiAgY29uc3QgaGFzU2lnbmF0dXJlID0gaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSh2YWx1ZSk7XG5cbiAgaWYgKCFoYXNTaWduYXR1cmUgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHZhbHVlOiB0aGlzIGhvb2sgb25seSBhY2NlcHRzIHZhbHVlcyBjcmVhdGVkIHZpYSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlYC4nLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gaGFzU2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0YWtlcyBhIHN0cmVhbWFibGUgdmFsdWUgY3JlYXRlZCB2aWEgdGhlIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoKS52YWx1ZWAgQVBJLFxuICogYW5kIHJldHVybnMgYW4gYXN5bmMgaXRlcmF0b3IuXG4gKlxuICogYGBganNcbiAqIC8vIEluc2lkZSB5b3VyIEFJIGFjdGlvbjpcbiAqXG4gKiBhc3luYyBmdW5jdGlvbiBhY3Rpb24oKSB7XG4gKiAgICd1c2Ugc2VydmVyJ1xuICogICBjb25zdCBzdHJlYW1hYmxlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCk7XG4gKlxuICogICBzdHJlYW1hYmxlLnVwZGF0ZSgxKTtcbiAqICAgc3RyZWFtYWJsZS51cGRhdGUoMik7XG4gKiAgIHN0cmVhbWFibGUuZG9uZSgzKTtcbiAqICAgLy8gLi4uXG4gKiAgIHJldHVybiBzdHJlYW1hYmxlLnZhbHVlO1xuICogfVxuICogYGBgXG4gKlxuICogQW5kIHRvIHJlYWQgdGhlIHZhbHVlOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBzdHJlYW1hYmxlVmFsdWUgPSBhd2FpdCBhY3Rpb24oKVxuICogZm9yIGF3YWl0IChjb25zdCB2IG9mIHJlYWRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSkge1xuICogICBjb25zb2xlLmxvZyh2KVxuICogfVxuICogYGBgXG4gKlxuICogVGhpcyBsb2dzIG91dCAxLCAyLCAzIG9uIGNvbnNvbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3RyZWFtYWJsZVZhbHVlPFQgPSB1bmtub3duPihcbiAgc3RyZWFtYWJsZVZhbHVlOiBTdHJlYW1hYmxlVmFsdWU8VD4sXG4pOiBBc3luY0l0ZXJhYmxlPFQgfCB1bmRlZmluZWQ+IHtcbiAgYXNzZXJ0U3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgbGV0IHJvdzogU3RyZWFtYWJsZVZhbHVlPFQ+IHwgUHJvbWlzZTxTdHJlYW1hYmxlVmFsdWU8VD4+ID1cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlO1xuICAgICAgbGV0IGN1cnIgPSByb3cuY3VycjtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICBsZXQgaW5pdGlhbCA9IHRydWU7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybiB7IHZhbHVlOiBjdXJyLCBkb25lOiB0cnVlIH07XG5cbiAgICAgICAgICByb3cgPSBhd2FpdCByb3c7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHJvdy5lcnJvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IHJvdy5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdjdXJyJyBpbiByb3cgfHwgcm93LmRpZmYpIHtcbiAgICAgICAgICAgIGlmIChyb3cuZGlmZikge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHJvdy5kaWZmWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgcGF0Y2g6IGNhbiBvbmx5IGFwcGVuZCB0byBzdHJpbmcgdHlwZXMuIFRoaXMgaXMgYSBidWcgaW4gdGhlIEFJIFNESy4nLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKGN1cnIgYXMgc3RyaW5nKSA9IGN1cnIgKyByb3cuZGlmZlsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyID0gcm93LmN1cnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IGVtaXR0ZWQgeyBkb25lOiB0cnVlIH0gd29uJ3QgYmUgdXNlZCBhcyB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGJ5IHRoZSBmb3IgYXdhaXQuLi5vZiBzeW50YXguXG4gICAgICAgICAgICBpZiAoIXJvdy5uZXh0KSB7XG4gICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyLFxuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcm93Lm5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBjdXJyLFxuICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgPSByb3cubmV4dDtcbiAgICAgICAgICBpZiAoaW5pdGlhbCkge1xuICAgICAgICAgICAgaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBpbml0aWFsIGNodW5rIGFuZCB0aGVyZSBpc24ndCBhbiBpbml0aWFsIHZhbHVlIHlldC5cbiAgICAgICAgICAgICAgLy8gTGV0J3Mgc2tpcCB0aGlzIG9uZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogY3VycixcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogYHVzZVN0cmVhbWFibGVWYWx1ZWAgaXMgYSBSZWFjdCBob29rIHRoYXQgdGFrZXMgYSBzdHJlYW1hYmxlIHZhbHVlIGNyZWF0ZWQgdmlhIHRoZSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCkudmFsdWVgIEFQSSxcbiAqIGFuZCByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlLCBlcnJvciwgYW5kIHBlbmRpbmcgc3RhdGUuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbnN1bWluZyBzdHJlYW1hYmxlIHZhbHVlcyByZWNlaXZlZCBmcm9tIGEgY29tcG9uZW50J3MgcHJvcHMuIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbiBNeUNvbXBvbmVudCh7IHN0cmVhbWFibGVWYWx1ZSB9KSB7XG4gKiAgIGNvbnN0IFtkYXRhLCBlcnJvciwgcGVuZGluZ10gPSB1c2VTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKTtcbiAqXG4gKiAgIGlmIChwZW5kaW5nKSByZXR1cm4gPGRpdj5Mb2FkaW5nLi4uPC9kaXY+O1xuICogICBpZiAoZXJyb3IpIHJldHVybiA8ZGl2PkVycm9yOiB7ZXJyb3IubWVzc2FnZX08L2Rpdj47XG4gKlxuICogICByZXR1cm4gPGRpdj5EYXRhOiB7ZGF0YX08L2Rpdj47XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0cmVhbWFibGVWYWx1ZTxUID0gdW5rbm93biwgRXJyb3IgPSB1bmtub3duPihcbiAgc3RyZWFtYWJsZVZhbHVlPzogU3RyZWFtYWJsZVZhbHVlPFQ+LFxuKTogW2RhdGE6IFQgfCB1bmRlZmluZWQsIGVycm9yOiBFcnJvciB8IHVuZGVmaW5lZCwgcGVuZGluZzogYm9vbGVhbl0ge1xuICBjb25zdCBbY3Vyciwgc2V0Q3Vycl0gPSB1c2VTdGF0ZTxUIHwgdW5kZWZpbmVkPihcbiAgICBpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gc3RyZWFtYWJsZVZhbHVlLmN1cnIgOiB1bmRlZmluZWQsXG4gICk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8RXJyb3IgfCB1bmRlZmluZWQ+KFxuICAgIGlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkgPyBzdHJlYW1hYmxlVmFsdWUuZXJyb3IgOiB1bmRlZmluZWQsXG4gICk7XG4gIGNvbnN0IFtwZW5kaW5nLCBzZXRQZW5kaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KFxuICAgIGlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkgPyAhIXN0cmVhbWFibGVWYWx1ZS5uZXh0IDogZmFsc2UsXG4gICk7XG5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkpIHJldHVybjtcblxuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gcmVhZFN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuICAgIGlmIChzdHJlYW1hYmxlVmFsdWUubmV4dCkge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzZXRQZW5kaW5nKHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHNldEN1cnIodmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgc2V0RXJyb3IoZSBhcyBFcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gIH0sIFtzdHJlYW1hYmxlVmFsdWVdKTtcblxuICByZXR1cm4gW2N1cnIsIGVycm9yLCBwZW5kaW5nXTtcbn1cbiIsImV4cG9ydCBjb25zdCBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUgPSBTeW1ib2wuZm9yKCd1aS5zdHJlYW1hYmxlLnZhbHVlJyk7XG5leHBvcnQgY29uc3QgREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUgPSAxNSAqIDEwMDA7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cbid1c2UgY2xpZW50JztcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgKiBhcyBqc29uZGlmZnBhdGNoIGZyb20gJ2pzb25kaWZmcGF0Y2gnO1xuaW1wb3J0IHR5cGUge1xuICBJbnRlcm5hbEFJUHJvdmlkZXJQcm9wcyxcbiAgQUlQcm92aWRlcixcbiAgSW5mZXJBSVN0YXRlLFxuICBWYWx1ZU9yVXBkYXRlcixcbiAgSW5mZXJBY3Rpb25zLFxuICBJbmZlclVJU3RhdGUsXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IEludGVybmFsVUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDxudWxsIHwgYW55PihudWxsKTtcbmNvbnN0IEludGVybmFsQUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDx1bmRlZmluZWQgfCBhbnk+KHVuZGVmaW5lZCk7XG5jb25zdCBJbnRlcm5hbEFjdGlvblByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDxudWxsIHwgYW55PihudWxsKTtcbmNvbnN0IEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlciA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8bnVsbCB8IGFueT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBJbnRlcm5hbEFJUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbiAgaW5pdGlhbFVJU3RhdGUsXG4gIGluaXRpYWxBSVN0YXRlLFxuICBpbml0aWFsQUlTdGF0ZVBhdGNoLFxuICB3cmFwcGVkQWN0aW9ucyxcbiAgd3JhcHBlZFN5bmNVSVN0YXRlLFxufTogSW50ZXJuYWxBSVByb3ZpZGVyUHJvcHMpIHtcbiAgaWYgKCEoJ3VzZScgaW4gUmVhY3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBSZWFjdCB2ZXJzaW9uLicpO1xuICB9XG5cbiAgY29uc3QgdWlTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxVSVN0YXRlKTtcbiAgY29uc3Qgc2V0VUlTdGF0ZSA9IHVpU3RhdGVbMV07XG5cbiAgY29uc3QgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoID0gaW5pdGlhbEFJU3RhdGVQYXRjaFxuICAgID8gKFJlYWN0IGFzIGFueSkudXNlKGluaXRpYWxBSVN0YXRlUGF0Y2gpXG4gICAgOiB1bmRlZmluZWQ7XG4gIGluaXRpYWxBSVN0YXRlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCkge1xuICAgICAgcmV0dXJuIGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgIGpzb25kaWZmcGF0Y2guY2xvbmUoaW5pdGlhbEFJU3RhdGUpLFxuICAgICAgICByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2gsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbEFJU3RhdGU7XG4gIH0sIFtpbml0aWFsQUlTdGF0ZSwgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoXSk7XG5cbiAgY29uc3QgYWlTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxBSVN0YXRlKTtcbiAgY29uc3Qgc2V0QUlTdGF0ZSA9IGFpU3RhdGVbMV07XG4gIGNvbnN0IGFpU3RhdGVSZWYgPSBSZWFjdC51c2VSZWYoYWlTdGF0ZVswXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBhaVN0YXRlUmVmLmN1cnJlbnQgPSBhaVN0YXRlWzBdO1xuICB9LCBbYWlTdGF0ZVswXV0pO1xuXG4gIGNvbnN0IGNsaWVudFdyYXBwZWRBY3Rpb25zID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PlxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyh3cmFwcGVkQWN0aW9ucykubWFwKChba2V5LCBhY3Rpb25dKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGFzeW5jICguLi5hcmdzOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFpU3RhdGVTbmFwc2hvdCA9IGFpU3RhdGVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGNvbnN0IFthaVN0YXRlRGVsdGEsIHJlc3VsdF0gPSBhd2FpdCBhY3Rpb24oXG4gICAgICAgICAgICAgIGFpU3RhdGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IGF3YWl0IGFpU3RhdGVEZWx0YTtcbiAgICAgICAgICAgICAgaWYgKGRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhaVN0YXRlWzFdKFxuICAgICAgICAgICAgICAgICAganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAgICAgICAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShhaVN0YXRlU25hcHNob3QpLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgXSksXG4gICAgICApLFxuICAgIFt3cmFwcGVkQWN0aW9uc10sXG4gICk7XG5cbiAgY29uc3QgY2xpZW50V3JhcHBlZFN5bmNVSVN0YXRlQWN0aW9uID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCF3cmFwcGVkU3luY1VJU3RhdGUpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWlTdGF0ZVNuYXBzaG90ID0gYWlTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgW2FpU3RhdGVEZWx0YSwgdWlTdGF0ZV0gPSBhd2FpdCB3cmFwcGVkU3luY1VJU3RhdGUhKFxuICAgICAgICBhaVN0YXRlU25hcHNob3QsXG4gICAgICApO1xuXG4gICAgICBpZiAodWlTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldFVJU3RhdGUodWlTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbHRhID0gYXdhaXQgYWlTdGF0ZURlbHRhO1xuICAgICAgaWYgKGRlbHRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcGF0Y2hlZEFpU3RhdGUgPSBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICAgIGpzb25kaWZmcGF0Y2guY2xvbmUoYWlTdGF0ZVNuYXBzaG90KSxcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgKTtcbiAgICAgICAgc2V0QUlTdGF0ZShwYXRjaGVkQWlTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3dyYXBwZWRTeW5jVUlTdGF0ZV0pO1xuXG4gIHJldHVybiAoXG4gICAgPEludGVybmFsQUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyIHZhbHVlPXthaVN0YXRlfT5cbiAgICAgIDxJbnRlcm5hbFVJU3RhdGVQcm92aWRlci5Qcm92aWRlciB2YWx1ZT17dWlTdGF0ZX0+XG4gICAgICAgIDxJbnRlcm5hbEFjdGlvblByb3ZpZGVyLlByb3ZpZGVyIHZhbHVlPXtjbGllbnRXcmFwcGVkQWN0aW9uc30+XG4gICAgICAgICAgPEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlci5Qcm92aWRlclxuICAgICAgICAgICAgdmFsdWU9e2NsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbn1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgPC9JbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXI+XG4gICAgICAgIDwvSW50ZXJuYWxBY3Rpb25Qcm92aWRlci5Qcm92aWRlcj5cbiAgICAgIDwvSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXI+XG4gICAgPC9JbnRlcm5hbEFJU3RhdGVQcm92aWRlci5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpIHtcbiAgdHlwZSBUID0gSW5mZXJVSVN0YXRlPEFJLCBhbnk+O1xuXG4gIGNvbnN0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dDxcbiAgICBbVCwgKHY6IFQgfCAoKHZfOiBUKSA9PiBUKSkgPT4gdm9pZF0gfCBudWxsIHwgdW5kZWZpbmVkXG4gID4oSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIpO1xuICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VVSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9XG4gIGlmIChzdGF0ZVswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Bpbml0aWFsVUlTdGF0ZWAgbXVzdCBiZSBwcm92aWRlZCB0byBgY3JlYXRlQUlgIG9yIGA8QUk+YCcsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8vIFRPRE86IEhvdyBkbyB3ZSBhdm9pZCBjYXVzaW5nIGEgcmUtcmVuZGVyIHdoZW4gdGhlIEFJIHN0YXRlIGNoYW5nZXMgYnV0IHlvdVxuLy8gYXJlIG9ubHkgbGlzdGVuaW5nIHRvIGEgc3BlY2lmaWMga2V5PyBXZSBuZWVkIHVzZVNFUyBwZXJoYXBzP1xuZnVuY3Rpb24gdXNlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCk6IFtcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuICAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPEluZmVyQUlTdGF0ZTxBSSwgYW55Pj4pID0+IHZvaWQsXG5dO1xuZnVuY3Rpb24gdXNlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IFtcbiAgSW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldLFxuICAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XT4pID0+IHZvaWQsXG5dO1xuZnVuY3Rpb24gdXNlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICAuLi5hcmdzOiBbXSB8IFtrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT5dXG4pIHtcbiAgdHlwZSBUID0gSW5mZXJBSVN0YXRlPEFJLCBhbnk+O1xuXG4gIGNvbnN0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dDxcbiAgICBbVCwgKG5ld1N0YXRlOiBWYWx1ZU9yVXBkYXRlcjxUPikgPT4gdm9pZF0gfCBudWxsIHwgdW5kZWZpbmVkXG4gID4oSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIpO1xuICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B1c2VBSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuJyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICB9XG4gIGlmIChzdGF0ZVswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2Bpbml0aWFsQUlTdGF0ZWAgbXVzdCBiZSBwcm92aWRlZCB0byBgY3JlYXRlQUlgIG9yIGA8QUk+YCcsXG4gICAgKTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggPj0gMSAmJiB0eXBlb2Ygc3RhdGVbMF0gIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1doZW4gdXNpbmcgYHVzZUFJU3RhdGVgIHdpdGggYSBrZXksIHRoZSBBSSBzdGF0ZSBtdXN0IGJlIGFuIG9iamVjdC4nLFxuICAgICk7XG4gIH1cblxuICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICBjb25zdCBzZXR0ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJ1xuICAgICAgPyBzdGF0ZVsxXVxuICAgICAgOiAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPFQ+KSA9PiB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24obmV3U3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVbMV0ocyA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLnMsIFtrZXldOiBuZXdTdGF0ZShzW2tleV0pIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlWzFdKHsgLi4uc3RhdGVbMF0sIFtrZXldOiBuZXdTdGF0ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgW2tleV0sXG4gICk7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbc3RhdGVbMF1bYXJnc1swXV0sIHNldHRlcl07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGlvbnM8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PigpIHtcbiAgdHlwZSBUID0gSW5mZXJBY3Rpb25zPEFJLCBhbnk+O1xuXG4gIGNvbnN0IGFjdGlvbnMgPSBSZWFjdC51c2VDb250ZXh0PFQ+KEludGVybmFsQWN0aW9uUHJvdmlkZXIpO1xuICByZXR1cm4gYWN0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN5bmNVSVN0YXRlKCkge1xuICBjb25zdCBzeW5jVUlTdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQ8KCkgPT4gUHJvbWlzZTx2b2lkPj4oXG4gICAgSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyLFxuICApO1xuXG4gIGlmIChzeW5jVUlTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHVzZVN5bmNVSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuJyk7XG4gIH1cblxuICByZXR1cm4gc3luY1VJU3RhdGU7XG59XG5cbmV4cG9ydCB7IHVzZUFJU3RhdGUgfTtcbiIsImltcG9ydCBSZWFjdCwgeyBTdXNwZW5zZSB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPFQgPSBhbnk+KCkge1xuICBsZXQgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkLCByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmU6IHJlc29sdmUhLFxuICAgIHJlamVjdDogcmVqZWN0ISxcbiAgfTtcbn1cblxuLy8gVXNlIHRoZSBuYW1lIGBSYCBmb3IgYFJvd2AgYXMgaXQgd2lsbCBiZSBzaG9ydGVyIGluIHRoZSBSU0MgcGF5bG9hZC5cbmNvbnN0IFIgPSBbXG4gIChhc3luYyAoe1xuICAgIGMsIC8vIGN1cnJlbnRcbiAgICBuLCAvLyBuZXh0XG4gIH06IHtcbiAgICBjOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgbjogUHJvbWlzZTxhbnk+O1xuICB9KSA9PiB7XG4gICAgY29uc3QgY2h1bmsgPSBhd2FpdCBuO1xuICAgIGlmIChjaHVuay5kb25lKSB7XG4gICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGNodW5rLmFwcGVuZCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICB7Y31cbiAgICAgICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2NodW5rLnZhbHVlfT5cbiAgICAgICAgICAgIDxSIGM9e2NodW5rLnZhbHVlfSBuPXtjaHVuay5uZXh0fSAvPlxuICAgICAgICAgIDwvU3VzcGVuc2U+XG4gICAgICAgIDwvPlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtjaHVuay52YWx1ZX0+XG4gICAgICAgIDxSIGM9e2NodW5rLnZhbHVlfSBuPXtjaHVuay5uZXh0fSAvPlxuICAgICAgPC9TdXNwZW5zZT5cbiAgICApO1xuICB9KSBhcyB1bmtub3duIGFzIFJlYWN0LkZDPHtcbiAgICBjOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgbjogUHJvbWlzZTxhbnk+O1xuICB9Pixcbl1bMF07XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdXNwZW5zZWRDaHVuayhpbml0aWFsVmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkge1xuICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcblxuICByZXR1cm4ge1xuICAgIHJvdzogKFxuICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtpbml0aWFsVmFsdWV9PlxuICAgICAgICA8UiBjPXtpbml0aWFsVmFsdWV9IG49e3Byb21pc2V9IC8+XG4gICAgICA8L1N1c3BlbnNlPlxuICAgICksXG4gICAgcmVzb2x2ZSxcbiAgICByZWplY3QsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHg6IHVua25vd24pOiB4IGlzIEZ1bmN0aW9uID0+XG4gIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgY29uc3VtZVN0cmVhbSA9IGFzeW5jIChzdHJlYW06IFJlYWRhYmxlU3RyZWFtKSA9PiB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIGJyZWFrO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbInN0YXJ0VHJhbnNpdGlvbiIsInVzZUxheW91dEVmZmVjdCIsInVzZVN0YXRlIiwiU1RSRUFNQUJMRV9WQUxVRV9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUiLCJoYXNSZWFkYWJsZVZhbHVlU2lnbmF0dXJlIiwidmFsdWUiLCJ0eXBlIiwiYXNzZXJ0U3RyZWFtYWJsZVZhbHVlIiwiRXJyb3IiLCJpc1N0cmVhbWFibGVWYWx1ZSIsImhhc1NpZ25hdHVyZSIsInJlYWRTdHJlYW1hYmxlVmFsdWUiLCJzdHJlYW1hYmxlVmFsdWUiLCJhc3luY0l0ZXJhdG9yIiwicm93IiwiY3VyciIsImRvbmUiLCJpbml0aWFsIiwibmV4dCIsImVycm9yIiwiZGlmZiIsInVzZVN0cmVhbWFibGVWYWx1ZSIsInNldEN1cnIiLCJzZXRFcnJvciIsInBlbmRpbmciLCJzZXRQZW5kaW5nIiwiY2FuY2VsbGVkIiwiaXRlcmF0b3IiLCJlIiwiUmVhY3QiLCJqc29uZGlmZnBhdGNoIiwiU3VzcGVuc2UiLCJGcmFnbWVudCIsImpzeCIsImpzeHMiLCJSIiwiYyIsIm4iLCJjaHVuayIsImFwcGVuZCIsImNoaWxkcmVuIiwiZmFsbGJhY2siLCJpc0Z1bmN0aW9uIiwieCIsIkludGVybmFsVUlTdGF0ZVByb3ZpZGVyIiwiUmVhY3QyIiwiY3JlYXRlQ29udGV4dCIsIkludGVybmFsQUlTdGF0ZVByb3ZpZGVyIiwiSW50ZXJuYWxBY3Rpb25Qcm92aWRlciIsIkludGVybmFsU3luY1VJU3RhdGVQcm92aWRlciIsIkludGVybmFsQUlQcm92aWRlciIsImluaXRpYWxVSVN0YXRlIiwiaW5pdGlhbEFJU3RhdGUiLCJpbml0aWFsQUlTdGF0ZVBhdGNoIiwid3JhcHBlZEFjdGlvbnMiLCJ3cmFwcGVkU3luY1VJU3RhdGUiLCJ1aVN0YXRlIiwic2V0VUlTdGF0ZSIsInJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCIsInVzZSIsInVzZU1lbW8iLCJwYXRjaCIsImNsb25lIiwiYWlTdGF0ZSIsInNldEFJU3RhdGUiLCJhaVN0YXRlUmVmIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiY3VycmVudCIsImNsaWVudFdyYXBwZWRBY3Rpb25zIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwia2V5IiwiYWN0aW9uIiwiYXJncyIsImFpU3RhdGVTbmFwc2hvdCIsImFpU3RhdGVEZWx0YSIsInJlc3VsdCIsImRlbHRhIiwiY2xpZW50V3JhcHBlZFN5bmNVSVN0YXRlQWN0aW9uIiwicGF0Y2hlZEFpU3RhdGUiLCJQcm92aWRlciIsInVzZVVJU3RhdGUiLCJzdGF0ZSIsInVzZUNvbnRleHQiLCJBcnJheSIsImlzQXJyYXkiLCJ1c2VBSVN0YXRlIiwibGVuZ3RoIiwic2V0dGVyIiwidXNlQ2FsbGJhY2siLCJuZXdTdGF0ZSIsInMiLCJ1c2VBY3Rpb25zIiwiYWN0aW9ucyIsInVzZVN5bmNVSVN0YXRlIiwic3luY1VJU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_3___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$ACTION_0: () => (/* binding */ $$ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(rsc)/./node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jsondiffpatch */ \"(rsc)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"784eaeca1c316aa5d98fd936c53125000c396aeb\":\"$$ACTION_0\"} */ \n\n\n\n// rsc/utils.tsx\n\n\nfunction createResolvablePromise() {\n    let resolve, reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspensedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\nvar isFunction = (x)=>typeof x === \"function\";\nvar consumeStream = async (stream)=>{\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n};\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: state1,\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a = store.options).onSetAIState) == null ? void 0 : _b.call(_a, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/streamable.tsx\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.convertBase64ToUint8Array)(content);\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidDataContentError({\n        content\n    });\n}\n// core/prompt/convert-to-language-model-prompt.ts\nfunction convertToLanguageModelPrompt(prompt) {\n    const languageModelMessages = [];\n    if (prompt.system != null) {\n        languageModelMessages.push({\n            role: \"system\",\n            content: prompt.system\n        });\n    }\n    switch(prompt.type){\n        case \"prompt\":\n            {\n                languageModelMessages.push({\n                    role: \"user\",\n                    content: [\n                        {\n                            type: \"text\",\n                            text: prompt.prompt\n                        }\n                    ]\n                });\n                break;\n            }\n        case \"messages\":\n            {\n                languageModelMessages.push(...prompt.messages.map((message)=>{\n                    switch(message.role){\n                        case \"system\":\n                            {\n                                return {\n                                    role: \"system\",\n                                    content: message.content\n                                };\n                            }\n                        case \"user\":\n                            {\n                                if (typeof message.content === \"string\") {\n                                    return {\n                                        role: \"user\",\n                                        content: [\n                                            {\n                                                type: \"text\",\n                                                text: message.content\n                                            }\n                                        ]\n                                    };\n                                }\n                                return {\n                                    role: \"user\",\n                                    content: message.content.map((part)=>{\n                                        var _a;\n                                        switch(part.type){\n                                            case \"text\":\n                                                {\n                                                    return part;\n                                                }\n                                            case \"image\":\n                                                {\n                                                    if (part.image instanceof URL) {\n                                                        return {\n                                                            type: \"image\",\n                                                            image: part.image,\n                                                            mimeType: part.mimeType\n                                                        };\n                                                    }\n                                                    const imageUint8 = convertDataContentToUint8Array(part.image);\n                                                    return {\n                                                        type: \"image\",\n                                                        image: imageUint8,\n                                                        mimeType: (_a = part.mimeType) != null ? _a : detectImageMimeType(imageUint8)\n                                                    };\n                                                }\n                                        }\n                                    })\n                                };\n                            }\n                        case \"assistant\":\n                            {\n                                if (typeof message.content === \"string\") {\n                                    return {\n                                        role: \"assistant\",\n                                        content: [\n                                            {\n                                                type: \"text\",\n                                                text: message.content\n                                            }\n                                        ]\n                                    };\n                                }\n                                return {\n                                    role: \"assistant\",\n                                    content: message.content\n                                };\n                            }\n                        case \"tool\":\n                            {\n                                return message;\n                            }\n                    }\n                }));\n                break;\n            }\n        default:\n            {\n                const _exhaustiveCheck = prompt;\n                throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n            }\n    }\n    return languageModelMessages;\n}\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    return prompt.prompt != null ? {\n        type: \"prompt\",\n        prompt: prompt.prompt,\n        messages: void 0,\n        system: prompt.system\n    } : {\n        type: \"messages\",\n        prompt: void 0,\n        messages: prompt.messages,\n        // only possible case bc of checks above\n        system: prompt.system\n    };\n}\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({ maxTokens, temperature, topP, presencePenalty, frequencyPenalty, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        presencePenalty,\n        frequencyPenalty,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/util/convert-zod-to-json-schema.ts\n\nfunction convertZodToJSONSchema(zodSchema) {\n    return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(zodSchema);\n}\n// core/util/retry-with-exponential-backoff.ts\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n    return new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n    const streamPart = streamParts.find((part)=>part.name === type);\n    if (!streamPart) {\n        throw new Error(`Invalid stream part type: ${type}`);\n    }\n    return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_9__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a;\n            await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a = choice.delta) == null ? void 0 : _a.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = createChunkDecoder();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode(formatStreamPart(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode(formatStreamPart(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/streamable.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspensedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    return {\n        /**\n     * The value of the streamable UI. This can be returned from a Server Action and received by the client.\n     */ value: row,\n        /**\n     * This method updates the current UI node. It takes a new UI node and replaces the old one.\n     */ update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to append a new UI node to the end of the old one.\n     * Once appended a new UI node, the previous UI node cannot be updated anymore.\n     *\n     * @example\n     * ```jsx\n     * const ui = createStreamableUI(<div>hello</div>)\n     * ui.append(<div>world</div>)\n     *\n     * // The UI node will be:\n     * // <>\n     * //   <div>hello</div>\n     * //   <div>world</div>\n     * // </>\n     * ```\n     */ append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to signal that there is an error in the UI stream.\n     * It will be thrown on the client side and caught by the nearest error boundary component.\n     */ error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n        },\n        /**\n     * This method marks the UI node as finalized. You can either call it without any parameters or with a new UI node as the final state.\n     * Once called, the UI node cannot be updated or appended anymore.\n     *\n     * This method is always **required** to be called, otherwise the response will be stuck in a loading state.\n     */ done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n        }\n    };\n}\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    return {\n        /**\n     * @internal This is an internal lock to prevent the value from being\n     * updated by the user.\n     */ set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        /**\n     * The value of the streamable. This can be returned from a Server Action and\n     * received by the client. To read the streamed values, use the\n     * `readStreamableValue` or `useStreamableValue` APIs.\n     */ get value () {\n            return createWrapped(true);\n        },\n        /**\n     * This method updates the current value with a new one.\n     */ update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to append a delta string to the current value. It\n     * requires the current value of the streamable to be a string.\n     *\n     * @example\n     * ```jsx\n     * const streamable = createStreamableValue('hello');\n     * streamable.append(' world');\n     *\n     * // The value will be 'hello world'\n     * ```\n     */ append (value) {\n            assertStream(\".append()\");\n            if (typeof currentValue !== \"string\" && typeof currentValue !== \"undefined\") {\n                throw new Error(`.append(): The current value is not a string. Received: ${typeof currentValue}`);\n            }\n            if (typeof value !== \"string\") {\n                throw new Error(`.append(): The value is not a string. Received: ${typeof value}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            if (typeof currentValue === \"string\") {\n                currentPatchValue = [\n                    0,\n                    value\n                ];\n                currentValue = currentValue + value;\n            } else {\n                currentPatchValue = void 0;\n                currentValue = value;\n            }\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to signal that there is an error in the value stream.\n     * It will be thrown on the client side when consumed via\n     * `readStreamableValue` or `useStreamableValue`.\n     */ error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n        },\n        /**\n     * This method marks the value as finalized. You can either call it without\n     * any parameters or with a new value as the final state.\n     * Once called, the value cannot be updated or appended anymore.\n     *\n     * This method is always **required** to be called, otherwise the response\n     * will be stuck in a loading state.\n     */ done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return;\n            }\n            resolvable.resolve({});\n        }\n    };\n}\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name, { description, parameters }])=>{\n        return {\n            name,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a = options.functions) == null ? void 0 : _a[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a = options.tools) == null ? void 0 : _a[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, system, prompt, messages, maxRetries, abortSignal, initial, text, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(...args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n    });\n    const result = await retry(()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool])=>({\n                        type: \"function\",\n                        name,\n                        description: tool.description,\n                        parameters: convertZodToJSONSchema(tool.parameters)\n                    }))\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: convertToLanguageModelPrompt(validatedPrompt),\n            abortSignal\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            handleRender([\n                                {\n                                    content,\n                                    done: false,\n                                    delta: value.textDelta\n                                }\n                            ], textRender, ui);\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            handleRender([\n                                parseResult.value,\n                                {\n                                    toolName,\n                                    toolCallId: value.toolCallId\n                                }\n                            ], tool.generate, ui);\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {}\n                }\n            }\n            if (hasToolCall) {\n                await finished;\n                ui.done();\n            } else {\n                handleRender([\n                    {\n                        content,\n                        done: true\n                    }\n                ], textRender, ui);\n                await finished;\n                ui.done();\n            }\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/provider.tsx\n\n\n\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(\"784eaeca1c316aa5d98fd936c53125000c396aeb\", $$ACTION_0);\nasync function $$ACTION_0({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n}\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name in actions){\n        wrappedActions[name] = wrapAction(actions[name], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_3__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a = props.initialUIState) != null ? _a : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_10__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNlcnZlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDSDs7QUNEQztBQStCeEI7QUE3QkQsU0FBU007SUFDZCxJQUFJQyxTQUE2QkM7SUFDakMsTUFBTUMsVUFBVSxJQUFJQyxRQUFXLENBQUNDLEtBQUtDO1FBQ25DTCxVQUFVSTtRQUNWSCxTQUFTSTtJQUNYO0lBQ0EsT0FBTztRQUNMSDtRQUNBRjtRQUNBQztJQUNGO0FBQ0Y7QUFHQSxJQUFNSyxJQUFJO0lBQ1AsT0FBTyxFQUNOQyxDQUFBO0lBQ0FDLENBQUEsRUFDRjtRQUlFLE1BQU1DLFFBQVEsTUFBTUQ7UUFDcEIsSUFBSUMsTUFBTUMsSUFBQSxFQUFNO1lBQ2QsT0FBT0QsTUFBTUUsS0FBQTtRQUNmO1FBRUEsSUFBSUYsTUFBTUcsTUFBQSxFQUFRO1lBQ2hCLE9BQ0UsZ0JBQUFkLHVEQUFBQSxDQUFBRix1REFBQUEsRUFBQTtnQkFDR2lCLFVBQUE7b0JBQUFOO29CQUNELGdCQUFBVixzREFBQUEsQ0FBQ0YsMkNBQVFBLEVBQVI7d0JBQVNtQixVQUFVTCxNQUFNRSxLQUFBO3dCQUN4QkUsVUFBQSxnQkFBQWhCLHNEQUFBQSxDQUFDUyxHQUFBOzRCQUFFQyxHQUFHRSxNQUFNRSxLQUFBOzRCQUFPSCxHQUFHQyxNQUFNTSxJQUFBO3dCQUFBO29CQUFNO2lCQUNwQztZQUFBO1FBR047UUFFQSxPQUNFLGdCQUFBbEIsc0RBQUFBLENBQUNGLDJDQUFRQSxFQUFSO1lBQVNtQixVQUFVTCxNQUFNRSxLQUFBO1lBQ3hCRSxVQUFBLGdCQUFBaEIsc0RBQUFBLENBQUNTLEdBQUE7Z0JBQUVDLEdBQUdFLE1BQU1FLEtBQUE7Z0JBQU9ILEdBQUdDLE1BQU1NLElBQUE7WUFBQTtRQUFNO0lBR3hDO0NBSUYsQ0FBRSxFQUFDO0FBRUksU0FBU0MscUJBQXFCQyxZQUFBO0lBQ25DLE1BQU0sRUFBRWYsT0FBQSxF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LEtBQUksR0FBSTJQLFdBQVdHLE9BQUEsQ0FBUTlQLEtBQUksRUFBRztZQUMvQzdFO1FBQ0Y7SUFDRjtJQUVBLE1BQU1nVixxQkFBcUJGLGVBQ3ZCTixXQUFXTSxjQUFjLENBQUMsS0FDMUI7SUFFSixNQUFNRyxLQUE0QyxPQUFNQztRQWhIMUQsSUFBQXBWLElBQUFDO1FBaUhJLElBQUksdU1BQWNxVSxFQUFPO1lBSXZCLE1BQU0sSUFBSTNWLE1BQ1I7UUFFSjtRQUVBLElBQUkwVyxVQUFBLENBQVVyVixLQUFBb1YsTUFBTUwsY0FBQSxLQUFOLE9BQUEvVSxLQUF3QitVO1FBQ3RDLElBQUlPLFVBQUEsQ0FBVXJWLEtBQUFtVixNQUFNTixjQUFBLEtBQU4sT0FBQTdVLEtBQXdCNlU7UUFDdEMsSUFBSVMsZUFBZTtRQUVuQixJQUFJTCxvQkFBb0I7WUFDdEIsTUFBTSxDQUFDTSxpQkFBaUJDLFdBQVUsR0FBSSxNQUFNUCxtQkFBbUJJO1lBQy9ELElBQUlHLGVBQWUsUUFBVztnQkFDNUJGLGVBQWVDO2dCQUNmSCxVQUFVSTtZQUNaO1FBQ0Y7UUFFQSxPQUNFLGdCQUFBaFosc0RBQUFBLENBQUM4WCxnRUFBa0JBLEVBQWxCO1lBQ0NVO1lBQ0FDO1lBQ0FILGdCQUFnQk07WUFDaEJQLGdCQUFnQlE7WUFDaEJJLHFCQUFxQkg7WUFFcEI5WCxVQUFBMlgsTUFBTTNYLFFBQUE7UUFBQTtJQUdiO0lBRUEsT0FBTzBYO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vYWktc3RhdGUudHN4PzM4MDAiLCJ3ZWJwYWNrOi8vLy4uL3V0aWxzLnRzeD83YTJlIiwid2VicGFjazovLy8uLi9zdHJlYW1hYmxlLnRzeD82OTFmIiwid2VicGFjazovLy8uLi8uLi9jb3JlL3V0aWwvZGV0ZWN0LWltYWdlLW1pbWV0eXBlLnRzPzk1NDUiLCJ3ZWJwYWNrOi8vLy4uLy4uL2NvcmUvcHJvbXB0L2RhdGEtY29udGVudC50cz9lOTJmIiwid2VicGFjazovLy8uLi8uLi9jb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50cz83MTc0Iiwid2VicGFjazovLy8uLi8uLi9jb3JlL3Byb21wdC9nZXQtdmFsaWRhdGVkLXByb21wdC50cz81NzhlIiwid2VicGFjazovLy8uLi8uLi9jb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHM/ZDU4YyIsIndlYnBhY2s6Ly8vLi4vLi4vY29yZS91dGlsL2NvbnZlcnQtem9kLXRvLWpzb24tc2NoZW1hLnRzPzAwZmYiLCJ3ZWJwYWNrOi8vLy4uLy4uL2NvcmUvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHM/ZjBkMCIsIndlYnBhY2s6Ly8vLi4vLi4vY29yZS91dGlsL2RlbGF5LnRzP2ExZTciLCJ3ZWJwYWNrOi8vLy4uLy4uL3NoYXJlZC9zdHJlYW0tcGFydHMudHM/YzRhOCIsIndlYnBhY2s6Ly8vLi4vLi4vc2hhcmVkL3V0aWxzLnRzP2Y4Y2YiLCJ3ZWJwYWNrOi8vLy4uLy4uL3N0cmVhbXMvYWktc3RyZWFtLnRzPzQ4NTQiLCJ3ZWJwYWNrOi8vLy4uLy4uL3N0cmVhbXMvc3RyZWFtLWRhdGEudHM/NjczMCIsIndlYnBhY2s6Ly8vLi4vLi4vc3RyZWFtcy9vcGVuYWktc3RyZWFtLnRzP2IyYmQiLCJ3ZWJwYWNrOi8vLy4uL2NvbnN0YW50cy50cz9hYjcyIiwid2VicGFjazovLy8uLi9zdHJlYW0tdWkvc3RyZWFtLXVpLnRzeD8xY2NhIiwid2VicGFjazovLy8uLi9wcm92aWRlci50c3g/MzBlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ2FzeW5jX2hvb2tzJztcbmltcG9ydCAqIGFzIGpzb25kaWZmcGF0Y2ggZnJvbSAnanNvbmRpZmZwYXRjaCc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSwgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHR5cGUge1xuICBBSVByb3ZpZGVyLFxuICBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbiAgSW5mZXJBSVN0YXRlLFxuICBNdXRhYmxlQUlTdGF0ZSxcbiAgVmFsdWVPclVwZGF0ZXIsXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBJdCBpcyBwb3NzaWJsZSB0aGF0IG11bHRpcGxlIEFJIHJlcXVlc3RzIGdldCBpbiBjb25jdXJyZW50bHksIGZvciBkaWZmZXJlbnRcbi8vIEFJIGluc3RhbmNlcy4gU28gQUxTIGlzIG5lY2Vzc2FyeSBoZXJlIGZvciBhIHNpbXBsZXIgQVBJLlxuY29uc3QgYXN5bmNBSVN0YXRlU3RvcmFnZSA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZTx7XG4gIGN1cnJlbnRTdGF0ZTogYW55O1xuICBvcmlnaW5hbFN0YXRlOiBhbnk7XG4gIHNlYWxlZDogYm9vbGVhbjtcbiAgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnM7XG4gIG11dGF0aW9uRGVsdGFQcm9taXNlPzogUHJvbWlzZTxhbnk+O1xuICBtdXRhdGlvbkRlbHRhUmVzb2x2ZT86ICh2OiBhbnkpID0+IHZvaWQ7XG59PigpO1xuXG5mdW5jdGlvbiBnZXRBSVN0YXRlU3RvcmVPclRocm93KG1lc3NhZ2U6IHN0cmluZykge1xuICBjb25zdCBzdG9yZSA9IGFzeW5jQUlTdGF0ZVN0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgaWYgKCFzdG9yZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gc3RvcmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoQUlTdGF0ZTxTLCBUPihcbiAgeyBzdGF0ZSwgb3B0aW9ucyB9OiB7IHN0YXRlOiBTOyBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyB9LFxuICBmbjogKCkgPT4gVCxcbik6IFQge1xuICByZXR1cm4gYXN5bmNBSVN0YXRlU3RvcmFnZS5ydW4oXG4gICAge1xuICAgICAgY3VycmVudFN0YXRlOiBzdGF0ZSxcbiAgICAgIG9yaWdpbmFsU3RhdGU6IHN0YXRlLFxuICAgICAgc2VhbGVkOiBmYWxzZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgfSxcbiAgICBmbixcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFJU3RhdGVEZWx0YVByb21pc2UoKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdygnSW50ZXJuYWwgZXJyb3Igb2NjdXJyZWQuJyk7XG4gIHJldHVybiBzdG9yZS5tdXRhdGlvbkRlbHRhUHJvbWlzZTtcbn1cblxuLy8gSW50ZXJuYWwgbWV0aG9kLiBUaGlzIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBBSSBBY3Rpb24gaGFzIGJlZW4gcmV0dXJuZWRcbi8vIGFuZCB5b3UgY2FuIG5vIGxvbmdlciBjYWxsIGBnZXRNdXRhYmxlQUlTdGF0ZSgpYCBpbnNpZGUgYW55IGFzeW5jIGNhbGxiYWNrc1xuLy8gY3JlYXRlZCBieSB0aGF0IEFjdGlvbi5cbmV4cG9ydCBmdW5jdGlvbiBzZWFsTXV0YWJsZUFJU3RhdGUoKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdygnSW50ZXJuYWwgZXJyb3Igb2NjdXJyZWQuJyk7XG4gIHN0b3JlLnNlYWxlZCA9IHRydWU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IEFJIHN0YXRlLlxuICogSWYgYGtleWAgaXMgcHJvdmlkZWQsIGl0IHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGtleSBpbiB0aGVcbiAqIEFJIHN0YXRlLCBpZiBpdCdzIGFuIG9iamVjdC4gSWYgaXQncyBub3QgYW4gb2JqZWN0LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuICpcbiAqIEBleGFtcGxlIGNvbnN0IHN0YXRlID0gZ2V0QUlTdGF0ZSgpIC8vIEdldCB0aGUgZW50aXJlIEFJIHN0YXRlXG4gKiBAZXhhbXBsZSBjb25zdCBmaWVsZCA9IGdldEFJU3RhdGUoJ2tleScpIC8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGtleVxuICovXG5mdW5jdGlvbiBnZXRBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKTogSW5mZXJBSVN0YXRlPEFJLCBhbnk+O1xuZnVuY3Rpb24gZ2V0QUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XTtcbmZ1bmN0aW9uIGdldEFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAgLi4uYXJnczogW10gfCBba2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT5dXG4pIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KFxuICAgICdgZ2V0QUlTdGF0ZWAgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGFuIEFJIEFjdGlvbi4nLFxuICApO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbid0IGdldCB0aGUgXCIke1N0cmluZyhcbiAgICAgICAgICBrZXksXG4gICAgICAgICl9XCIgZmllbGQgZnJvbSB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGVba2V5IGFzIGtleW9mIHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGVdO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG11dGFibGUgQUkgc3RhdGUuIE5vdGUgdGhhdCB5b3UgbXVzdCBjYWxsIGAuY2xvc2UoKWAgd2hlbiBmaW5pc2hpbmdcbiAqIHVwZGF0aW5nIHRoZSBBSSBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCBzdGF0ZSA9IGdldE11dGFibGVBSVN0YXRlKClcbiAqIHN0YXRlLnVwZGF0ZSh7IC4uLnN0YXRlLmdldCgpLCBrZXk6ICd2YWx1ZScgfSlcbiAqIHN0YXRlLnVwZGF0ZSgoY3VycmVudFN0YXRlKSA9PiAoeyAuLi5jdXJyZW50U3RhdGUsIGtleTogJ3ZhbHVlJyB9KSlcbiAqIHN0YXRlLmRvbmUoKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gKiBzdGF0ZS5kb25lKHsgLi4uc3RhdGUuZ2V0KCksIGtleTogJ3ZhbHVlJyB9KSAvLyBEb25lIHdpdGggYSBuZXcgc3RhdGVcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCk6IE11dGFibGVBSVN0YXRlPFxuICBJbmZlckFJU3RhdGU8QUksIGFueT5cbj47XG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICBrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pixcbik6IE11dGFibGVBSVN0YXRlPEluZmVyQUlTdGF0ZTxBSSwgYW55Plt0eXBlb2Yga2V5XT47XG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KFxuICAuLi5hcmdzOiBbXSB8IFtrZXk6IGtleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pl1cbikge1xuICB0eXBlIEFJU3RhdGUgPSBJbmZlckFJU3RhdGU8QUksIGFueT47XG4gIHR5cGUgQUlTdGF0ZVdpdGhLZXkgPSB0eXBlb2YgYXJncyBleHRlbmRzIFtrZXk6IGtleW9mIEFJU3RhdGVdXG4gICAgPyBBSVN0YXRlWyh0eXBlb2YgYXJncylbMF1dXG4gICAgOiBBSVN0YXRlO1xuICB0eXBlIE5ld1N0YXRlT3JVcGRhdGVyID0gVmFsdWVPclVwZGF0ZXI8QUlTdGF0ZVdpdGhLZXk+O1xuXG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcbiAgICAnYGdldE11dGFibGVBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYW4gQUkgQWN0aW9uLicsXG4gICk7XG5cbiAgaWYgKHN0b3JlLnNlYWxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYGdldE11dGFibGVBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gYW4gQUkgQWN0aW9uLiBQbGVhc2UgbW92ZSBpdCB0byB0aGUgdG9wIGxldmVsIG9mIHRoZSBBY3Rpb24ncyBmdW5jdGlvbiBib2R5LlwiLFxuICAgICk7XG4gIH1cblxuICBpZiAoIXN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlKSB7XG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlID0gcHJvbWlzZTtcbiAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUmVzb2x2ZSA9IHJlc29sdmU7XG4gIH1cblxuICBmdW5jdGlvbiBkb1VwZGF0ZShuZXdTdGF0ZTogTmV3U3RhdGVPclVwZGF0ZXIsIGRvbmU6IGJvb2xlYW4pIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgY2FuJ3QgbW9kaWZ5IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICl9XCIgZmllbGQgb2YgdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24obmV3U3RhdGUpKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSA9IG5ld1N0YXRlKHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZShzdG9yZS5jdXJyZW50U3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSA9IG5ld1N0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RvcmUub3B0aW9ucy5vblNldEFJU3RhdGU/Lih7XG4gICAgICBrZXk6IGFyZ3MubGVuZ3RoID4gMCA/IGFyZ3NbMF0gOiB1bmRlZmluZWQsXG4gICAgICBzdGF0ZTogc3RvcmUuY3VycmVudFN0YXRlLFxuICAgICAgZG9uZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG11dGFibGVTdGF0ZSA9IHtcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFlvdSBjYW4ndCBnZXQgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICl9XCIgZmllbGQgZnJvbSB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGVba2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZSBhcyBBSVN0YXRlO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUobmV3QUlTdGF0ZTogTmV3U3RhdGVPclVwZGF0ZXIpIHtcbiAgICAgIGRvVXBkYXRlKG5ld0FJU3RhdGUsIGZhbHNlKTtcbiAgICB9LFxuICAgIGRvbmU6IGZ1bmN0aW9uIGRvbmUoLi4uZG9uZUFyZ3M6IFtdIHwgW05ld1N0YXRlT3JVcGRhdGVyXSkge1xuICAgICAgaWYgKGRvbmVBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZG9VcGRhdGUoZG9uZUFyZ3NbMF0gYXMgTmV3U3RhdGVPclVwZGF0ZXIsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWx0YSA9IGpzb25kaWZmcGF0Y2guZGlmZihzdG9yZS5vcmlnaW5hbFN0YXRlLCBzdG9yZS5jdXJyZW50U3RhdGUpO1xuICAgICAgc3RvcmUubXV0YXRpb25EZWx0YVJlc29sdmUhKGRlbHRhKTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBtdXRhYmxlU3RhdGU7XG59XG5cbmV4cG9ydCB7IGdldEFJU3RhdGUsIGdldE11dGFibGVBSVN0YXRlIH07XG4iLCJpbXBvcnQgUmVhY3QsIHsgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTxUID0gYW55PigpIHtcbiAgbGV0IHJlc29sdmU6ICh2YWx1ZTogVCkgPT4gdm9pZCwgcmVqZWN0OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWQ7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlOiByZXNvbHZlISxcbiAgICByZWplY3Q6IHJlamVjdCEsXG4gIH07XG59XG5cbi8vIFVzZSB0aGUgbmFtZSBgUmAgZm9yIGBSb3dgIGFzIGl0IHdpbGwgYmUgc2hvcnRlciBpbiB0aGUgUlNDIHBheWxvYWQuXG5jb25zdCBSID0gW1xuICAoYXN5bmMgKHtcbiAgICBjLCAvLyBjdXJyZW50XG4gICAgbiwgLy8gbmV4dFxuICB9OiB7XG4gICAgYzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG46IFByb21pc2U8YW55PjtcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGNodW5rID0gYXdhaXQgbjtcbiAgICBpZiAoY2h1bmsuZG9uZSkge1xuICAgICAgcmV0dXJuIGNodW5rLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChjaHVuay5hcHBlbmQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAge2N9XG4gICAgICAgICAgPFN1c3BlbnNlIGZhbGxiYWNrPXtjaHVuay52YWx1ZX0+XG4gICAgICAgICAgICA8UiBjPXtjaHVuay52YWx1ZX0gbj17Y2h1bmsubmV4dH0gLz5cbiAgICAgICAgICA8L1N1c3BlbnNlPlxuICAgICAgICA8Lz5cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17Y2h1bmsudmFsdWV9PlxuICAgICAgICA8UiBjPXtjaHVuay52YWx1ZX0gbj17Y2h1bmsubmV4dH0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgKTtcbiAgfSkgYXMgdW5rbm93biBhcyBSZWFjdC5GQzx7XG4gICAgYzogUmVhY3QuUmVhY3ROb2RlO1xuICAgIG46IFByb21pc2U8YW55PjtcbiAgfT4sXG5dWzBdO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VkQ2h1bmsoaW5pdGlhbFZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgcmV0dXJuIHtcbiAgICByb3c6IChcbiAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17aW5pdGlhbFZhbHVlfT5cbiAgICAgICAgPFIgYz17aW5pdGlhbFZhbHVlfSBuPXtwcm9taXNlfSAvPlxuICAgICAgPC9TdXNwZW5zZT5cbiAgICApLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0LFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9ICh4OiB1bmtub3duKTogeCBpcyBGdW5jdGlvbiA9PlxuICB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcblxuZXhwb3J0IGNvbnN0IGNvbnN1bWVTdHJlYW0gPSBhc3luYyAoc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSkgPT4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSBicmVhaztcbiAgfVxufTtcbiIsImltcG9ydCB0eXBlIHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHR5cGUgT3BlbkFJIGZyb20gJ29wZW5haSc7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB6b2RUb0pzb25TY2hlbWEgZnJvbSAnem9kLXRvLWpzb24tc2NoZW1hJztcblxuLy8gVE9ETzogVGhpcyBuZWVkcyB0byBiZSBleHRlcm5hbGl6ZWQuXG5pbXBvcnQgeyBPcGVuQUlTdHJlYW0gfSBmcm9tICcuLi9zdHJlYW1zJztcblxuaW1wb3J0IHtcbiAgU1RSRUFNQUJMRV9WQUxVRV9UWVBFLFxuICBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UsXG4gIGNyZWF0ZVN1c3BlbnNlZENodW5rLFxuICBjb25zdW1lU3RyZWFtLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgU3RyZWFtYWJsZVBhdGNoLCBTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBDcmVhdGUgYSBwaWVjZSBvZiBjaGFuZ2FibGUgVUkgdGhhdCBjYW4gYmUgc3RyZWFtZWQgdG8gdGhlIGNsaWVudC5cbiAqIE9uIHRoZSBjbGllbnQgc2lkZSwgaXQgY2FuIGJlIHJlbmRlcmVkIGFzIGEgbm9ybWFsIFJlYWN0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVVSShpbml0aWFsVmFsdWU/OiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICBsZXQgeyByb3csIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlU3VzcGVuc2VkQ2h1bmsoaW5pdGlhbFZhbHVlKTtcblxuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJzogVUkgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgfVxuXG4gIGxldCB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgc3RyZWFtYWJsZSBVSSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLicsXG4gICAgICAgICk7XG4gICAgICB9LCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSk7XG4gICAgfVxuICB9XG4gIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlIFVJLiBUaGlzIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgU2VydmVyIEFjdGlvbiBhbmQgcmVjZWl2ZWQgYnkgdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICB2YWx1ZTogcm93LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGN1cnJlbnQgVUkgbm9kZS4gSXQgdGFrZXMgYSBuZXcgVUkgbm9kZSBhbmQgcmVwbGFjZXMgdGhlIG9sZCBvbmUuXG4gICAgICovXG4gICAgdXBkYXRlKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLnVwZGF0ZSgpJyk7XG5cbiAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdXBkYXRlIHRoZSB2YWx1ZSBpZiBpdCdzIHJlZmVyZW50aWFsbHkgZXF1YWwuXG4gICAgICBpZiAodmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICByZXNvbHZlKHsgdmFsdWU6IGN1cnJlbnRWYWx1ZSwgZG9uZTogZmFsc2UsIG5leHQ6IHJlc29sdmFibGUucHJvbWlzZSB9KTtcbiAgICAgIHJlc29sdmUgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZWplY3QgPSByZXNvbHZhYmxlLnJlamVjdDtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGFwcGVuZCBhIG5ldyBVSSBub2RlIHRvIHRoZSBlbmQgb2YgdGhlIG9sZCBvbmUuXG4gICAgICogT25jZSBhcHBlbmRlZCBhIG5ldyBVSSBub2RlLCB0aGUgcHJldmlvdXMgVUkgbm9kZSBjYW5ub3QgYmUgdXBkYXRlZCBhbnltb3JlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc3hcbiAgICAgKiBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSSg8ZGl2PmhlbGxvPC9kaXY+KVxuICAgICAqIHVpLmFwcGVuZCg8ZGl2PndvcmxkPC9kaXY+KVxuICAgICAqXG4gICAgICogLy8gVGhlIFVJIG5vZGUgd2lsbCBiZTpcbiAgICAgKiAvLyA8PlxuICAgICAqIC8vICAgPGRpdj5oZWxsbzwvZGl2PlxuICAgICAqIC8vICAgPGRpdj53b3JsZDwvZGl2PlxuICAgICAqIC8vIDwvPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFwcGVuZCh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5hcHBlbmQoKScpO1xuXG4gICAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICByZXNvbHZlKHsgdmFsdWUsIGRvbmU6IGZhbHNlLCBhcHBlbmQ6IHRydWUsIG5leHQ6IHJlc29sdmFibGUucHJvbWlzZSB9KTtcbiAgICAgIHJlc29sdmUgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZWplY3QgPSByZXNvbHZhYmxlLnJlamVjdDtcblxuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNpZ25hbCB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSBVSSBzdHJlYW0uXG4gICAgICogSXQgd2lsbCBiZSB0aHJvd24gb24gdGhlIGNsaWVudCBzaWRlIGFuZCBjYXVnaHQgYnkgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmVycm9yKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSBVSSBub2RlIGFzIGZpbmFsaXplZC4gWW91IGNhbiBlaXRoZXIgY2FsbCBpdCB3aXRob3V0IGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgVUkgbm9kZSBhcyB0aGUgZmluYWwgc3RhdGUuXG4gICAgICogT25jZSBjYWxsZWQsIHRoZSBVSSBub2RlIGNhbm5vdCBiZSB1cGRhdGVkIG9yIGFwcGVuZGVkIGFueW1vcmUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhbHdheXMgKipyZXF1aXJlZCoqIHRvIGJlIGNhbGxlZCwgb3RoZXJ3aXNlIHRoZSByZXNwb25zZSB3aWxsIGJlIHN0dWNrIGluIGEgbG9hZGluZyBzdGF0ZS5cbiAgICAgKi9cbiAgICBkb25lKC4uLmFyZ3M6IFtdIHwgW1JlYWN0LlJlYWN0Tm9kZV0pIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmRvbmUoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBhcmdzWzBdLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKHsgdmFsdWU6IGN1cnJlbnRWYWx1ZSwgZG9uZTogdHJ1ZSB9KTtcbiAgICB9LFxuICB9O1xufVxuXG5jb25zdCBTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0sgPSBTeW1ib2woJ3N0cmVhbWFibGUudmFsdWUubG9jaycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHdyYXBwZWQsIGNoYW5nYWJsZSB2YWx1ZSB0aGF0IGNhbiBiZSBzdHJlYW1lZCB0byB0aGUgY2xpZW50LlxuICogT24gdGhlIGNsaWVudCBzaWRlLCB0aGUgdmFsdWUgY2FuIGJlIGFjY2Vzc2VkIHZpYSB0aGUgcmVhZFN0cmVhbWFibGVWYWx1ZSgpIEFQSS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtYWJsZVZhbHVlPFQgPSBhbnksIEUgPSBhbnk+KFxuICBpbml0aWFsVmFsdWU/OiBUIHwgUmVhZGFibGVTdHJlYW08VD4sXG4pIHtcbiAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9XG4gICAgaW5pdGlhbFZhbHVlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHxcbiAgICAodHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIGluaXRpYWxWYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgJ2dldFJlYWRlcicgaW4gaW5pdGlhbFZhbHVlICYmXG4gICAgICB0eXBlb2YgaW5pdGlhbFZhbHVlLmdldFJlYWRlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgJ2xvY2tlZCcgaW4gaW5pdGlhbFZhbHVlICYmXG4gICAgICB0eXBlb2YgaW5pdGlhbFZhbHVlLmxvY2tlZCA9PT0gJ2Jvb2xlYW4nKTtcblxuICBpZiAoIWlzUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbDxULCBFPihpbml0aWFsVmFsdWUpO1xuICB9XG5cbiAgY29uc3Qgc3RyZWFtYWJsZVZhbHVlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlSW1wbDxULCBFPigpO1xuXG4gIC8vIFNpbmNlIHRoZSBzdHJlYW1hYmxlIHZhbHVlIHdpbGwgYmUgZnJvbSBhIHJlYWRhYmxlIHN0cmVhbSwgaXQncyBub3QgYWxsb3dlZFxuICAvLyB0byB1cGRhdGUgdGhlIHZhbHVlIG1hbnVhbGx5IGFzIHRoYXQgaW50cm9kdWNlcyByYWNlIGNvbmRpdGlvbnMgYW5kXG4gIC8vIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG4gIC8vIFdlIGxvY2sgdGhlIHZhbHVlIHRvIHByZXZlbnQgYW55IHVwZGF0ZXMgZnJvbSB0aGUgdXNlci5cbiAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSB0cnVlO1xuXG4gIChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnN1bWUgdGhlIHJlYWRhYmxlIHN0cmVhbSBhbmQgdXBkYXRlIHRoZSB2YWx1ZS5cbiAgICAgIGNvbnN0IHJlYWRlciA9IGluaXRpYWxWYWx1ZS5nZXRSZWFkZXIoKTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVubG9jayB0aGUgdmFsdWUgdG8gYWxsb3cgdXBkYXRlcy5cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVmFsdWUuYXBwZW5kKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVmFsdWUudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2NrIHRoZSB2YWx1ZSBhZ2Fpbi5cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgc3RyZWFtYWJsZVZhbHVlLmRvbmUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgc3RyZWFtYWJsZVZhbHVlLmVycm9yKGUpO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4gc3RyZWFtYWJsZVZhbHVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQgPSBhbnksIEUgPSBhbnk+KGluaXRpYWxWYWx1ZT86IFQpIHtcbiAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICBsZXQgbG9ja2VkID0gZmFsc2U7XG4gIGxldCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PigpO1xuXG4gIGxldCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGxldCBjdXJyZW50RXJyb3I6IEUgfCB1bmRlZmluZWQ7XG4gIGxldCBjdXJyZW50UHJvbWlzZTogdHlwZW9mIHJlc29sdmFibGUucHJvbWlzZSB8IHVuZGVmaW5lZCA9XG4gICAgcmVzb2x2YWJsZS5wcm9taXNlO1xuICBsZXQgY3VycmVudFBhdGNoVmFsdWU6IFN0cmVhbWFibGVQYXRjaDtcblxuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJzogVmFsdWUgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgICBpZiAobG9ja2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIG1ldGhvZCArICc6IFZhbHVlIHN0cmVhbSBpcyBsb2NrZWQgYW5kIGNhbm5vdCBiZSB1cGRhdGVkLicsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGxldCB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgc3RyZWFtYWJsZSBVSSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLicsXG4gICAgICAgICk7XG4gICAgICB9LCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSk7XG4gICAgfVxuICB9XG4gIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZWQoaW5pdGlhbENodW5rPzogYm9vbGVhbik6IFN0cmVhbWFibGVWYWx1ZTxULCBFPiB7XG4gICAgLy8gVGhpcyBtYWtlcyB0aGUgcGF5bG9hZCBtdWNoIHNtYWxsZXIgaWYgdGhlcmUncmUgbXV0YXRpdmUgdXBkYXRlcyBiZWZvcmUgdGhlIGZpcnN0IHJlYWQuXG4gICAgbGV0IGluaXQ6IFBhcnRpYWw8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PjtcblxuICAgIGlmIChjdXJyZW50RXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5pdCA9IHsgZXJyb3I6IGN1cnJlbnRFcnJvciB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VycmVudFBhdGNoVmFsdWUgJiYgIWluaXRpYWxDaHVuaykge1xuICAgICAgICBpbml0ID0geyBkaWZmOiBjdXJyZW50UGF0Y2hWYWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdCA9IHsgY3VycjogY3VycmVudFZhbHVlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9taXNlKSB7XG4gICAgICBpbml0Lm5leHQgPSBjdXJyZW50UHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbENodW5rKSB7XG4gICAgICBpbml0LnR5cGUgPSBTVFJFQU1BQkxFX1ZBTFVFX1RZUEU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGBjdXJyZW50VmFsdWVgIGFuZCBgY3VycmVudFBhdGNoVmFsdWVgIGlmIG5lZWRlZC5cbiAgZnVuY3Rpb24gdXBkYXRlVmFsdWVTdGF0ZXModmFsdWU6IFQpIHtcbiAgICAvLyBJZiB3ZSBjYW4gb25seSBzZW5kIGEgcGF0Y2ggb3ZlciB0aGUgd2lyZSwgaXQncyBiZXR0ZXIgdG8gZG8gc28uXG4gICAgY3VycmVudFBhdGNoVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSBbMCwgdmFsdWUuc2xpY2UoY3VycmVudFZhbHVlLmxlbmd0aCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCBUaGlzIGlzIGFuIGludGVybmFsIGxvY2sgdG8gcHJldmVudCB0aGUgdmFsdWUgZnJvbSBiZWluZ1xuICAgICAqIHVwZGF0ZWQgYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgc2V0IFtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdKHN0YXRlOiBib29sZWFuKSB7XG4gICAgICBsb2NrZWQgPSBzdGF0ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgc3RyZWFtYWJsZS4gVGhpcyBjYW4gYmUgcmV0dXJuZWQgZnJvbSBhIFNlcnZlciBBY3Rpb24gYW5kXG4gICAgICogcmVjZWl2ZWQgYnkgdGhlIGNsaWVudC4gVG8gcmVhZCB0aGUgc3RyZWFtZWQgdmFsdWVzLCB1c2UgdGhlXG4gICAgICogYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgIEFQSXMuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZWQodHJ1ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBjdXJyZW50IHZhbHVlIHdpdGggYSBuZXcgb25lLlxuICAgICAqL1xuICAgIHVwZGF0ZSh2YWx1ZTogVCkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcudXBkYXRlKCknKTtcblxuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgICAgIHVwZGF0ZVZhbHVlU3RhdGVzKHZhbHVlKTtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgICAgcmVzb2x2ZVByZXZpb3VzKGNyZWF0ZVdyYXBwZWQoKSk7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhcHBlbmQgYSBkZWx0YSBzdHJpbmcgdG8gdGhlIGN1cnJlbnQgdmFsdWUuIEl0XG4gICAgICogcmVxdWlyZXMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUgdG8gYmUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzeFxuICAgICAqIGNvbnN0IHN0cmVhbWFibGUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoJ2hlbGxvJyk7XG4gICAgICogc3RyZWFtYWJsZS5hcHBlbmQoJyB3b3JsZCcpO1xuICAgICAqXG4gICAgICogLy8gVGhlIHZhbHVlIHdpbGwgYmUgJ2hlbGxvIHdvcmxkJ1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFwcGVuZCh2YWx1ZTogVCkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuYXBwZW5kKCknKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgLmFwcGVuZCgpOiBUaGUgY3VycmVudCB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuIFJlY2VpdmVkOiAke3R5cGVvZiBjdXJyZW50VmFsdWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgLmFwcGVuZCgpOiBUaGUgdmFsdWUgaXMgbm90IGEgc3RyaW5nLiBSZWNlaXZlZDogJHt0eXBlb2YgdmFsdWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IFswLCB2YWx1ZV07XG4gICAgICAgIChjdXJyZW50VmFsdWUgYXMgc3RyaW5nKSA9IGN1cnJlbnRWYWx1ZSArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICAgIHJlc29sdmVQcmV2aW91cyhjcmVhdGVXcmFwcGVkKCkpO1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2lnbmFsIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIHZhbHVlIHN0cmVhbS5cbiAgICAgKiBJdCB3aWxsIGJlIHRocm93biBvbiB0aGUgY2xpZW50IHNpZGUgd2hlbiBjb25zdW1lZCB2aWFcbiAgICAgKiBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgb3IgYHVzZVN0cmVhbWFibGVWYWx1ZWAuXG4gICAgICovXG4gICAgZXJyb3IoZXJyb3I6IGFueSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZXJyb3IoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBjdXJyZW50RXJyb3IgPSBlcnJvcjtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gdW5kZWZpbmVkO1xuXG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUoeyBlcnJvciB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSB2YWx1ZSBhcyBmaW5hbGl6ZWQuIFlvdSBjYW4gZWl0aGVyIGNhbGwgaXQgd2l0aG91dFxuICAgICAqIGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgdmFsdWUgYXMgdGhlIGZpbmFsIHN0YXRlLlxuICAgICAqIE9uY2UgY2FsbGVkLCB0aGUgdmFsdWUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsd2F5cyAqKnJlcXVpcmVkKiogdG8gYmUgY2FsbGVkLCBvdGhlcndpc2UgdGhlIHJlc3BvbnNlXG4gICAgICogd2lsbCBiZSBzdHVjayBpbiBhIGxvYWRpbmcgc3RhdGUuXG4gICAgICovXG4gICAgZG9uZSguLi5hcmdzOiBbXSB8IFtUXSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuZG9uZSgpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdXBkYXRlVmFsdWVTdGF0ZXMoYXJnc1swXSk7XG4gICAgICAgIHJlc29sdmFibGUucmVzb2x2ZShjcmVhdGVXcmFwcGVkKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh7fSk7XG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVVJLCBjcmVhdGVTdHJlYW1hYmxlVmFsdWUgfTtcblxudHlwZSBTdHJlYW1hYmxlID0gUmVhY3ROb2RlIHwgUHJvbWlzZTxSZWFjdE5vZGU+O1xudHlwZSBSZW5kZXJlcjxUPiA9IChcbiAgcHJvcHM6IFQsXG4pID0+XG4gIHwgU3RyZWFtYWJsZVxuICB8IEdlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPlxuICB8IEFzeW5jR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+O1xuXG4vKipcbiAqIGByZW5kZXJgIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0cmVhbWFibGUgVUkgZnJvbSBzb21lIExMTXMuXG4gKiBUaGlzIEFQSSBvbmx5IHN1cHBvcnRzIE9wZW5BSSdzIEdQVCBtb2RlbHMgd2l0aCBGdW5jdGlvbiBDYWxsaW5nIGFuZCBBc3Npc3RhbnRzIFRvb2xzLFxuICogcGxlYXNlIHVzZSBgc3RyZWFtVUlgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggb3RoZXIgcHJvdmlkZXJzLlxuICpcbiAqIEBkZXByZWNhdGVkIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBgc3RyZWFtVUlgIEFQSSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFJIFNESyBDb3JlIEFQSXNcbiAqIGFuZCBmdXR1cmUgZmVhdHVyZXMuIFRoaXMgQVBJIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyPFxuICBUUyBleHRlbmRzIHtcbiAgICBbbmFtZTogc3RyaW5nXTogei5TY2hlbWE7XG4gIH0gPSB7fSxcbiAgRlMgZXh0ZW5kcyB7XG4gICAgW25hbWU6IHN0cmluZ106IHouU2NoZW1hO1xuICB9ID0ge30sXG4+KG9wdGlvbnM6IHtcbiAgLyoqXG4gICAqIFRoZSBtb2RlbCBuYW1lIHRvIHVzZS4gTXVzdCBiZSBPcGVuQUkgU0RLIGNvbXBhdGlibGUuIFRvb2xzIGFuZCBGdW5jdGlvbnMgYXJlIG9ubHkgc3VwcG9ydGVkXG4gICAqIEdQVCBtb2RlbHMgKDMuNS80KSwgT3BlbkFJIEFzc2lzdGFudHMsIE1pc3RyYWwgc21hbGwgYW5kIGxhcmdlLCBhbmQgRmlyZXdvcmtzIGZpcmVmdW5jdGlvbi12MS5cbiAgICpcbiAgICogQGV4YW1wbGUgXCJncHQtMy41LXR1cmJvXCJcbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcHJvdmlkZXIgaW5zdGFuY2UgdG8gdXNlLiBDdXJyZW50bHkgdGhlIG9ubHkgcHJvdmlkZXIgYXZhaWxhYmxlIGlzIE9wZW5BSS5cbiAgICogVGhpcyBuZWVkcyB0byBtYXRjaCB0aGUgbW9kZWwgbmFtZS5cbiAgICovXG4gIHByb3ZpZGVyOiBPcGVuQUk7XG4gIG1lc3NhZ2VzOiBQYXJhbWV0ZXJzPFxuICAgIHR5cGVvZiBPcGVuQUkucHJvdG90eXBlLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlXG4gID5bMF1bJ21lc3NhZ2VzJ107XG4gIHRleHQ/OiBSZW5kZXJlcjx7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bGwgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNvIGZhci5cbiAgICAgKi9cbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIG5ldyBhcHBlbmRlZCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc2luY2UgdGhlIGxhc3QgYHRleHRgIGNhbGwuXG4gICAgICovXG4gICAgZGVsdGE6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBpcyBkb25lIGdlbmVyYXRpbmcgdGV4dC5cbiAgICAgKiBJZiBgdHJ1ZWAsIHRoZSBgY29udGVudGAgd2lsbCBiZSB0aGUgZmluYWwgb3V0cHV0IGFuZCB0aGlzIGNhbGwgd2lsbCBiZSB0aGUgbGFzdC5cbiAgICAgKi9cbiAgICBkb25lOiBib29sZWFuO1xuICB9PjtcbiAgdG9vbHM/OiB7XG4gICAgW25hbWUgaW4ga2V5b2YgVFNdOiB7XG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICAgIHBhcmFtZXRlcnM6IFRTW25hbWVdO1xuICAgICAgcmVuZGVyOiBSZW5kZXJlcjx6LmluZmVyPFRTW25hbWVdPj47XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb25zPzoge1xuICAgIFtuYW1lIGluIGtleW9mIEZTXToge1xuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgICBwYXJhbWV0ZXJzOiBGU1tuYW1lXTtcbiAgICAgIHJlbmRlcjogUmVuZGVyZXI8ei5pbmZlcjxGU1tuYW1lXT4+O1xuICAgIH07XG4gIH07XG4gIGluaXRpYWw/OiBSZWFjdE5vZGU7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xufSk6IFJlYWN0Tm9kZSB7XG4gIGNvbnN0IHVpID0gY3JlYXRlU3RyZWFtYWJsZVVJKG9wdGlvbnMuaW5pdGlhbCk7XG5cbiAgLy8gVGhlIGRlZmF1bHQgdGV4dCByZW5kZXJlciBqdXN0IHJldHVybnMgdGhlIGNvbnRlbnQgYXMgc3RyaW5nLlxuICBjb25zdCB0ZXh0ID0gb3B0aW9ucy50ZXh0XG4gICAgPyBvcHRpb25zLnRleHRcbiAgICA6ICh7IGNvbnRlbnQgfTogeyBjb250ZW50OiBzdHJpbmcgfSkgPT4gY29udGVudDtcblxuICBjb25zdCBmdW5jdGlvbnMgPSBvcHRpb25zLmZ1bmN0aW9uc1xuICAgID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy5mdW5jdGlvbnMpLm1hcChcbiAgICAgICAgKFtuYW1lLCB7IGRlc2NyaXB0aW9uLCBwYXJhbWV0ZXJzIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHpvZFRvSnNvblNjaGVtYShwYXJhbWV0ZXJzKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHRvb2xzID0gb3B0aW9ucy50b29sc1xuICAgID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy50b29scykubWFwKFxuICAgICAgICAoW25hbWUsIHsgZGVzY3JpcHRpb24sIHBhcmFtZXRlcnMgfV0pID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyBhcyBjb25zdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB6b2RUb0pzb25TY2hlbWEocGFyYW1ldGVycykgYXMgUmVjb3JkPFxuICAgICAgICAgICAgICAgIHN0cmluZyxcbiAgICAgICAgICAgICAgICB1bmtub3duXG4gICAgICAgICAgICAgID4sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICApXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGZ1bmN0aW9ucyAmJiB0b29scykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbid0IGhhdmUgYm90aCBmdW5jdGlvbnMgYW5kIHRvb2xzIGRlZmluZWQuIFBsZWFzZSBjaG9vc2Ugb25lIG9yIHRoZSBvdGhlci5cIixcbiAgICApO1xuICB9XG5cbiAgbGV0IGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlbmRlcihcbiAgICBhcmdzOiBhbnksXG4gICAgcmVuZGVyZXI6IHVuZGVmaW5lZCB8IFJlbmRlcmVyPGFueT4sXG4gICAgcmVzOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTdHJlYW1hYmxlVUk+LFxuICApIHtcbiAgICBpZiAoIXJlbmRlcmVyKSByZXR1cm47XG5cbiAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8dm9pZD4oKTtcblxuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgZmluaXNoZWQgPSBmaW5pc2hlZC50aGVuKCgpID0+IHJlc29sdmFibGUucHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaGVkID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gcmVuZGVyZXIoYXJncyk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlIHx8XG4gICAgICAodmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndGhlbicgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICBjb25zdCBub2RlID0gYXdhaXQgKHZhbHVlIGFzIFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPik7XG4gICAgICByZXMudXBkYXRlKG5vZGUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiB2YWx1ZVxuICAgICkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZSBhcyBBc3luY0dlbmVyYXRvcjxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICBSZWFjdC5SZWFjdE5vZGUsXG4gICAgICAgIHZvaWRcbiAgICAgID47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlIGFzIEdlbmVyYXRvcjxSZWFjdC5SZWFjdE5vZGUsIFJlYWN0LlJlYWN0Tm9kZSwgdm9pZD47XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9XG4gIH1cblxuICAoYXN5bmMgKCkgPT4ge1xuICAgIGxldCBoYXNGdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50ID0gJyc7XG5cbiAgICBjb25zdW1lU3RyZWFtKFxuICAgICAgT3BlbkFJU3RyZWFtKFxuICAgICAgICAoYXdhaXQgb3B0aW9ucy5wcm92aWRlci5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICAgICAgbW9kZWw6IG9wdGlvbnMubW9kZWwsXG4gICAgICAgICAgbWVzc2FnZXM6IG9wdGlvbnMubWVzc2FnZXMsXG4gICAgICAgICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMudGVtcGVyYXR1cmUsXG4gICAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAgIC4uLihmdW5jdGlvbnNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgLi4uKHRvb2xzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pKSBhcyBhbnksXG4gICAgICAgIHtcbiAgICAgICAgICAuLi4oZnVuY3Rpb25zXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZnVuY3Rpb25DYWxsUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgaGFzRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxQYXlsb2FkLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5mdW5jdGlvbnM/LltmdW5jdGlvbkNhbGxQYXlsb2FkLm5hbWUgYXMgYW55XVxuICAgICAgICAgICAgICAgICAgICAgID8ucmVuZGVyLFxuICAgICAgICAgICAgICAgICAgICB1aSxcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgLi4uKHRvb2xzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25Ub29sQ2FsbCh0b29sQ2FsbFBheWxvYWQ6IGFueSkge1xuICAgICAgICAgICAgICAgICAgaGFzRnVuY3Rpb24gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBtaWdodCBuZWVkIFByb21pc2UuYWxsIGhlcmU/XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbENhbGxQYXlsb2FkLnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgICAgICAgICB0b29sLmZ1bmMuYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudG9vbHM/Llt0b29sLmZ1bmMubmFtZSBhcyBhbnldPy5yZW5kZXIsXG4gICAgICAgICAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgb25UZXh0KGNodW5rKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IGNodW5rO1xuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKHsgY29udGVudCwgZG9uZTogZmFsc2UsIGRlbHRhOiBjaHVuayB9LCB0ZXh0LCB1aSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBvbkZpbmFsKCkge1xuICAgICAgICAgICAgaWYgKGhhc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKHsgY29udGVudCwgZG9uZTogdHJ1ZSB9LCB0ZXh0LCB1aSk7XG4gICAgICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgIHVpLmRvbmUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgKSxcbiAgICApO1xuICB9KSgpO1xuXG4gIHJldHVybiB1aS52YWx1ZTtcbn1cbiIsImNvbnN0IG1pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL2dpZicgYXMgY29uc3QsIGJ5dGVzOiBbMHg0NywgMHg0OSwgMHg0Nl0gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL3BuZycgYXMgY29uc3QsIGJ5dGVzOiBbMHg4OSwgMHg1MCwgMHg0ZSwgMHg0N10gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL2pwZWcnIGFzIGNvbnN0LCBieXRlczogWzB4ZmYsIDB4ZDhdIH0sXG4gIHsgbWltZVR5cGU6ICdpbWFnZS93ZWJwJyBhcyBjb25zdCwgYnl0ZXM6IFsweDUyLCAweDQ5LCAweDQ2LCAweDQ2XSB9LFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdEltYWdlTWltZVR5cGUoXG4gIGltYWdlOiBVaW50OEFycmF5LFxuKTogJ2ltYWdlL2pwZWcnIHwgJ2ltYWdlL3BuZycgfCAnaW1hZ2UvZ2lmJyB8ICdpbWFnZS93ZWJwJyB8IHVuZGVmaW5lZCB7XG4gIGZvciAoY29uc3QgeyBieXRlcywgbWltZVR5cGUgfSBvZiBtaW1lVHlwZVNpZ25hdHVyZXMpIHtcbiAgICBpZiAoXG4gICAgICBpbWFnZS5sZW5ndGggPj0gYnl0ZXMubGVuZ3RoICYmXG4gICAgICBieXRlcy5ldmVyeSgoYnl0ZSwgaW5kZXgpID0+IGltYWdlW2luZGV4XSA9PT0gYnl0ZSlcbiAgICApIHtcbiAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHsgSW52YWxpZERhdGFDb250ZW50RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXksXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQsXG59IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuXG4vKipcbkRhdGEgY29udGVudC4gQ2FuIGVpdGhlciBiZSBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZywgYSBVaW50OEFycmF5LCBhbiBBcnJheUJ1ZmZlciwgb3IgYSBCdWZmZXIuXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFDb250ZW50ID0gc3RyaW5nIHwgVWludDhBcnJheSB8IEFycmF5QnVmZmVyIHwgQnVmZmVyO1xuXG4vKipcbkNvbnZlcnRzIGRhdGEgY29udGVudCB0byBhIGJhc2U2NC1lbmNvZGVkIHN0cmluZy5cblxuQHBhcmFtIGNvbnRlbnQgLSBEYXRhIGNvbnRlbnQgdG8gY29udmVydC5cbkByZXR1cm5zIEJhc2U2NC1lbmNvZGVkIHN0cmluZy5cbiovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcoY29udGVudDogRGF0YUNvbnRlbnQpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoY29udGVudCk7XG59XG5cbi8qKlxuQ29udmVydHMgZGF0YSBjb250ZW50IHRvIGEgVWludDhBcnJheS5cblxuQHBhcmFtIGNvbnRlbnQgLSBEYXRhIGNvbnRlbnQgdG8gY29udmVydC5cbkByZXR1cm5zIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoXG4gIGNvbnRlbnQ6IERhdGFDb250ZW50LFxuKTogVWludDhBcnJheSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG5cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuXG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG4iLCJpbXBvcnQge1xuICBMYW5ndWFnZU1vZGVsVjFJbWFnZVBhcnQsXG4gIExhbmd1YWdlTW9kZWxWMU1lc3NhZ2UsXG4gIExhbmd1YWdlTW9kZWxWMVByb21wdCxcbiAgTGFuZ3VhZ2VNb2RlbFYxVGV4dFBhcnQsXG59IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgZGV0ZWN0SW1hZ2VNaW1lVHlwZSB9IGZyb20gJy4uL3V0aWwvZGV0ZWN0LWltYWdlLW1pbWV0eXBlJztcbmltcG9ydCB7IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheSB9IGZyb20gJy4vZGF0YS1jb250ZW50JztcbmltcG9ydCB7IFZhbGlkYXRlZFByb21wdCB9IGZyb20gJy4vZ2V0LXZhbGlkYXRlZC1wcm9tcHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdChcbiAgcHJvbXB0OiBWYWxpZGF0ZWRQcm9tcHQsXG4pOiBMYW5ndWFnZU1vZGVsVjFQcm9tcHQge1xuICBjb25zdCBsYW5ndWFnZU1vZGVsTWVzc2FnZXM6IExhbmd1YWdlTW9kZWxWMVByb21wdCA9IFtdO1xuXG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwpIHtcbiAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBwcm9tcHQuc3lzdGVtIH0pO1xuICB9XG5cbiAgc3dpdGNoIChwcm9tcHQudHlwZSkge1xuICAgIGNhc2UgJ3Byb21wdCc6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IHByb21wdC5wcm9tcHQgfV0sXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ21lc3NhZ2VzJzoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goXG4gICAgICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoKG1lc3NhZ2UpOiBMYW5ndWFnZU1vZGVsVjFNZXNzYWdlID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2Uucm9sZSkge1xuICAgICAgICAgICAgY2FzZSAnc3lzdGVtJzoge1xuICAgICAgICAgICAgICByZXR1cm4geyByb2xlOiAnc3lzdGVtJywgY29udGVudDogbWVzc2FnZS5jb250ZW50IH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3VzZXInOiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcChcbiAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICAgICk6IExhbmd1YWdlTW9kZWxWMVRleHRQYXJ0IHwgTGFuZ3VhZ2VNb2RlbFYxSW1hZ2VQYXJ0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5pbWFnZSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHBhcnQuaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVWludDggPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VVaW50OCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5taW1lVHlwZSA/PyBkZXRlY3RJbWFnZU1pbWVUeXBlKGltYWdlVWludDgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnYXNzaXN0YW50Jzoge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHsgcm9sZTogJ2Fzc2lzdGFudCcsIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlICd0b29sJzoge1xuICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2s6IG5ldmVyID0gcHJvbXB0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm9tcHQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYW5ndWFnZU1vZGVsTWVzc2FnZXM7XG59XG4iLCJpbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IENvcmVNZXNzYWdlIH0gZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7IFByb21wdCB9IGZyb20gJy4vcHJvbXB0JztcblxuZXhwb3J0IHR5cGUgVmFsaWRhdGVkUHJvbXB0ID1cbiAgfCB7XG4gICAgICB0eXBlOiAncHJvbXB0JztcbiAgICAgIHByb21wdDogc3RyaW5nO1xuICAgICAgbWVzc2FnZXM6IHVuZGVmaW5lZDtcbiAgICAgIHN5c3RlbT86IHN0cmluZztcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogJ21lc3NhZ2VzJztcbiAgICAgIHByb21wdDogdW5kZWZpbmVkO1xuICAgICAgbWVzc2FnZXM6IENvcmVNZXNzYWdlW107XG4gICAgICBzeXN0ZW0/OiBzdHJpbmc7XG4gICAgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkYXRlZFByb21wdChwcm9tcHQ6IFByb21wdCk6IFZhbGlkYXRlZFByb21wdCB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgb3IgbWVzc2FnZXMgbXVzdCBiZSBkZWZpbmVkJyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWUnLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHByb21wdC5wcm9tcHQgIT0gbnVsbFxuICAgID8ge1xuICAgICAgICB0eXBlOiAncHJvbXB0JyxcbiAgICAgICAgcHJvbXB0OiBwcm9tcHQucHJvbXB0LFxuICAgICAgICBtZXNzYWdlczogdW5kZWZpbmVkLFxuICAgICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW0sXG4gICAgICB9XG4gICAgOiB7XG4gICAgICAgIHR5cGU6ICdtZXNzYWdlcycsXG4gICAgICAgIHByb21wdDogdW5kZWZpbmVkLFxuICAgICAgICBtZXNzYWdlczogcHJvbXB0Lm1lc3NhZ2VzISwgLy8gb25seSBwb3NzaWJsZSBjYXNlIGJjIG9mIGNoZWNrcyBhYm92ZVxuICAgICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW0sXG4gICAgICB9O1xufVxuIiwiaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IENhbGxTZXR0aW5ncyB9IGZyb20gJy4vY2FsbC1zZXR0aW5ncyc7XG5cbi8qKlxuICogVmFsaWRhdGVzIGNhbGwgc2V0dGluZ3MgYW5kIHNldHMgZGVmYXVsdCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzZWVkLFxuICBtYXhSZXRyaWVzLFxufTogQ2FsbFNldHRpbmdzKTogQ2FsbFNldHRpbmdzIHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFRva2VucycsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXhUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhUb2tlbnMnLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiAnbWF4VG9rZW5zIG11c3QgYmUgPj0gMScsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICd0ZW1wZXJhdHVyZScsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogJ3RlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3RvcFAnLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogJ3RvcFAgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByZXNlbmNlUGVuYWx0eSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6ICdwcmVzZW5jZVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBmcmVxdWVuY3lQZW5hbHR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiAnZnJlcXVlbmN5UGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWVkICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VlZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3NlZWQnLFxuICAgICAgICB2YWx1ZTogc2VlZCxcbiAgICAgICAgbWVzc2FnZTogJ3NlZWQgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFJldHJpZXMnLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogJ21heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnbWF4UmV0cmllcycsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiAnbWF4UmV0cmllcyBtdXN0IGJlID49IDAnLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXhUb2tlbnMsXG4gICAgdGVtcGVyYXR1cmU6IHRlbXBlcmF0dXJlID8/IDAsXG4gICAgdG9wUCxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzZWVkLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXMgPz8gMixcbiAgfTtcbn1cbiIsImltcG9ydCB7IEpTT05TY2hlbWE3IH0gZnJvbSAnanNvbi1zY2hlbWEnO1xuaW1wb3J0ICogYXMgeiBmcm9tICd6b2QnO1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tICd6b2QtdG8tanNvbi1zY2hlbWEnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFpvZFRvSlNPTlNjaGVtYShcbiAgem9kU2NoZW1hOiB6LlNjaGVtYTx1bmtub3duPixcbik6IEpTT05TY2hlbWE3IHtcbiAgLy8gd2UgYXNzdW1lIHRoYXQgem9kVG9Kc29uU2NoZW1hIHdpbGwgcmV0dXJuIGEgdmFsaWQgSlNPTlNjaGVtYTdcbiAgcmV0dXJuIHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEpIGFzIEpTT05TY2hlbWE3O1xufVxuIiwiaW1wb3J0IHsgQVBJQ2FsbEVycm9yLCBSZXRyeUVycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UsIGlzQWJvcnRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuaW1wb3J0IHsgZGVsYXkgfSBmcm9tICcuL2RlbGF5JztcblxuZXhwb3J0IHR5cGUgUmV0cnlGdW5jdGlvbiA9IDxPVVRQVVQ+KFxuICBmbjogKCkgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPixcbikgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPjtcblxuLyoqXG5UaGUgYHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZmAgc3RyYXRlZ3kgcmV0cmllcyBhIGZhaWxlZCBBUEkgY2FsbCB3aXRoIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYuXG5Zb3UgY2FuIGNvbmZpZ3VyZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcywgdGhlIGluaXRpYWwgZGVsYXksIGFuZCB0aGUgYmFja29mZiBmYWN0b3IuXG4gKi9cbmV4cG9ydCBjb25zdCByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYgPVxuICAoe1xuICAgIG1heFJldHJpZXMgPSAyLFxuICAgIGluaXRpYWxEZWxheUluTXMgPSAyMDAwLFxuICAgIGJhY2tvZmZGYWN0b3IgPSAyLFxuICB9ID0ge30pOiBSZXRyeUZ1bmN0aW9uID0+XG4gIGFzeW5jIDxPVVRQVVQ+KGY6ICgpID0+IFByb21pc2VMaWtlPE9VVFBVVD4pID0+XG4gICAgX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gICAgICBtYXhSZXRyaWVzLFxuICAgICAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICAgICAgYmFja29mZkZhY3RvcixcbiAgICB9KTtcblxuYXN5bmMgZnVuY3Rpb24gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZjxPVVRQVVQ+KFxuICBmOiAoKSA9PiBQcm9taXNlTGlrZTxPVVRQVVQ+LFxuICB7XG4gICAgbWF4UmV0cmllcyxcbiAgICBkZWxheUluTXMsXG4gICAgYmFja29mZkZhY3RvcixcbiAgfTogeyBtYXhSZXRyaWVzOiBudW1iZXI7IGRlbGF5SW5NczogbnVtYmVyOyBiYWNrb2ZmRmFjdG9yOiBudW1iZXIgfSxcbiAgZXJyb3JzOiB1bmtub3duW10gPSBbXSxcbik6IFByb21pc2U8T1VUUFVUPiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIGRvbid0IHJldHJ5IHdoZW4gdGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWRcbiAgICB9XG5cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIGRvbid0IHdyYXAgdGhlIGVycm9yIHdoZW4gcmV0cmllcyBhcmUgZGlzYWJsZWRcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuXG4gICAgaWYgKHRyeU51bWJlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMuIExhc3QgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgIHJlYXNvbjogJ21heFJldHJpZXNFeGNlZWRlZCcsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgQVBJQ2FsbEVycm9yLmlzQVBJQ2FsbEVycm9yKGVycm9yKSAmJlxuICAgICAgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiZcbiAgICAgIHRyeU51bWJlciA8PSBtYXhSZXRyaWVzXG4gICAgKSB7XG4gICAgICBhd2FpdCBkZWxheShkZWxheUluTXMpO1xuICAgICAgcmV0dXJuIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoXG4gICAgICAgIGYsXG4gICAgICAgIHsgbWF4UmV0cmllcywgZGVsYXlJbk1zOiBiYWNrb2ZmRmFjdG9yICogZGVsYXlJbk1zLCBiYWNrb2ZmRmFjdG9yIH0sXG4gICAgICAgIG5ld0Vycm9ycyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRyeU51bWJlciA9PT0gMSkge1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIGRvbid0IHdyYXAgdGhlIGVycm9yIHdoZW4gYSBub24tcmV0cnlhYmxlIGVycm9yIG9jY3VycyBvbiB0aGUgZmlyc3QgdHJ5XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246ICdlcnJvck5vdFJldHJ5YWJsZScsXG4gICAgICBlcnJvcnM6IG5ld0Vycm9ycyxcbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGF5KGRlbGF5SW5NczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlJbk1zKSk7XG59XG4iLCJpbXBvcnQge1xuICBBc3Npc3RhbnRNZXNzYWdlLFxuICBEYXRhTWVzc2FnZSxcbiAgRnVuY3Rpb25DYWxsLFxuICBKU09OVmFsdWUsXG4gIFRvb2xDYWxsLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFN0cmVhbVN0cmluZyB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmVhbVBhcnQ8Q09ERSBleHRlbmRzIHN0cmluZywgTkFNRSBleHRlbmRzIHN0cmluZywgVFlQRT4ge1xuICBjb2RlOiBDT0RFO1xuICBuYW1lOiBOQU1FO1xuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHsgdHlwZTogTkFNRTsgdmFsdWU6IFRZUEUgfTtcbn1cblxuY29uc3QgdGV4dFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzAnLCAndGV4dCcsIHN0cmluZz4gPSB7XG4gIGNvZGU6ICcwJyxcbiAgbmFtZTogJ3RleHQnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInRleHRcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICcxJyxcbiAgJ2Z1bmN0aW9uX2NhbGwnLFxuICB7IGZ1bmN0aW9uX2NhbGw6IEZ1bmN0aW9uQ2FsbCB9XG4+ID0ge1xuICBjb2RlOiAnMScsXG4gIG5hbWU6ICdmdW5jdGlvbl9jYWxsJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgnZnVuY3Rpb25fY2FsbCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbCAhPT0gJ29iamVjdCcgfHxcbiAgICAgIHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fFxuICAgICAgISgnbmFtZScgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHxcbiAgICAgICEoJ2FyZ3VtZW50cycgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgIT09ICdzdHJpbmcnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Z1bmN0aW9uX2NhbGwnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIHVua25vd24gYXMgeyBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGwgfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgZGF0YVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8JzInLCAnZGF0YScsIEFycmF5PEpTT05WYWx1ZT4+ID0ge1xuICBjb2RlOiAnMicsXG4gIG5hbWU6ICdkYXRhJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImRhdGFcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHlwZTogJ2RhdGEnLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3QgZXJyb3JTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCczJywgJ2Vycm9yJywgc3RyaW5nPiA9IHtcbiAgY29kZTogJzMnLFxuICBuYW1lOiAnZXJyb3InLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAnZXJyb3InLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3QgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc0JyxcbiAgJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgQXNzaXN0YW50TWVzc2FnZVxuPiA9IHtcbiAgY29kZTogJzQnLFxuICBuYW1lOiAnYXNzaXN0YW50X21lc3NhZ2UnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCdpZCcgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdyb2xlJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ2NvbnRlbnQnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmlkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnJvbGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICB2YWx1ZS5yb2xlICE9PSAnYXNzaXN0YW50JyB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHxcbiAgICAgICF2YWx1ZS5jb250ZW50LmV2ZXJ5KFxuICAgICAgICBpdGVtID0+XG4gICAgICAgICAgaXRlbSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgJ3R5cGUnIGluIGl0ZW0gJiZcbiAgICAgICAgICBpdGVtLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICAgICd0ZXh0JyBpbiBpdGVtICYmXG4gICAgICAgICAgaXRlbS50ZXh0ICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgaXRlbS50ZXh0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICd2YWx1ZScgaW4gaXRlbS50ZXh0ICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0udGV4dC52YWx1ZSA9PT0gJ3N0cmluZycsXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGFuIFwiaWRcIiwgXCJyb2xlXCIsIGFuZCBcImNvbnRlbnRcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyBBc3Npc3RhbnRNZXNzYWdlLFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc1JyxcbiAgJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICB7XG4gICAgdGhyZWFkSWQ6IHN0cmluZztcbiAgICBtZXNzYWdlSWQ6IHN0cmluZztcbiAgfVxuPiA9IHtcbiAgY29kZTogJzUnLFxuICBuYW1lOiAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3RocmVhZElkJyBpbiB2YWx1ZSkgfHxcbiAgICAgICEoJ21lc3NhZ2VJZCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUudGhyZWFkSWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUubWVzc2FnZUlkICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0aHJlYWRJZFwiIGFuZCBcIm1lc3NhZ2VJZFwiIHByb3BlcnR5LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnYXNzaXN0YW50X2NvbnRyb2xfZGF0YScsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkLFxuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCc2JywgJ2RhdGFfbWVzc2FnZScsIERhdGFNZXNzYWdlPiA9IHtcbiAgY29kZTogJzYnLFxuICBuYW1lOiAnZGF0YV9tZXNzYWdlJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgncm9sZScgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdkYXRhJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5yb2xlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdmFsdWUucm9sZSAhPT0gJ2RhdGEnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImRhdGFfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwicm9sZVwiIGFuZCBcImRhdGFcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2RhdGFfbWVzc2FnZScsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgRGF0YU1lc3NhZ2UsXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IHRvb2xDYWxsU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzcnLFxuICAndG9vbF9jYWxscycsXG4gIHsgdG9vbF9jYWxsczogVG9vbENhbGxbXSB9XG4+ID0ge1xuICBjb2RlOiAnNycsXG4gIG5hbWU6ICd0b29sX2NhbGxzJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgndG9vbF9jYWxscycgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUudG9vbF9jYWxscyAhPT0gJ29iamVjdCcgfHxcbiAgICAgIHZhbHVlLnRvb2xfY2FsbHMgPT0gbnVsbCB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUudG9vbF9jYWxscykgfHxcbiAgICAgIHZhbHVlLnRvb2xfY2FsbHMuc29tZShcbiAgICAgICAgdGMgPT5cbiAgICAgICAgICB0YyA9PSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIHRjICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICEoJ2lkJyBpbiB0YykgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuaWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgISgndHlwZScgaW4gdGMpIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLnR5cGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgISgnZnVuY3Rpb24nIGluIHRjKSB8fFxuICAgICAgICAgIHRjLmZ1bmN0aW9uID09IG51bGwgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuZnVuY3Rpb24gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgISgnYXJndW1lbnRzJyBpbiB0Yy5mdW5jdGlvbikgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuZnVuY3Rpb24ubmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuZnVuY3Rpb24uYXJndW1lbnRzICE9PSAnc3RyaW5nJyxcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsc1wiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFRvb2xDYWxsUGF5bG9hZC4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3Rvb2xfY2FsbHMnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIHVua25vd24gYXMgeyB0b29sX2NhbGxzOiBUb29sQ2FsbFtdIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc4JyxcbiAgJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLFxuICBBcnJheTxKU09OVmFsdWU+XG4+ID0ge1xuICBjb2RlOiAnOCcsXG4gIG5hbWU6ICdtZXNzYWdlX2Fubm90YXRpb25zJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHlwZTogJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLCB2YWx1ZSB9O1xuICB9LFxufTtcblxuY29uc3Qgc3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0LFxuICBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBkYXRhU3RyZWFtUGFydCxcbiAgZXJyb3JTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LFxuICBkYXRhTWVzc2FnZVN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbl0gYXMgY29uc3Q7XG5cbi8vIHVuaW9uIHR5cGUgb2YgYWxsIHN0cmVhbSBwYXJ0c1xudHlwZSBTdHJlYW1QYXJ0cyA9XG4gIHwgdHlwZW9mIHRleHRTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZGF0YVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZXJyb3JTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydFxuICB8IHR5cGVvZiBkYXRhTWVzc2FnZVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgdG9vbENhbGxTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQ7XG4vKipcbiAqIE1hcHMgdGhlIHR5cGUgb2YgYSBzdHJlYW0gcGFydCB0byBpdHMgdmFsdWUgdHlwZS5cbiAqL1xudHlwZSBTdHJlYW1QYXJ0VmFsdWVUeXBlID0ge1xuICBbUCBpbiBTdHJlYW1QYXJ0cyBhcyBQWyduYW1lJ11dOiBSZXR1cm5UeXBlPFBbJ3BhcnNlJ10+Wyd2YWx1ZSddO1xufTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtUGFydFR5cGUgPVxuICB8IFJldHVyblR5cGU8dHlwZW9mIHRleHRTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZGF0YVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZXJyb3JTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgdG9vbENhbGxTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQucGFyc2U+O1xuXG5leHBvcnQgY29uc3Qgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LFxufSBhcyBjb25zdDtcblxuLyoqXG4gKiBUaGUgbWFwIG9mIHByZWZpeGVzIGZvciBkYXRhIGluIHRoZSBzdHJlYW1cbiAqXG4gKiAtIDA6IFRleHQgZnJvbSB0aGUgTExNIHJlc3BvbnNlXG4gKiAtIDE6IChPcGVuQUkpIGZ1bmN0aW9uX2NhbGwgcmVzcG9uc2VzXG4gKiAtIDI6IGN1c3RvbSBKU09OIGFkZGVkIGJ5IHRoZSB1c2VyIHVzaW5nIGBEYXRhYFxuICogLSA2OiAoT3BlbkFJKSB0b29sX2NhbGwgcmVzcG9uc2VzXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYFxuICogMDpWZXJjZWxcbiAqIDA6J3NcbiAqIDA6IEFJXG4gKiAwOiBBSVxuICogMDogU0RLXG4gKiAwOiBpcyBncmVhdFxuICogMDohXG4gKiAyOiB7IFwic29tZUpzb25cIjogXCJ2YWx1ZVwiIH1cbiAqIDE6IHtcImZ1bmN0aW9uX2NhbGxcIjoge1wibmFtZVwiOiBcImdldF9jdXJyZW50X3dlYXRoZXJcIiwgXCJhcmd1bWVudHNcIjogXCJ7XFxcXG5cXFxcXCJsb2NhdGlvblxcXFxcIjogXFxcXFwiQ2hhcmxvdHRlc3ZpbGxlLCBWaXJnaW5pYVxcXFxcIixcXFxcblxcXFxcImZvcm1hdFxcXFxcIjogXFxcXFwiY2Vsc2l1c1xcXFxcIlxcXFxufVwifX1cbiAqIDY6IHtcInRvb2xfY2FsbFwiOiB7XCJpZFwiOiBcInRvb2xfMFwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCJnZXRfY3VycmVudF93ZWF0aGVyXCIsIFwiYXJndW1lbnRzXCI6IFwie1xcXFxuXFxcXFwibG9jYXRpb25cXFxcXCI6IFxcXFxcIkNoYXJsb3R0ZXN2aWxsZSwgVmlyZ2luaWFcXFxcXCIsXFxcXG5cXFxcXCJmb3JtYXRcXFxcXCI6IFxcXFxcImNlbHNpdXNcXFxcXCJcXFxcbn1cIn19fVxuICpgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IFN0cmVhbVN0cmluZ1ByZWZpeGVzID0ge1xuICBbdGV4dFN0cmVhbVBhcnQubmFtZV06IHRleHRTdHJlYW1QYXJ0LmNvZGUsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0Lm5hbWVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhU3RyZWFtUGFydC5uYW1lXTogZGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2Vycm9yU3RyZWFtUGFydC5uYW1lXTogZXJyb3JTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQubmFtZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCB2YWxpZENvZGVzID0gc3RyZWFtUGFydHMubWFwKHBhcnQgPT4gcGFydC5jb2RlKTtcblxuLyoqXG5QYXJzZXMgYSBzdHJlYW0gcGFydCBmcm9tIGEgc3RyaW5nLlxuXG5AcGFyYW0gbGluZSBUaGUgc3RyaW5nIHRvIHBhcnNlLlxuQHJldHVybnMgVGhlIHBhcnNlZCBzdHJlYW0gcGFydC5cbkB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIHN0cmluZyBjYW5ub3QgYmUgcGFyc2VkLlxuICovXG5leHBvcnQgY29uc3QgcGFyc2VTdHJlYW1QYXJ0ID0gKGxpbmU6IHN0cmluZyk6IFN0cmVhbVBhcnRUeXBlID0+IHtcbiAgY29uc3QgZmlyc3RTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuXG4gIGlmIChmaXJzdFNlcGFyYXRvckluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC4nKTtcbiAgfVxuXG4gIGNvbnN0IHByZWZpeCA9IGxpbmUuc2xpY2UoMCwgZmlyc3RTZXBhcmF0b3JJbmRleCk7XG5cbiAgaWYgKCF2YWxpZENvZGVzLmluY2x1ZGVzKHByZWZpeCBhcyBrZXlvZiB0eXBlb2Ygc3RyZWFtUGFydHNCeUNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gSW52YWxpZCBjb2RlICR7cHJlZml4fS5gKTtcbiAgfVxuXG4gIGNvbnN0IGNvZGUgPSBwcmVmaXggYXMga2V5b2YgdHlwZW9mIHN0cmVhbVBhcnRzQnlDb2RlO1xuXG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWU6IEpTT05WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcblxuICByZXR1cm4gc3RyZWFtUGFydHNCeUNvZGVbY29kZV0ucGFyc2UoanNvblZhbHVlKTtcbn07XG5cbi8qKlxuUHJlcGVuZHMgYSBzdHJpbmcgd2l0aCBhIHByZWZpeCBmcm9tIHRoZSBgU3RyZWFtQ2h1bmtQcmVmaXhlc2AsIEpTT04taWZpZXMgaXQsXG5hbmQgYXBwZW5kcyBhIG5ldyBsaW5lLlxuXG5JdCBlbnN1cmVzIHR5cGUtc2FmZXR5IGZvciB0aGUgcGFydCB0eXBlIGFuZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFN0cmVhbVBhcnQ8VCBleHRlbmRzIGtleW9mIFN0cmVhbVBhcnRWYWx1ZVR5cGU+KFxuICB0eXBlOiBULFxuICB2YWx1ZTogU3RyZWFtUGFydFZhbHVlVHlwZVtUXSxcbik6IFN0cmVhbVN0cmluZyB7XG4gIGNvbnN0IHN0cmVhbVBhcnQgPSBzdHJlYW1QYXJ0cy5maW5kKHBhcnQgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcblxuICBpZiAoIXN0cmVhbVBhcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RyZWFtIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XFxuYDtcbn1cbiIsImltcG9ydCB7XG4gIFN0cmVhbVBhcnRUeXBlLFxuICBTdHJlYW1TdHJpbmdQcmVmaXhlcyxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxufSBmcm9tICcuL3N0cmVhbS1wYXJ0cyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vZ2VuZXJhdGUtaWQnO1xuXG4vLyBUT0RPIHJlbW92ZSAoYnJlYWtpbmcgY2hhbmdlKVxuZXhwb3J0IHsgZ2VuZXJhdGVJZCBhcyBuYW5vaWQgfSBmcm9tICcuL2dlbmVyYXRlLWlkJztcblxuLy8gRXhwb3J0IHN0cmVhbSBkYXRhIHV0aWxpdGllcyBmb3IgY3VzdG9tIHN0cmVhbSBpbXBsZW1lbnRhdGlvbnMsXG4vLyBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlLlxuZXhwb3J0IHR5cGUgeyBTdHJlYW1QYXJ0IH0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuZXhwb3J0IHsgZm9ybWF0U3RyZWFtUGFydCwgcGFyc2VTdHJlYW1QYXJ0IH0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuZXhwb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuL3JlYWQtZGF0YS1zdHJlYW0nO1xuXG4vLyBzaW1wbGUgZGVjb2RlciBzaWduYXR1cmVzOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKCk6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gc3RyaW5nO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4OiBmYWxzZSxcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gc3RyaW5nO1xuLy8gY29tcGxleCBkZWNvZGVyIHNpZ25hdHVyZTpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleDogdHJ1ZSxcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gU3RyZWFtUGFydFR5cGVbXTtcbi8vIGNvbWJpbmVkIHNpZ25hdHVyZSBmb3Igd2hlbiB0aGUgY2xpZW50IGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aCBhIGJvb2xlYW46XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg/OiBib29sZWFuLFxuKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBTdHJlYW1QYXJ0VHlwZVtdIHwgc3RyaW5nO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKGNvbXBsZXg/OiBib29sZWFuKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcblxuICBpZiAoIWNvbXBsZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICAgIGlmICghY2h1bmspIHJldHVybiAnJztcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlclxuICAgICAgLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lICE9PSAnJyk7IC8vIHNwbGl0dGluZyBsZWF2ZXMgYW4gZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmRcblxuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ2h1bmtEZWNvZGVyIH07XG5cbmV4cG9ydCBjb25zdCBpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlID0gKFxuICB0eXBlOiBrZXlvZiB0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXMsXG4gIHZhbHVlOiBzdHJpbmcsXG4pOiB2YWx1ZSBpcyBTdHJlYW1TdHJpbmcgPT5cbiAgdmFsdWUuc3RhcnRzV2l0aChgJHtTdHJlYW1TdHJpbmdQcmVmaXhlc1t0eXBlXX06YCkgJiYgdmFsdWUuZW5kc1dpdGgoJ1xcbicpO1xuXG5leHBvcnQgdHlwZSBTdHJlYW1TdHJpbmcgPVxuICBgJHsodHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzKVtrZXlvZiB0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXNdfToke3N0cmluZ31cXG5gO1xuIiwiaW1wb3J0IHtcbiAgY3JlYXRlUGFyc2VyLFxuICB0eXBlIEV2ZW50U291cmNlUGFyc2VyLFxuICB0eXBlIFBhcnNlZEV2ZW50LFxuICB0eXBlIFJlY29ubmVjdEludGVydmFsLFxufSBmcm9tICdldmVudHNvdXJjZS1wYXJzZXInO1xuaW1wb3J0IHsgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIH0gZnJvbSAnLi9vcGVuYWktc3RyZWFtJztcblxuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkNhbGxQYXlsb2FkIHtcbiAgbmFtZTogc3RyaW5nO1xuICBhcmd1bWVudHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xufVxuZXhwb3J0IGludGVyZmFjZSBUb29sQ2FsbFBheWxvYWQge1xuICB0b29sczoge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJztcbiAgICBmdW5jOiB7XG4gICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICBhcmd1bWVudHM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH07XG4gIH1bXTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgYW5kIGhlbHBlciBjYWxsYmFjayBtZXRob2RzIGZvciBBSVN0cmVhbSBzdHJlYW0gbGlmZWN5Y2xlIGV2ZW50cy5cbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMge1xuICAvKiogYG9uU3RhcnRgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgaW5pdGlhbGl6ZWQuICovXG4gIG9uU3RhcnQ/OiAoKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvbkNvbXBsZXRpb25gOiBDYWxsZWQgZm9yIGVhY2ggdG9rZW5pemVkIG1lc3NhZ2UuICovXG4gIG9uQ29tcGxldGlvbj86IChjb21wbGV0aW9uOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uRmluYWxgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgY2xvc2VkIHdpdGggdGhlIGZpbmFsIGNvbXBsZXRpb24gbWVzc2FnZS4gKi9cbiAgb25GaW5hbD86IChjb21wbGV0aW9uOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uVG9rZW5gOiBDYWxsZWQgZm9yIGVhY2ggdG9rZW5pemVkIG1lc3NhZ2UuICovXG4gIG9uVG9rZW4/OiAodG9rZW46IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25UZXh0YDogQ2FsbGVkIGZvciBlYWNoIHRleHQgY2h1bmsuICovXG4gIG9uVGV4dD86ICh0ZXh0OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBmbGFnIGlzIG5vIGxvbmdlciB1c2VkIGFuZCBvbmx5IHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICogWW91IGNhbiByZW1vdmUgaXQgZnJvbSB5b3VyIGNvZGUuXG4gICAqL1xuICBleHBlcmltZW50YWxfc3RyZWFtRGF0YT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIEFJU3RyZWFtUGFyc2VyLlxuICogQGludGVyZmFjZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50ICh0eXBlKSBmcm9tIHRoZSBzZXJ2ZXIgc2lkZSBldmVudCBzdHJlYW0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlTdHJlYW1QYXJzZXJPcHRpb25zIHtcbiAgZXZlbnQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ3VzdG9tIHBhcnNlciBmb3IgQUlTdHJlYW0gZGF0YS5cbiAqIEBpbnRlcmZhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gVGhlIGRhdGEgdG8gYmUgcGFyc2VkLlxuICogQHBhcmFtIHtBSVN0cmVhbVBhcnNlck9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHBhcnNlci5cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB2b2lkfSBUaGUgcGFyc2VkIGRhdGEgb3Igdm9pZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBSVN0cmVhbVBhcnNlciB7XG4gIChkYXRhOiBzdHJpbmcsIG9wdGlvbnM6IEFJU3RyZWFtUGFyc2VyT3B0aW9ucyk6XG4gICAgfCBzdHJpbmdcbiAgICB8IHZvaWRcbiAgICB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRyYW5zZm9ybVN0cmVhbSB0aGF0IHBhcnNlcyBldmVudHMgZnJvbSBhbiBFdmVudFNvdXJjZSBzdHJlYW0gdXNpbmcgYSBjdXN0b20gcGFyc2VyLlxuICogQHBhcmFtIHtBSVN0cmVhbVBhcnNlcn0gY3VzdG9tUGFyc2VyIC0gRnVuY3Rpb24gdG8gaGFuZGxlIGV2ZW50IGRhdGEuXG4gKiBAcmV0dXJucyB7VHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIHN0cmluZz59IFRyYW5zZm9ybVN0cmVhbSBwYXJzaW5nIGV2ZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoXG4gIGN1c3RvbVBhcnNlcj86IEFJU3RyZWFtUGFyc2VyLFxuKTogVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0+IHtcbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGV2ZW50U291cmNlUGFyc2VyOiBFdmVudFNvdXJjZVBhcnNlcjtcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIgPSBjcmVhdGVQYXJzZXIoXG4gICAgICAgIChldmVudDogUGFyc2VkRXZlbnQgfCBSZWNvbm5lY3RJbnRlcnZhbCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICgnZGF0YScgaW4gZXZlbnQgJiZcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2V2ZW50JyAmJlxuICAgICAgICAgICAgICBldmVudC5kYXRhID09PSAnW0RPTkVdJykgfHxcbiAgICAgICAgICAgIC8vIFJlcGxpY2F0ZSBkb2Vzbid0IHNlbmQgW0RPTkVdIGJ1dCBkb2VzIHNlbmQgYSAnZG9uZScgZXZlbnRcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZXBsaWNhdGUuY29tL2RvY3Mvc3RyZWFtaW5nXG4gICAgICAgICAgICAoZXZlbnQgYXMgYW55KS5ldmVudCA9PT0gJ2RvbmUnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnZGF0YScgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBjdXN0b21QYXJzZXJcbiAgICAgICAgICAgICAgPyBjdXN0b21QYXJzZXIoZXZlbnQuZGF0YSwge1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIDogZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRNZXNzYWdlKSBjb250cm9sbGVyLmVucXVldWUocGFyc2VkTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlci5mZWVkKHRleHREZWNvZGVyLmRlY29kZShjaHVuaykpO1xuICAgIH0sXG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgZW5jb2RlcyBpbnB1dCBtZXNzYWdlcyBhbmQgaW52b2tlcyBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbnMuXG4gKiBUaGUgdHJhbnNmb3JtIHN0cmVhbSB1c2VzIHRoZSBwcm92aWRlZCBjYWxsYmFja3MgdG8gZXhlY3V0ZSBjdXN0b20gbG9naWMgYXQgZGlmZmVyZW50IHN0YWdlcyBvZiB0aGUgc3RyZWFtJ3MgbGlmZWN5Y2xlLlxuICogLSBgb25TdGFydGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBpbml0aWFsaXplZC5cbiAqIC0gYG9uVG9rZW5gOiBDYWxsZWQgZm9yIGVhY2ggdG9rZW5pemVkIG1lc3NhZ2UuXG4gKiAtIGBvbkNvbXBsZXRpb25gOiBDYWxsZWQgZXZlcnkgdGltZSBhbiBBSVN0cmVhbSBjb21wbGV0aW9uIG1lc3NhZ2UgaXMgcmVjZWl2ZWQuIFRoaXMgY2FuIG9jY3VyIG11bHRpcGxlIHRpbWVzIHdoZW4gdXNpbmcgZS5nLiBPcGVuQUkgZnVuY3Rpb25zXG4gKiAtIGBvbkZpbmFsYDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGNsb3NlZCB3aXRoIHRoZSBmaW5hbCBjb21wbGV0aW9uIG1lc3NhZ2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBwcm9jZXNzIGEgc3RyZWFtIG9mIG1lc3NhZ2VzIGFuZCBwZXJmb3JtIHNwZWNpZmljIGFjdGlvbnMgZHVyaW5nIHRoZSBzdHJlYW0ncyBsaWZlY3ljbGUuXG4gKlxuICogQHBhcmFtIHtBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnN9IFtjYWxsYmFja3NdIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybVN0cmVhbTxzdHJpbmcsIFVpbnQ4QXJyYXk+fSBBIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCBlbmNvZGVzIGlucHV0IG1lc3NhZ2VzIGFzIFVpbnQ4QXJyYXkgYW5kIGFsbG93cyB0aGUgZXhlY3V0aW9uIG9mIGN1c3RvbSBsb2dpYyB0aHJvdWdoIGNhbGxiYWNrcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgY2FsbGJhY2tzID0ge1xuICogICBvblN0YXJ0OiBhc3luYyAoKSA9PiBjb25zb2xlLmxvZygnU3RyZWFtIHN0YXJ0ZWQnKSxcbiAqICAgb25Ub2tlbjogYXN5bmMgKHRva2VuKSA9PiBjb25zb2xlLmxvZyhgVG9rZW46ICR7dG9rZW59YCksXG4gKiAgIG9uQ29tcGxldGlvbjogYXN5bmMgKGNvbXBsZXRpb24pID0+IGNvbnNvbGUubG9nKGBDb21wbGV0aW9uOiAke2NvbXBsZXRpb259YClcbiAqICAgb25GaW5hbDogYXN5bmMgKCkgPT4gZGF0YS5jbG9zZSgpXG4gKiB9O1xuICogY29uc3QgdHJhbnNmb3JtZXIgPSBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gIGNiOiBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgfCBPcGVuQUlTdHJlYW1DYWxsYmFja3MgfCB1bmRlZmluZWQsXG4pOiBUcmFuc2Zvcm1TdHJlYW08c3RyaW5nIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfSwgVWludDhBcnJheT4ge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gJyc7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IGNiIHx8IHt9O1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydCkgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBtZXNzYWdlIDogbWVzc2FnZS5jb250ZW50O1xuXG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpKTtcblxuICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IGNvbnRlbnQ7XG5cbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbikgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4oY29udGVudCk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVGV4dChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgZmx1c2goKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBjb25zdCBpc09wZW5BSUNhbGxiYWNrcyA9IGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcyk7XG4gICAgICAvLyBJZiBpdCdzIE9wZW5BSUNhbGxiYWNrcywgaXQgaGFzIGFuIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB3aGljaCBtZWFucyB0aGF0IHRoZSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lclxuICAgICAgLy8gd2lsbCBoYW5kbGUgY2FsbGluZyBvbkNvbXBsZXRlLlxuICAgICAgaWYgKGNhbGxiYWNrcy5vbkNvbXBsZXRpb24pIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uQ29tcGxldGlvbihhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgIWlzT3BlbkFJQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKFxuICBjYWxsYmFja3M6IEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyB8IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyxcbik6IGNhbGxiYWNrcyBpcyBPcGVuQUlTdHJlYW1DYWxsYmFja3Mge1xuICByZXR1cm4gJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCcgaW4gY2FsbGJhY2tzO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RhdGVmdWwgZnVuY3Rpb24gdGhhdCwgd2hlbiBpbnZva2VkLCB0cmltcyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAqIGZyb20gdGhlIGlucHV0IHRleHQuIFRoZSB0cmltbWluZyBvbmx5IG9jY3VycyBvbiB0aGUgZmlyc3QgaW52b2NhdGlvbiwgZW5zdXJpbmcgdGhhdFxuICogc3Vic2VxdWVudCBjYWxscyBkbyBub3QgYWx0ZXIgdGhlIGlucHV0IHRleHQuIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBpbiBzY2VuYXJpb3NcbiAqIHdoZXJlIGEgdGV4dCBzdHJlYW0gaXMgYmVpbmcgcHJvY2Vzc2VkIGFuZCBvbmx5IHRoZSBpbml0aWFsIHdoaXRlc3BhY2Ugc2hvdWxkIGJlIHJlbW92ZWQuXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb24oc3RyaW5nKTogc3RyaW5nfSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzdHJpbmcgYXMgaW5wdXQgYW5kIHJldHVybnMgYSBzdHJpbmdcbiAqIHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWQgaWYgaXQgaXMgdGhlIGZpcnN0IGludm9jYXRpb247IG90aGVyd2lzZSwgaXQgcmV0dXJucyB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB0cmltU3RhcnQgPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICogY29uc3Qgb3V0cHV0MSA9IHRyaW1TdGFydChcIiAgIHRleHRcIik7IC8vIFwidGV4dFwiXG4gKiBjb25zdCBvdXRwdXQyID0gdHJpbVN0YXJ0KFwiICAgdGV4dFwiKTsgLy8gXCIgICB0ZXh0XCJcbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpOiAodGV4dDogc3RyaW5nKSA9PiBzdHJpbmcge1xuICBsZXQgaXNTdHJlYW1TdGFydCA9IHRydWU7XG5cbiAgcmV0dXJuICh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIGlmIChpc1N0cmVhbVN0YXJ0KSB7XG4gICAgICB0ZXh0ID0gdGV4dC50cmltU3RhcnQoKTtcbiAgICAgIGlmICh0ZXh0KSBpc1N0cmVhbVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBSZWFkYWJsZVN0cmVhbSBjcmVhdGVkIGZyb20gdGhlIHJlc3BvbnNlLCBwYXJzZWQgYW5kIGhhbmRsZWQgd2l0aCBjdXN0b20gbG9naWMuXG4gKiBUaGUgc3RyZWFtIGdvZXMgdGhyb3VnaCB0d28gdHJhbnNmb3JtYXRpb24gc3RhZ2VzLCBmaXJzdCBwYXJzaW5nIHRoZSBldmVudHMgYW5kIHRoZW5cbiAqIGludm9raW5nIHRoZSBwcm92aWRlZCBjYWxsYmFja3MuXG4gKlxuICogRm9yIDJ4eCBIVFRQIHJlc3BvbnNlczpcbiAqIC0gVGhlIGZ1bmN0aW9uIGNvbnRpbnVlcyB3aXRoIHN0YW5kYXJkIHN0cmVhbSBwcm9jZXNzaW5nLlxuICpcbiAqIEZvciBub24tMnh4IEhUVFAgcmVzcG9uc2VzOlxuICogLSBJZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBkZWZpbmVkLCBpdCBhc3luY2hyb25vdXNseSBleHRyYWN0cyBhbmQgZGVjb2RlcyB0aGUgcmVzcG9uc2UgYm9keS5cbiAqIC0gSXQgdGhlbiBjcmVhdGVzIGEgY3VzdG9tIFJlYWRhYmxlU3RyZWFtIHRvIHByb3BhZ2F0ZSBhIGRldGFpbGVkIGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UuXG4gKiBAcGFyYW0ge0FJU3RyZWFtUGFyc2VyfSBjdXN0b21QYXJzZXIgLSBUaGUgY3VzdG9tIHBhcnNlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zfSBjYWxsYmFja3MgLSBUaGUgY2FsbGJhY2tzLlxuICogQHJldHVybiB7UmVhZGFibGVTdHJlYW19IFRoZSBBSVN0cmVhbS5cbiAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgcmVzcG9uc2UgaXMgbm90IE9LLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQUlTdHJlYW0oXG4gIHJlc3BvbnNlOiBSZXNwb25zZSxcbiAgY3VzdG9tUGFyc2VyPzogQUlTdHJlYW1QYXJzZXIsXG4gIGNhbGxiYWNrcz86IEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyxcbik6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGlmIChyZXNwb25zZS5ib2R5KSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKGBSZXNwb25zZSBlcnJvcjogJHtlcnJvclRleHR9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKCdSZXNwb25zZSBlcnJvcjogTm8gcmVzcG9uc2UgYm9keScpKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlc3BvbnNlQm9keVN0cmVhbSA9IHJlc3BvbnNlLmJvZHkgfHwgY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpO1xuXG4gIHJldHVybiByZXNwb25zZUJvZHlTdHJlYW1cbiAgICAucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpKVxuICAgIC5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKTtcbn1cblxuLy8gb3V0cHV0cyBsaW5lcyBsaWtlXG4vLyAwOiBjaHVua1xuLy8gMDogbW9yZSBjaHVua1xuLy8gMTogYSBmY3QgY2FsbFxuLy8gejogYWRkZWQgZGF0YSBmcm9tIERhdGFcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IFJlYWRhYmxlU3RyZWFtIHRoYXQgaW1tZWRpYXRlbHkgY2xvc2VzIHVwb24gY3JlYXRpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYXMgYSBmYWxsYmFjayBmb3IgY3JlYXRpbmcgYSBSZWFkYWJsZVN0cmVhbSB3aGVuIHRoZSByZXNwb25zZSBib2R5IGlzIG51bGwgb3IgdW5kZWZpbmVkLFxuICogZW5zdXJpbmcgdGhhdCB0aGUgc3Vic2VxdWVudCBwaXBlbGluZSBwcm9jZXNzaW5nIGRvZXNuJ3QgZmFpbCBkdWUgdG8gYSBsYWNrIG9mIGEgc3RyZWFtLlxuICpcbiAqIEByZXR1cm5zIHtSZWFkYWJsZVN0cmVhbX0gQW4gZW1wdHkgYW5kIGNsb3NlZCBSZWFkYWJsZVN0cmVhbSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpOiBSZWFkYWJsZVN0cmVhbSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIFJlYWRhYmxlU3RyZWFtLmZyb20oYXN5bmNJdGVyYWJsZSksIHdoaWNoIGlzbid0IGRvY3VtZW50ZWQgaW4gTUROIGFuZCBpc24ndCBpbXBsZW1lbnRlZCBpbiBub2RlLlxuICogaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9zdHJlYW1zL2NvbW1pdC84ZDdhMGJmMjZlYjJjYzIzZTg4NGRkYmFhYzdjMWRhNGI5MWNmMmJjXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlPFQ+KGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFQ+KSB7XG4gIGxldCBpdCA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtPFQ+KHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgIGlmIChkb25lKSBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICBlbHNlIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIGF3YWl0IGl0LnJldHVybj8uKHJlYXNvbik7XG4gICAgfSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBmb3JtYXRTdHJlYW1QYXJ0IH0gZnJvbSAnLi4vc2hhcmVkL3N0cmVhbS1wYXJ0cyc7XG5pbXBvcnQgeyBKU09OVmFsdWUgfSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuXG4vKipcbiAqIEEgc3RyZWFtIHdyYXBwZXIgdG8gc2VuZCBjdXN0b20gSlNPTi1lbmNvZGVkIGRhdGEgYmFjayB0byB0aGUgY2xpZW50LlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtRGF0YSB7XG4gIHByaXZhdGUgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gIHByaXZhdGUgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8VWludDhBcnJheT4gfCBudWxsID1cbiAgICBudWxsO1xuICBwdWJsaWMgc3RyZWFtOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgVWludDhBcnJheT47XG5cbiAgLy8gY2xvc2luZyB0aGUgc3RyZWFtIGlzIHN5bmNocm9ub3VzLCBidXQgd2Ugd2FudCB0byByZXR1cm4gYSBwcm9taXNlXG4gIC8vIGluIGNhc2Ugd2UncmUgZG9pbmcgYXN5bmMgd29ya1xuICBwcml2YXRlIGlzQ2xvc2VkUHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzQ2xvc2VkUHJvbWlzZVJlc29sdmVyOiB1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCkgPSB1bmRlZmluZWQ7XG4gIHByaXZhdGUgaXNDbG9zZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvLyBhcnJheSB0byBzdG9yZSBhcHBlbmRlZCBkYXRhXG4gIHByaXZhdGUgZGF0YTogSlNPTlZhbHVlW10gPSBbXTtcbiAgcHJpdmF0ZSBtZXNzYWdlQW5ub3RhdGlvbnM6IEpTT05WYWx1ZVtdID0gW107XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuaXNDbG9zZWRQcm9taXNlUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyBjb250cm9sbGVyID0+IHtcbiAgICAgICAgc2VsZi5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgIH0sXG4gICAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAvLyBhZGQgYnVmZmVyZWQgZGF0YSB0byB0aGUgc3RyZWFtXG4gICAgICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoJ2RhdGEnLCBzZWxmLmRhdGEpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2VsZi5kYXRhID0gW107XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVkTWVzc2FnZUFubm90YXRpb25zID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLCBzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucyksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkTWVzc2FnZUFubm90YXRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAvLyBTaG93IGEgd2FybmluZyBkdXJpbmcgZGV2IGlmIHRoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nIGFmdGVyIDMgc2Vjb25kcy5cbiAgICAgICAgY29uc3Qgd2FybmluZ1RpbWVvdXQgPVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnXG4gICAgICAgICAgICA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICdUaGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZy4gRGlkIHlvdSBmb3JnZXQgdG8gY2xvc2UgaXQgd2l0aCBgZGF0YS5jbG9zZSgpYD8nLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0sIDMwMDApXG4gICAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgYXdhaXQgc2VsZi5pc0Nsb3NlZFByb21pc2U7XG5cbiAgICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlZERhdGEgPSBzZWxmLmVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydCgnZGF0YScsIHNlbGYuZGF0YSksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYubWVzc2FnZUFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLCBzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucyksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZERhdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgIH1cblxuICAgIHRoaXMuaXNDbG9zZWRQcm9taXNlUmVzb2x2ZXI/LigpO1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICB9XG5cbiAgYXBwZW5kKHZhbHVlOiBKU09OVmFsdWUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gIH1cblxuICBhcHBlbmRNZXNzYWdlQW5ub3RhdGlvbih2YWx1ZTogSlNPTlZhbHVlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNzYWdlQW5ub3RhdGlvbnMucHVzaCh2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIFRyYW5zZm9ybVN0cmVhbSBmb3IgTExNcyB0aGF0IGRvIG5vdCBoYXZlIHRoZWlyIG93biB0cmFuc2Zvcm0gc3RyZWFtIGhhbmRsZXJzIG1hbmFnaW5nIGVuY29kaW5nIChlLmcuIE9wZW5BSVN0cmVhbSBoYXMgb25lIGZvciBmdW5jdGlvbiBjYWxsIGhhbmRsaW5nKS5cbiAqIFRoaXMgYXNzdW1lcyBldmVyeSBjaHVuayBpcyBhICd0ZXh0JyBjaHVuay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KCd0ZXh0JywgbWVzc2FnZSkpKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG5AZGVwcmVjYXRlZCBVc2UgYFN0cmVhbURhdGFgIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBleHBlcmltZW50YWxfU3RyZWFtRGF0YSBleHRlbmRzIFN0cmVhbURhdGEge31cbiIsImltcG9ydCB7IGZvcm1hdFN0cmVhbVBhcnQgfSBmcm9tICcuLi9zaGFyZWQvc3RyZWFtLXBhcnRzJztcbmltcG9ydCB7XG4gIENyZWF0ZU1lc3NhZ2UsXG4gIEZ1bmN0aW9uQ2FsbCxcbiAgSlNPTlZhbHVlLFxuICBUb29sQ2FsbCxcbn0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZUNodW5rRGVjb2RlciB9IGZyb20gJy4uL3NoYXJlZC91dGlscyc7XG5cbmltcG9ydCB7XG4gIEFJU3RyZWFtLFxuICB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcixcbiAgdHlwZSBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMsXG4gIEZ1bmN0aW9uQ2FsbFBheWxvYWQsXG4gIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUsXG4gIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyLFxuICBUb29sQ2FsbFBheWxvYWQsXG59IGZyb20gJy4vYWktc3RyZWFtJztcbmltcG9ydCB7IEF6dXJlQ2hhdENvbXBsZXRpb25zIH0gZnJvbSAnLi9henVyZS1vcGVuYWktdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyIH0gZnJvbSAnLi9zdHJlYW0tZGF0YSc7XG5cbmV4cG9ydCB0eXBlIE9wZW5BSVN0cmVhbUNhbGxiYWNrcyA9IEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyAmIHtcbiAgLyoqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICogICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMDYxMycsXG4gICAqICAgc3RyZWFtOiB0cnVlLFxuICAgKiAgIG1lc3NhZ2VzLFxuICAgKiAgIGZ1bmN0aW9ucyxcbiAgICogfSlcbiAgICpcbiAgICogY29uc3Qgc3RyZWFtID0gT3BlbkFJU3RyZWFtKHJlc3BvbnNlLCB7XG4gICAqICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsOiBhc3luYyAoZnVuY3Rpb25DYWxsUGF5bG9hZCwgY3JlYXRlRnVuY3Rpb25DYWxsTWVzc2FnZXMpID0+IHtcbiAgICogICAgIC8vIC4uLiBydW4geW91ciBjdXN0b20gbG9naWMgaGVyZVxuICAgKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbXlGdW5jdGlvbihmdW5jdGlvbkNhbGxQYXlsb2FkKVxuICAgKlxuICAgKiAgICAgLy8gQXNrIGZvciBhbm90aGVyIGNvbXBsZXRpb24sIG9yIHJldHVybiBhIHN0cmluZyB0byBzZW5kIHRvIHRoZSBjbGllbnQgYXMgYW4gYXNzaXN0YW50IG1lc3NhZ2UuXG4gICAqICAgICByZXR1cm4gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICogICAgICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTA2MTMnLFxuICAgKiAgICAgICBzdHJlYW06IHRydWUsXG4gICAqICAgICAgIC8vIEFwcGVuZCB0aGUgcmVsZXZhbnQgXCJhc3Npc3RhbnRcIiBhbmQgXCJmdW5jdGlvblwiIGNhbGwgbWVzc2FnZXNcbiAgICogICAgICAgbWVzc2FnZXM6IFsuLi5tZXNzYWdlcywgLi4uY3JlYXRlRnVuY3Rpb25DYWxsTWVzc2FnZXMocmVzdWx0KV0sXG4gICAqICAgICAgIGZ1bmN0aW9ucyxcbiAgICogICAgIH0pXG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbD86IChcbiAgICBmdW5jdGlvbkNhbGxQYXlsb2FkOiBGdW5jdGlvbkNhbGxQYXlsb2FkLFxuICAgIGNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzOiAoXG4gICAgICBmdW5jdGlvbkNhbGxSZXN1bHQ6IEpTT05WYWx1ZSxcbiAgICApID0+IENyZWF0ZU1lc3NhZ2VbXSxcbiAgKSA9PiBQcm9taXNlPFxuICAgIFJlc3BvbnNlIHwgdW5kZWZpbmVkIHwgdm9pZCB8IHN0cmluZyB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlc1xuICA+O1xuICAvKipcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgKiAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0xMTA2JywgLy8gb3IgZ3B0LTQtMTEwNi1wcmV2aWV3XG4gICAqICAgc3RyZWFtOiB0cnVlLFxuICAgKiAgIG1lc3NhZ2VzLFxuICAgKiAgIHRvb2xzLFxuICAgKiAgIHRvb2xfY2hvaWNlOiBcImF1dG9cIiwgLy8gYXV0byBpcyBkZWZhdWx0LCBidXQgd2UnbGwgYmUgZXhwbGljaXRcbiAgICogfSlcbiAgICpcbiAgICogY29uc3Qgc3RyZWFtID0gT3BlbkFJU3RyZWFtKHJlc3BvbnNlLCB7XG4gICAqICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGw6IGFzeW5jICh0b29sQ2FsbFBheWxvYWQsIGFwcGVuZFRvb2xDYWxsTWVzc2FnZXMpID0+IHtcbiAgICogICAgbGV0IG1lc3NhZ2VzOiBDcmVhdGVNZXNzYWdlW10gPSBbXVxuICAgKiAgICAvLyAgIFRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIHRvb2wgY2FsbHMsIHNvIHdlIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZW1cbiAgICogICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xDYWxsUGF5bG9hZC50b29scykge1xuICAgKiAgICAgLy8gLi4uIHJ1biB5b3VyIGN1c3RvbSBsb2dpYyBoZXJlXG4gICAqICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBteUZ1bmN0aW9uKHRvb2wuZnVuY3Rpb24pXG4gICAqICAgIC8vIEFwcGVuZCB0aGUgcmVsZXZhbnQgXCJhc3Npc3RhbnRcIiBhbmQgXCJ0b29sXCIgY2FsbCBtZXNzYWdlc1xuICAgKiAgICAgYXBwZW5kVG9vbENhbGxNZXNzYWdlKHt0b29sX2NhbGxfaWQ6dG9vbC5pZCwgZnVuY3Rpb25fbmFtZTp0b29sLmZ1bmN0aW9uLm5hbWUsIHRvb2xfY2FsbF9yZXN1bHQ6cmVzdWx0fSlcbiAgICogICAgfVxuICAgKiAgICAgLy8gQXNrIGZvciBhbm90aGVyIGNvbXBsZXRpb24sIG9yIHJldHVybiBhIHN0cmluZyB0byBzZW5kIHRvIHRoZSBjbGllbnQgYXMgYW4gYXNzaXN0YW50IG1lc3NhZ2UuXG4gICAqICAgICByZXR1cm4gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICogICAgICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTExMDYnLCAvLyBvciBncHQtNC0xMTA2LXByZXZpZXdcbiAgICogICAgICAgc3RyZWFtOiB0cnVlLFxuICAgKiAgICAgICAvLyBBcHBlbmQgdGhlIHJlc3VsdHMgbWVzc2FnZXMsIGNhbGxpbmcgYXBwZW5kVG9vbENhbGxNZXNzYWdlIHdpdGhvdXRcbiAgICogICAgICAgLy8gYW55IGFyZ3VtZW50cyB3aWxsIGpzdXQgcmV0dXJuIHRoZSBhY2N1bXVsYXRlZCBtZXNzYWdlc1xuICAgKiAgICAgICBtZXNzYWdlczogWy4uLm1lc3NhZ2VzLCAuLi5hcHBlbmRUb29sQ2FsbE1lc3NhZ2UoKV0sXG4gICAqICAgICAgIHRvb2xzLFxuICAgKiAgICAgICAgdG9vbF9jaG9pY2U6IFwiYXV0b1wiLCAvLyBhdXRvIGlzIGRlZmF1bHQsIGJ1dCB3ZSdsbCBiZSBleHBsaWNpdFxuICAgKiAgICAgfSlcbiAgICogICB9XG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGw/OiAoXG4gICAgdG9vbENhbGxQYXlsb2FkOiBUb29sQ2FsbFBheWxvYWQsXG4gICAgYXBwZW5kVG9vbENhbGxNZXNzYWdlOiAocmVzdWx0Pzoge1xuICAgICAgdG9vbF9jYWxsX2lkOiBzdHJpbmc7XG4gICAgICBmdW5jdGlvbl9uYW1lOiBzdHJpbmc7XG4gICAgICB0b29sX2NhbGxfcmVzdWx0OiBKU09OVmFsdWU7XG4gICAgfSkgPT4gQ3JlYXRlTWVzc2FnZVtdLFxuICApID0+IFByb21pc2U8XG4gICAgUmVzcG9uc2UgfCB1bmRlZmluZWQgfCB2b2lkIHwgc3RyaW5nIHwgQXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzXG4gID47XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvMDdiMzUwNGUxYzQwZmQ5MjlmNGFhZTE2NTFiODNhZmMxOWUzYmFmOC9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHMjTDI4LUw0MFxuaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ2h1bmsge1xuICBpZDogc3RyaW5nO1xuICBjaG9pY2VzOiBBcnJheTxDaGF0Q29tcGxldGlvbkNodW5rQ2hvaWNlPjtcbiAgY3JlYXRlZDogbnVtYmVyO1xuICBtb2RlbDogc3RyaW5nO1xuICBvYmplY3Q6IHN0cmluZztcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iLzA3YjM1MDRlMWM0MGZkOTI5ZjRhYWUxNjUxYjgzYWZjMTllM2JhZjgvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzI0w0My1MNDlcbi8vIFVwZGF0ZWQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0L2YxMGM3NTdkODMxZDkwNDA3YmE0N2I0NjU5ZDljZDM0YjFhMzViMWRcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ2h1bmtDaG9pY2Uge1xuICBkZWx0YTogQ2hvaWNlRGVsdGE7XG4gIGZpbmlzaF9yZWFzb246XG4gICAgfCAnc3RvcCdcbiAgICB8ICdsZW5ndGgnXG4gICAgfCAndG9vbF9jYWxscydcbiAgICB8ICdjb250ZW50X2ZpbHRlcidcbiAgICB8ICdmdW5jdGlvbl9jYWxsJ1xuICAgIHwgbnVsbDtcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iLzA3YjM1MDRlMWM0MGZkOTI5ZjRhYWUxNjUxYjgzYWZjMTllM2JhZjgvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzI0wxMjMtTDEzOVxuLy8gVXBkYXRlZCB0byBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC84NGI0MzI4MDA4OWVhY2RmMThmMTcxNzIzNTkxODU2ODExYmVkZGNlXG5pbnRlcmZhY2UgQ2hvaWNlRGVsdGEge1xuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBjaHVuayBtZXNzYWdlLlxuICAgKi9cbiAgY29udGVudD86IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIGFuZCBhcmd1bWVudHMgb2YgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBjYWxsZWQsIGFzIGdlbmVyYXRlZCBieSB0aGVcbiAgICogbW9kZWwuXG4gICAqL1xuICBmdW5jdGlvbl9jYWxsPzogRnVuY3Rpb25DYWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgcm9sZSBvZiB0aGUgYXV0aG9yIG9mIHRoaXMgbWVzc2FnZS5cbiAgICovXG4gIHJvbGU/OiAnc3lzdGVtJyB8ICd1c2VyJyB8ICdhc3Npc3RhbnQnIHwgJ3Rvb2wnO1xuXG4gIHRvb2xfY2FsbHM/OiBBcnJheTxEZWx0YVRvb2xDYWxsPjtcbn1cblxuLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvbWFzdGVyL3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50c1xuLy8gVXBkYXRlZCB0byBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC84NGI0MzI4MDA4OWVhY2RmMThmMTcxNzIzNTkxODU2ODExYmVkZGNlXG5pbnRlcmZhY2UgRGVsdGFUb29sQ2FsbCB7XG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgdG9vbCBjYWxsLlxuICAgKi9cbiAgaWQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiB0aGF0IHRoZSBtb2RlbCBjYWxsZWQuXG4gICAqL1xuICBmdW5jdGlvbj86IFRvb2xDYWxsRnVuY3Rpb247XG5cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHRoZSB0b29sLiBDdXJyZW50bHksIG9ubHkgYGZ1bmN0aW9uYCBpcyBzdXBwb3J0ZWQuXG4gICAqL1xuICB0eXBlPzogJ2Z1bmN0aW9uJztcbn1cblxuLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvbWFzdGVyL3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50c1xuLy8gVXBkYXRlZCB0byBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC84NGI0MzI4MDA4OWVhY2RmMThmMTcxNzIzNTkxODU2ODExYmVkZGNlXG5pbnRlcmZhY2UgVG9vbENhbGxGdW5jdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgYXJndW1lbnRzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGgsIGFzIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaW4gSlNPTlxuICAgKiBmb3JtYXQuIE5vdGUgdGhhdCB0aGUgbW9kZWwgZG9lcyBub3QgYWx3YXlzIGdlbmVyYXRlIHZhbGlkIEpTT04sIGFuZCBtYXlcbiAgICogaGFsbHVjaW5hdGUgcGFyYW1ldGVycyBub3QgZGVmaW5lZCBieSB5b3VyIGZ1bmN0aW9uIHNjaGVtYS4gVmFsaWRhdGUgdGhlXG4gICAqIGFyZ3VtZW50cyBpbiB5b3VyIGNvZGUgYmVmb3JlIGNhbGxpbmcgeW91ciBmdW5jdGlvbi5cbiAgICovXG4gIGFyZ3VtZW50cz86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gICAqL1xuICBuYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8zZWM0M2VlNzkwYTJlYjZhMGNjZGQ1ZjI1ZmFhMjMyNTFiMGY5YjhlL3NyYy9yZXNvdXJjZXMvY29tcGxldGlvbnMudHMjTDI4QzEtTDY0QzFcbiAqIENvbXBsZXRpb25zIEFQSS4gU3RyZWFtZWQgYW5kIG5vbi1zdHJlYW1lZCByZXNwb25zZXMgYXJlIHRoZSBzYW1lLlxuICovXG5pbnRlcmZhY2UgQ29tcGxldGlvbiB7XG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY29tcGxldGlvbi5cbiAgICovXG4gIGlkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGNvbXBsZXRpb24gY2hvaWNlcyB0aGUgbW9kZWwgZ2VuZXJhdGVkIGZvciB0aGUgaW5wdXQgcHJvbXB0LlxuICAgKi9cbiAgY2hvaWNlczogQXJyYXk8Q29tcGxldGlvbkNob2ljZT47XG5cbiAgLyoqXG4gICAqIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBjb21wbGV0aW9uIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY3JlYXRlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgdXNlZCBmb3IgY29tcGxldGlvbi5cbiAgICovXG4gIG1vZGVsOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3QgdHlwZSwgd2hpY2ggaXMgYWx3YXlzIFwidGV4dF9jb21wbGV0aW9uXCJcbiAgICovXG4gIG9iamVjdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBVc2FnZSBzdGF0aXN0aWNzIGZvciB0aGUgY29tcGxldGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgdXNhZ2U/OiBDb21wbGV0aW9uVXNhZ2U7XG59XG5cbmludGVyZmFjZSBDb21wbGV0aW9uQ2hvaWNlIHtcbiAgLyoqXG4gICAqIFRoZSByZWFzb24gdGhlIG1vZGVsIHN0b3BwZWQgZ2VuZXJhdGluZyB0b2tlbnMuIFRoaXMgd2lsbCBiZSBgc3RvcGAgaWYgdGhlIG1vZGVsXG4gICAqIGhpdCBhIG5hdHVyYWwgc3RvcCBwb2ludCBvciBhIHByb3ZpZGVkIHN0b3Agc2VxdWVuY2UsIG9yIGBsZW5ndGhgIGlmIHRoZSBtYXhpbXVtXG4gICAqIG51bWJlciBvZiB0b2tlbnMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0IHdhcyByZWFjaGVkLlxuICAgKi9cbiAgZmluaXNoX3JlYXNvbjogJ3N0b3AnIHwgJ2xlbmd0aCcgfCAnY29udGVudF9maWx0ZXInO1xuXG4gIGluZGV4OiBudW1iZXI7XG5cbiAgLy8gZWRpdGVkOiBSZW1vdmVkIENvbXBsZXRpb25DaG9pY2UubG9nUHJvYnMgYW5kIHJlcGxhY2VkIHdpdGggYW55XG4gIGxvZ3Byb2JzOiBhbnkgfCBudWxsO1xuXG4gIHRleHQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uVXNhZ2Uge1xuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAgICovXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGdlbmVyYXRlZCBjb21wbGV0aW9uLlxuICAgKi9cbiAgY29tcGxldGlvbl90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHRva2VucyBpbiB0aGUgcHJvbXB0LlxuICAgKi9cbiAgcHJvbXB0X3Rva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUb3RhbCBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gdGhlIHJlcXVlc3QgKHByb21wdCArIGNvbXBsZXRpb24pLlxuICAgKi9cbiAgdG90YWxfdG9rZW5zOiBudW1iZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHBhcnNlciBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyB0aGUgT3BlbkFJIHN0cmVhbSBkYXRhLlxuICogVGhlIHBhcnNlciBleHRyYWN0cyBhbmQgdHJpbXMgdGV4dCBjb250ZW50IGZyb20gdGhlIEpTT04gZGF0YS4gVGhpcyBwYXJzZXJcbiAqIGNhbiBoYW5kbGUgZGF0YSBmb3IgY2hhdCBvciBjb21wbGV0aW9uIG1vZGVscy5cbiAqXG4gKiBAcmV0dXJuIHsoZGF0YTogc3RyaW5nKSA9PiBzdHJpbmcgfCB2b2lkfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9fVxuICogQSBwYXJzZXIgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIEpTT04gc3RyaW5nIGFzIGlucHV0IGFuZCByZXR1cm5zIHRoZSBleHRyYWN0ZWQgdGV4dCBjb250ZW50LFxuICogYSBjb21wbGV4IG9iamVjdCB3aXRoIGlzVGV4dDogZmFsc2UgZm9yIGZ1bmN0aW9uL3Rvb2wgY2FsbHMsIG9yIG5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3BlbkFJU3RyZWFtKCk6IChcbiAgZGF0YTogc3RyaW5nLFxuKSA9PiBzdHJpbmcgfCB2b2lkIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICByZXR1cm4gZGF0YSA9PiBleHRyYWN0KEpTT04ucGFyc2UoZGF0YSkgYXMgT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMpO1xufVxuXG4vKipcbiAqIFJlYWRzIGNodW5rcyBmcm9tIE9wZW5BSSdzIG5ldyBTdHJlYW1hYmxlIGludGVyZmFjZSwgd2hpY2ggaXMgZXNzZW50aWFsbHlcbiAqIHRoZSBzYW1lIGFzIHRoZSBvbGQgUmVzcG9uc2UgYm9keSBpbnRlcmZhY2Ugd2l0aCBhbiBpbmNsdWRlZCBTU0UgcGFyc2VyXG4gKiBkb2luZyB0aGUgcGFyc2luZyBmb3IgdXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlKHN0cmVhbTogQXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuXG4gIGZvciBhd2FpdCAobGV0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIC8vIGNvbnZlcnQgY2h1bmsgaWYgaXQgaXMgYW4gQXp1cmUgY2hhdCBjb21wbGV0aW9uLiBBenVyZSBkb2VzIG5vdCBleHBvc2UgYWxsXG4gICAgLy8gcHJvcGVydGllcyBpbiB0aGUgaW50ZXJmYWNlcywgYW5kIGFsc28gdXNlcyBjYW1lbENhc2UgaW5zdGVhZCBvZiBzbmFrZV9jYXNlXG4gICAgaWYgKCdwcm9tcHRGaWx0ZXJSZXN1bHRzJyBpbiBjaHVuaykge1xuICAgICAgY2h1bmsgPSB7XG4gICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgY3JlYXRlZDogY2h1bmsuY3JlYXRlZC5nZXREYXRlKCksXG4gICAgICAgIG9iamVjdDogKGNodW5rIGFzIGFueSkub2JqZWN0LCAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgbW9kZWw6IChjaHVuayBhcyBhbnkpLm1vZGVsLCAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgY2hvaWNlczogY2h1bmsuY2hvaWNlcy5tYXAoY2hvaWNlID0+ICh7XG4gICAgICAgICAgZGVsdGE6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNob2ljZS5kZWx0YT8uY29udGVudCxcbiAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IGNob2ljZS5kZWx0YT8uZnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgcm9sZTogY2hvaWNlLmRlbHRhPy5yb2xlIGFzIGFueSxcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IGNob2ljZS5kZWx0YT8udG9vbENhbGxzPy5sZW5ndGhcbiAgICAgICAgICAgICAgPyBjaG9pY2UuZGVsdGE/LnRvb2xDYWxscz8ubWFwKCh0b29sQ2FsbCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB0b29sQ2FsbC5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHRvb2xDYWxsLnR5cGUsXG4gICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmluaXNoX3JlYXNvbjogY2hvaWNlLmZpbmlzaFJlYXNvbiBhcyBhbnksXG4gICAgICAgICAgaW5kZXg6IGNob2ljZS5pbmRleCxcbiAgICAgICAgfSkpLFxuICAgICAgfSBzYXRpc2ZpZXMgQ2hhdENvbXBsZXRpb25DaHVuaztcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0ID0gZXh0cmFjdChjaHVuayk7XG5cbiAgICBpZiAodGV4dCkgeWllbGQgdGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaHVua1RvVGV4dCgpOiAoXG4gIGNodW5rOiBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbikgPT4gc3RyaW5nIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfSB8IHZvaWQge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW46IGJvb2xlYW47XG4gIHJldHVybiBqc29uID0+IHtcbiAgICBpZiAoaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IGpzb24uY2hvaWNlc1swXT8uZGVsdGE7XG4gICAgICBpZiAoZGVsdGEuZnVuY3Rpb25fY2FsbD8ubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogYHtcImZ1bmN0aW9uX2NhbGxcIjoge1wibmFtZVwiOiBcIiR7ZGVsdGEuZnVuY3Rpb25fY2FsbC5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImAsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhLnRvb2xfY2FsbHM/LlswXT8uZnVuY3Rpb24/Lm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9vbENhbGwgPSBkZWx0YS50b29sX2NhbGxzWzBdO1xuICAgICAgICBpZiAodG9vbENhbGwuaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGB7XCJ0b29sX2NhbGxzXCI6WyB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7dG9vbENhbGwuZnVuY3Rpb24/Lm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYCxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYFwifX0sIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHt0b29sQ2FsbC5mdW5jdGlvbj8ubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGVsdGEuZnVuY3Rpb25fY2FsbD8uYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKGRlbHRhLmZ1bmN0aW9uX2NhbGw/LmFyZ3VtZW50cyksXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhLnRvb2xfY2FsbHM/LlswXT8uZnVuY3Rpb24/LmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cyhkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5hcmd1bWVudHMpLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmXG4gICAgICAgIChqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICdmdW5jdGlvbl9jYWxsJyB8fFxuICAgICAgICAgIGpzb24uY2hvaWNlc1swXT8uZmluaXNoX3JlYXNvbiA9PT0gJ3N0b3AnKVxuICAgICAgKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlOyAvLyBSZXNldCB0aGUgZmxhZ1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX0nLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmXG4gICAgICAgIGpzb24uY2hvaWNlc1swXT8uZmluaXNoX3JlYXNvbiA9PT0gJ3Rvb2xfY2FsbHMnXG4gICAgICApIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7IC8vIFJlc2V0IHRoZSBmbGFnXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fV19JyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oXG4gICAgICBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikgJiYganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnRcbiAgICAgICAgPyBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudFxuICAgICAgICA6IGlzQ29tcGxldGlvbihqc29uKVxuICAgICAgICA/IGpzb24uY2hvaWNlc1swXS50ZXh0XG4gICAgICAgIDogJycsXG4gICAgKTtcblxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNsZWFudXBBcmd1bWVudHMoYXJndW1lbnRDaHVuazogc3RyaW5nKSB7XG4gICAgbGV0IGVzY2FwZWRQYXJ0aWFsSnNvbiA9IGFyZ3VtZW50Q2h1bmtcbiAgICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpIC8vIFJlcGxhY2UgYmFja3NsYXNoZXMgZmlyc3QgdG8gcHJldmVudCBkb3VibGUgZXNjYXBpbmdcbiAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ1xcXFwvJykgLy8gRXNjYXBlIHNsYXNoZXNcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgLy8gRXNjYXBlIGRvdWJsZSBxdW90ZXNcbiAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgLy8gRXNjYXBlIG5ldyBsaW5lc1xuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKSAvLyBFc2NhcGUgY2FycmlhZ2UgcmV0dXJuc1xuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKSAvLyBFc2NhcGUgdGFic1xuICAgICAgLnJlcGxhY2UoL1xcZi9nLCAnXFxcXGYnKTsgLy8gRXNjYXBlIGZvcm0gZmVlZHNcblxuICAgIHJldHVybiBgJHtlc2NhcGVkUGFydGlhbEpzb259YDtcbiAgfVxufVxuXG5jb25zdCBfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sID0gU3ltYm9sKFxuICAnaW50ZXJuYWxfb3BlbmFpX2ZuX21lc3NhZ2VzJyxcbik7XG5cbnR5cGUgQXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzID1cbiAgfCBBc3luY0l0ZXJhYmxlPENoYXRDb21wbGV0aW9uQ2h1bms+XG4gIHwgQXN5bmNJdGVyYWJsZTxDb21wbGV0aW9uPlxuICB8IEFzeW5jSXRlcmFibGU8QXp1cmVDaGF0Q29tcGxldGlvbnM+O1xuXG50eXBlIEV4dHJhY3RUeXBlPFQ+ID0gVCBleHRlbmRzIEFzeW5jSXRlcmFibGU8aW5mZXIgVT4gPyBVIDogbmV2ZXI7XG5cbnR5cGUgT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMgPVxuICBFeHRyYWN0VHlwZTxBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXM+O1xuXG5mdW5jdGlvbiBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoXG4gIGRhdGE6IE9wZW5BSVN0cmVhbVJldHVyblR5cGVzLFxuKTogZGF0YSBpcyBDaGF0Q29tcGxldGlvbkNodW5rIHtcbiAgcmV0dXJuIChcbiAgICAnY2hvaWNlcycgaW4gZGF0YSAmJlxuICAgIGRhdGEuY2hvaWNlcyAmJlxuICAgIGRhdGEuY2hvaWNlc1swXSAmJlxuICAgICdkZWx0YScgaW4gZGF0YS5jaG9pY2VzWzBdXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzQ29tcGxldGlvbihkYXRhOiBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyk6IGRhdGEgaXMgQ29tcGxldGlvbiB7XG4gIHJldHVybiAoXG4gICAgJ2Nob2ljZXMnIGluIGRhdGEgJiZcbiAgICBkYXRhLmNob2ljZXMgJiZcbiAgICBkYXRhLmNob2ljZXNbMF0gJiZcbiAgICAndGV4dCcgaW4gZGF0YS5jaG9pY2VzWzBdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBPcGVuQUlTdHJlYW0oXG4gIHJlczogUmVzcG9uc2UgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4gIGNhbGxiYWNrcz86IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyxcbik6IFJlYWRhYmxlU3RyZWFtIHtcbiAgLy8gQW5ub3RhdGUgdGhlIGludGVybmFsIGBtZXNzYWdlc2AgcHJvcGVydHkgZm9yIHJlY3Vyc2l2ZSBmdW5jdGlvbiBjYWxsc1xuICBjb25zdCBjYjpcbiAgICB8IHVuZGVmaW5lZFxuICAgIHwgKE9wZW5BSVN0cmVhbUNhbGxiYWNrcyAmIHtcbiAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdPzogQ3JlYXRlTWVzc2FnZVtdO1xuICAgICAgfSkgPSBjYWxsYmFja3M7XG5cbiAgbGV0IHN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT47XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUocmVzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgICAgICAgY2I/LmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYj8uZXhwZXJpbWVudGFsX29uVG9vbENhbGxcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgICAgIG9uRmluYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgICB9LFxuICAgICAgKSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IEFJU3RyZWFtKFxuICAgICAgcmVzLFxuICAgICAgcGFyc2VPcGVuQUlTdHJlYW0oKSxcbiAgICAgIGNiPy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2I/LmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgICBvbkZpbmFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIGlmIChjYiAmJiAoY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyID0gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2IpO1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKFxuICBjYWxsYmFja3M6IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyAmIHtcbiAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0/OiBDcmVhdGVNZXNzYWdlW107XG4gIH0sXG4pOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgVWludDhBcnJheT4ge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9ICcnO1xuICBsZXQgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gJyc7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcblxuICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZXM6IENyZWF0ZU1lc3NhZ2VbXSA9XG4gICAgY2FsbGJhY2tzW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdIHx8IFtdO1xuXG4gIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGUoY2h1bmspO1xuICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlICs9IG1lc3NhZ2U7XG5cbiAgICAgIGNvbnN0IHNob3VsZEhhbmRsZUFzRnVuY3Rpb24gPVxuICAgICAgICBpc0ZpcnN0Q2h1bmsgJiZcbiAgICAgICAgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpIHx8XG4gICAgICAgICAgbWVzc2FnZS5zdGFydHNXaXRoKCd7XCJ0b29sX2NhbGxzXCI6JykpO1xuXG4gICAgICBpZiAoc2hvdWxkSGFuZGxlQXNGdW5jdGlvbikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU3RyZWFtIGFzIG5vcm1hbFxuICAgICAgaWYgKCFpc0Z1bmN0aW9uU3RyZWFtaW5nSW4pIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KCd0ZXh0JywgbWVzc2FnZSkpLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaXNGaXJzdENodW5rICYmXG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmXG4gICAgICAgICAgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHxcbiAgICAgICAgICAgIGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgbWVzc2FnZSB0byB0aGUgbGlzdFxuICAgICAgICAgIGxldCBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID0gW1xuICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgXTtcblxuICAgICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlOlxuICAgICAgICAgICAgfCBSZXNwb25zZVxuICAgICAgICAgICAgfCB1bmRlZmluZWRcbiAgICAgICAgICAgIHwgdm9pZFxuICAgICAgICAgICAgfCBzdHJpbmdcbiAgICAgICAgICAgIHwgQXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzXG4gICAgICAgICAgICB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAvLyBUaGlzIGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgY2hlY2sgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgYnV0IFRTIGNvbXBsYWluc1xuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyB1c2luZyB0aGUgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIGNhbGxiYWNrLCB0aGV5IHNob3VsZCBub3QgYmUgdXNpbmcgdG9vbHNcbiAgICAgICAgICAgIC8vIGlmIHBheWxvYWQuZnVuY3Rpb25fY2FsbCBpcyBub3QgZGVmaW5lZCBieSB0aW1lIHdlIGdldCBoZXJlIHdlIG11c3QgaGF2ZSBnb3R0ZW4gYSB0b29sIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyBhbmQgdGhlIHVzZXIgaGFkIGRlZmluZWQgZXhwZXJpbWVudGFsX29uVG9vbENhbGxcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29scycsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c1BheWxvYWQgPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c1BheWxvYWQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlcXVlc3QgYW5kIHJlc3VsdCBtZXNzYWdlcyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdCksXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGl0IHRvIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzOiBUb29sQ2FsbFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgIHRvb2xzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgcGF5bG9hZC50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy50b29scy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogdG9vbC5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIGZ1bmM6IHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5wYXJzZSh0b29sLmZ1bmN0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VJbmRleCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKFxuICAgICAgICAgICAgICAgIHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICByZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvb2xfY2FsbF9pZCwgZnVuY3Rpb25fbmFtZSwgdG9vbF9jYWxsX3Jlc3VsdCB9ID1cbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXF1ZXN0IGFuZCByZXN1bHQgbWVzc2FnZXMgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgLi4ubmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBlbmQgdGhlIGFzc2lzdGFudCBtZXNzYWdlIGlmIGl0J3MgdGhlIGZpcnN0IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgLi4uKHJlc3BvbnNlSW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnIGFzIGNvbnN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBwYXlsb2FkLnRvb2xfY2FsbHMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGM6IFRvb2xDYWxsKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0Yy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0Yy5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2VuZCB0aGUgYXJndW1lbnRzIGFuIG9iamVjdCB0byB0aGUgdXNlciwgYnV0IGFzIHRoZSBBUEkgZXhwZWN0cyBhIHN0cmluZywgd2UgbmVlZCB0byBzdHJpbmdpZnkgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXN1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd0b29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uX25hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0b29sX2NhbGxfcmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaXQgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWxsaW5nIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZnVuY3Rpb25SZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gVGhlIHVzZXIgZGlkbid0IGRvIGFueXRoaW5nIHdpdGggdGhlIGZ1bmN0aW9uIGNhbGwgb24gdGhlIHNlcnZlciBhbmQgd2FudHNcbiAgICAgICAgICAgIC8vIHRvIGVpdGhlciBkbyBub3RoaW5nIG9yIHJ1biBpdCBvbiB0aGUgY2xpZW50XG4gICAgICAgICAgICAvLyBzbyB3ZSBqdXN0IHJldHVybiB0aGUgZnVuY3Rpb24gY2FsbCBhcyBhIG1lc3NhZ2VcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPyAnZnVuY3Rpb25fY2FsbCcgOiAndG9vbF9jYWxscycsXG4gICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0byBwcmV2ZW50IGRvdWJsZS1lbmNvZGluZzpcbiAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gVGhlIHVzZXIgcmV0dXJuZWQgYSBzdHJpbmcsIHNvIHdlIGp1c3QgcmV0dXJuIGl0IGFzIGEgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIGZ1bmN0aW9uUmVzcG9uc2UpKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBmdW5jdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5OlxuXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIG9uU3RhcnQgb3Igb25Db21wbGV0ZSByZWN1cnNpdmVseVxuICAgICAgICAgIC8vIHNvIHdlIHJlbW92ZSB0aGVtIGZyb20gdGhlIGNhbGxiYWNrc1xuICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL2FpL2lzc3Vlcy8zNTFcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZENhbGxiYWNrczogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLi4uY2FsbGJhY2tzLFxuICAgICAgICAgICAgb25TdGFydDogdW5kZWZpbmVkLFxuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gV2Ugb25seSB3YW50IG9uRmluYWwgdG8gYmUgY2FsbGVkIHRoZSBfbGFzdF8gdGltZVxuICAgICAgICAgIGNhbGxiYWNrcy5vbkZpbmFsID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgY29uc3Qgb3BlbkFJU3RyZWFtID0gT3BlbkFJU3RyZWFtKGZ1bmN0aW9uUmVzcG9uc2UsIHtcbiAgICAgICAgICAgIC4uLmZpbHRlcmVkQ2FsbGJhY2tzLFxuICAgICAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdOiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICB9IGFzIEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyk7XG5cbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBvcGVuQUlTdHJlYW0uZ2V0UmVhZGVyKCk7XG5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG59XG4iLCJleHBvcnQgY29uc3QgU1RSRUFNQUJMRV9WQUxVRV9UWVBFID0gU3ltYm9sLmZvcigndWkuc3RyZWFtYWJsZS52YWx1ZScpO1xuZXhwb3J0IGNvbnN0IERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FID0gMTUgKiAxMDAwO1xuIiwiaW1wb3J0IHtcbiAgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcixcbiAgTGFuZ3VhZ2VNb2RlbFYxLFxuICBOb1N1Y2hUb29sRXJyb3IsXG59IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5cbmltcG9ydCB7IENhbGxTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L2NhbGwtc2V0dGluZ3MnO1xuaW1wb3J0IHsgUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvcHJvbXB0JztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbWFibGVVSSB9IGZyb20gJy4uL3N0cmVhbWFibGUnO1xuaW1wb3J0IHsgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZic7XG5pbXBvcnQgeyBnZXRWYWxpZGF0ZWRQcm9tcHQgfSBmcm9tICcuLi8uLi9jb3JlL3Byb21wdC9nZXQtdmFsaWRhdGVkLXByb21wdCc7XG5pbXBvcnQgeyBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hIH0gZnJvbSAnLi4vLi4vY29yZS91dGlsL2NvbnZlcnQtem9kLXRvLWpzb24tc2NoZW1hJztcbmltcG9ydCB7IHByZXBhcmVDYWxsU2V0dGluZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MnO1xuaW1wb3J0IHsgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0JztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuXG50eXBlIFN0cmVhbWFibGUgPSBSZWFjdE5vZGUgfCBQcm9taXNlPFJlYWN0Tm9kZT47XG5cbnR5cGUgUmVuZGVyZXI8VCBleHRlbmRzIEFycmF5PGFueT4+ID0gKFxuICAuLi5hcmdzOiBUXG4pID0+XG4gIHwgU3RyZWFtYWJsZVxuICB8IEdlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPlxuICB8IEFzeW5jR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+O1xuXG50eXBlIFJlbmRlclRvb2w8UEFSQU1FVEVSUyBleHRlbmRzIHouWm9kVHlwZUFueSA9IGFueT4gPSB7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBwYXJhbWV0ZXJzOiBQQVJBTUVURVJTO1xuICBnZW5lcmF0ZT86IFJlbmRlcmVyPFxuICAgIFtcbiAgICAgIHouaW5mZXI8UEFSQU1FVEVSUz4sXG4gICAgICB7XG4gICAgICAgIHRvb2xOYW1lOiBzdHJpbmc7XG4gICAgICAgIHRvb2xDYWxsSWQ6IHN0cmluZztcbiAgICAgIH0sXG4gICAgXVxuICA+O1xufTtcblxudHlwZSBSZW5kZXJUZXh0ID0gUmVuZGVyZXI8XG4gIFtcbiAgICB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBmdWxsIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzbyBmYXIuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5ldyBhcHBlbmRlZCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgbW9kZWwgc2luY2UgdGhlIGxhc3QgYHRleHRgIGNhbGwuXG4gICAgICAgKi9cbiAgICAgIGRlbHRhOiBzdHJpbmc7XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdGhlIG1vZGVsIGlzIGRvbmUgZ2VuZXJhdGluZyB0ZXh0LlxuICAgICAgICogSWYgYHRydWVgLCB0aGUgYGNvbnRlbnRgIHdpbGwgYmUgdGhlIGZpbmFsIG91dHB1dCBhbmQgdGhpcyBjYWxsIHdpbGwgYmUgdGhlIGxhc3QuXG4gICAgICAgKi9cbiAgICAgIGRvbmU6IGJvb2xlYW47XG4gICAgfSxcbiAgXVxuPjtcblxudHlwZSBSZW5kZXJSZXN1bHQgPSB7XG4gIHZhbHVlOiBSZWFjdE5vZGU7XG59ICYgQXdhaXRlZDxSZXR1cm5UeXBlPExhbmd1YWdlTW9kZWxWMVsnZG9TdHJlYW0nXT4+O1xuXG5jb25zdCBkZWZhdWx0VGV4dFJlbmRlcmVyOiBSZW5kZXJUZXh0ID0gKHsgY29udGVudCB9OiB7IGNvbnRlbnQ6IHN0cmluZyB9KSA9PlxuICBjb250ZW50O1xuXG4vKipcbiAqIGBzdHJlYW1VSWAgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc3RyZWFtYWJsZSBVSSBmcm9tIExMTXMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdHJlYW1VSTxcbiAgVE9PTFMgZXh0ZW5kcyB7IFtuYW1lOiBzdHJpbmddOiB6LlpvZFR5cGVBbnkgfSA9IHt9LFxuPih7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaW5pdGlhbCxcbiAgdGV4dCxcbiAgLi4uc2V0dGluZ3Ncbn06IENhbGxTZXR0aW5ncyAmXG4gIFByb21wdCAmIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbGFuZ3VhZ2UgbW9kZWwgdG8gdXNlLlxuICAgICAqL1xuICAgIG1vZGVsOiBMYW5ndWFnZU1vZGVsVjE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG9vbHMgdGhhdCB0aGUgbW9kZWwgY2FuIGNhbGwuIFRoZSBtb2RlbCBuZWVkcyB0byBzdXBwb3J0IGNhbGxpbmcgdG9vbHMuXG4gICAgICovXG4gICAgdG9vbHM/OiB7XG4gICAgICBbbmFtZSBpbiBrZXlvZiBUT09MU106IFJlbmRlclRvb2w8VE9PTFNbbmFtZV0+O1xuICAgIH07XG5cbiAgICB0ZXh0PzogUmVuZGVyVGV4dDtcbiAgICBpbml0aWFsPzogUmVhY3ROb2RlO1xuICB9KTogUHJvbWlzZTxSZW5kZXJSZXN1bHQ+IHtcbiAgLy8gVE9ETzogUmVtb3ZlIHRoZXNlIGVycm9ycyBhZnRlciB0aGUgZXhwZXJpbWVudGFsIHBoYXNlLlxuICBpZiAodHlwZW9mIG1vZGVsID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgbW9kZWxgIGNhbm5vdCBiZSBhIHN0cmluZyBpbiBgc3RyZWFtVUlgLiBVc2UgdGhlIGFjdHVhbCBtb2RlbCBpbnN0YW5jZSBpbnN0ZWFkLicsXG4gICAgKTtcbiAgfVxuICBpZiAoJ2Z1bmN0aW9ucycgaW4gc2V0dGluZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYGZ1bmN0aW9uc2AgaXMgbm90IHN1cHBvcnRlZCBpbiBgc3RyZWFtVUlgLCB1c2UgYHRvb2xzYCBpbnN0ZWFkLicsXG4gICAgKTtcbiAgfVxuICBpZiAoJ3Byb3ZpZGVyJyBpbiBzZXR0aW5ncykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgcHJvdmlkZXJgIGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gYHN0cmVhbVVJYC4gVXNlIGBtb2RlbGAgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKHRvb2xzKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdG9vbF0gb2YgT2JqZWN0LmVudHJpZXModG9vbHMpKSB7XG4gICAgICBpZiAoJ3JlbmRlcicgaW4gdG9vbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1Rvb2wgZGVmaW5pdGlvbiBpbiBgc3RyZWFtVUlgIHNob3VsZCBub3QgaGF2ZSBgcmVuZGVyYCBwcm9wZXJ0eS4gVXNlIGBnZW5lcmF0ZWAgaW5zdGVhZC4gRm91bmQgaW4gdG9vbDogJyArXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVpID0gY3JlYXRlU3RyZWFtYWJsZVVJKGluaXRpYWwpO1xuXG4gIC8vIFRoZSBkZWZhdWx0IHRleHQgcmVuZGVyZXIganVzdCByZXR1cm5zIHRoZSBjb250ZW50IGFzIHN0cmluZy5cbiAgY29uc3QgdGV4dFJlbmRlciA9IHRleHQgfHwgZGVmYXVsdFRleHRSZW5kZXJlcjtcblxuICBsZXQgZmluaXNoZWQ6IFByb21pc2U8dm9pZD4gfCB1bmRlZmluZWQ7XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVuZGVyKFxuICAgIGFyZ3M6IFtwYXlsb2FkOiBhbnldIHwgW3BheWxvYWQ6IGFueSwgb3B0aW9uczogYW55XSxcbiAgICByZW5kZXJlcjogdW5kZWZpbmVkIHwgUmVuZGVyZXI8YW55PixcbiAgICByZXM6IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZVN0cmVhbWFibGVVST4sXG4gICkge1xuICAgIGlmICghcmVuZGVyZXIpIHJldHVybjtcblxuICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTx2b2lkPigpO1xuXG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICBmaW5pc2hlZCA9IGZpbmlzaGVkLnRoZW4oKCkgPT4gcmVzb2x2YWJsZS5wcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoZWQgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSByZW5kZXJlciguLi5hcmdzKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgfHxcbiAgICAgICh2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICd0aGVuJyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJylcbiAgICApIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhd2FpdCAodmFsdWUgYXMgUHJvbWlzZTxSZWFjdC5SZWFjdE5vZGU+KTtcbiAgICAgIHJlcy51cGRhdGUobm9kZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlXG4gICAgKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlIGFzIEFzeW5jR2VuZXJhdG9yPFxuICAgICAgICBSZWFjdC5SZWFjdE5vZGUsXG4gICAgICAgIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICAgICAgdm9pZFxuICAgICAgPjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWUgYXMgR2VuZXJhdG9yPFJlYWN0LlJlYWN0Tm9kZSwgUmVhY3QuUmVhY3ROb2RlLCB2b2lkPjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGl0Lm5leHQoKTtcbiAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeSgoKSA9PlxuICAgIG1vZGVsLmRvU3RyZWFtKHtcbiAgICAgIG1vZGU6IHtcbiAgICAgICAgdHlwZTogJ3JlZ3VsYXInLFxuICAgICAgICB0b29sczpcbiAgICAgICAgICB0b29scyA9PSBudWxsXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBPYmplY3QuZW50cmllcyh0b29scykubWFwKChbbmFtZSwgdG9vbF0pID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IGNvbnZlcnRab2RUb0pTT05TY2hlbWEodG9vbC5wYXJhbWV0ZXJzKSxcbiAgICAgICAgICAgICAgfSkpLFxuICAgICAgfSxcbiAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICB9KSxcbiAgKTtcblxuICBjb25zdCBbc3RyZWFtLCBmb3JrZWRTdHJlYW1dID0gcmVzdWx0LnN0cmVhbS50ZWUoKTtcblxuICAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb25zdW1lIHRoZSBmb3JrZWQgc3RyZWFtIGFzeW5jaG9ub3VzbHkuXG5cbiAgICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgICBsZXQgaGFzVG9vbENhbGwgPSBmYWxzZTtcblxuICAgICAgY29uc3QgcmVhZGVyID0gZm9ya2VkU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuXG4gICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3RleHQtZGVsdGEnOiB7XG4gICAgICAgICAgICBjb250ZW50ICs9IHZhbHVlLnRleHREZWx0YTtcbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgW3sgY29udGVudCwgZG9uZTogZmFsc2UsIGRlbHRhOiB2YWx1ZS50ZXh0RGVsdGEgfV0sXG4gICAgICAgICAgICAgIHRleHRSZW5kZXIsXG4gICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3Rvb2wtY2FsbC1kZWx0YSc6IHtcbiAgICAgICAgICAgIGhhc1Rvb2xDYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3Rvb2wtY2FsbCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gdmFsdWUudG9vbE5hbWUgYXMga2V5b2YgVE9PTFMgJiBzdHJpbmc7XG5cbiAgICAgICAgICAgIGlmICghdG9vbHMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiB0b29sTmFtZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG9vbCA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgIGlmICghdG9vbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgdGV4dDogdmFsdWUuYXJncyxcbiAgICAgICAgICAgICAgc2NoZW1hOiB0b29sLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICB0b29sQXJnczogdmFsdWUuYXJncyxcbiAgICAgICAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgdG9vbC5nZW5lcmF0ZSxcbiAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgIHRocm93IHZhbHVlLmVycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZpbmlzaCc6IHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1Rvb2xDYWxsKSB7XG4gICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICB1aS5kb25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVSZW5kZXIoW3sgY29udGVudCwgZG9uZTogdHJ1ZSB9XSwgdGV4dFJlbmRlciwgdWkpO1xuICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgdWkuZG9uZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBEdXJpbmcgdGhlIHN0cmVhbSByZW5kZXJpbmcsIHdlIGRvbid0IHdhbnQgdG8gdGhyb3cgdGhlIGVycm9yIHRvIHRoZVxuICAgICAgLy8gcGFyZW50IHNjb3BlIGJ1dCBvbmx5IGxldCB0aGUgUmVhY3QncyBlcnJvciBib3VuZGFyeSB0byBjYXRjaCBpdC5cbiAgICAgIHVpLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0pKCk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN1bHQsXG4gICAgc3RyZWFtLFxuICAgIHZhbHVlOiB1aS52YWx1ZSxcbiAgfTtcbn1cbiIsIi8vIFRoaXMgZmlsZSBwcm92aWRlcyB0aGUgQUkgY29udGV4dCB0byBhbGwgQUkgQWN0aW9ucyB2aWEgQXN5bmNMb2NhbFN0b3JhZ2UuXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEludGVybmFsQUlQcm92aWRlciB9IGZyb20gJy4vcnNjLXNoYXJlZC5tanMnO1xuaW1wb3J0IHtcbiAgd2l0aEFJU3RhdGUsXG4gIGdldEFJU3RhdGVEZWx0YVByb21pc2UsXG4gIHNlYWxNdXRhYmxlQUlTdGF0ZSxcbn0gZnJvbSAnLi9haS1zdGF0ZSc7XG5pbXBvcnQgdHlwZSB7XG4gIFNlcnZlcldyYXBwZWRBY3Rpb25zLFxuICBBSUFjdGlvbixcbiAgQUlBY3Rpb25zLFxuICBBSVByb3ZpZGVyLFxuICBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbiAgT25TZXRBSVN0YXRlLFxuICBPbkdldFVJU3RhdGUsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5hc3luYyBmdW5jdGlvbiBpbm5lckFjdGlvbjxUPihcbiAge1xuICAgIGFjdGlvbixcbiAgICBvcHRpb25zLFxuICB9OiB7IGFjdGlvbjogQUlBY3Rpb247IG9wdGlvbnM6IEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zIH0sXG4gIHN0YXRlOiBULFxuICAuLi5hcmdzOiB1bmtub3duW11cbikge1xuICAndXNlIHNlcnZlcic7XG4gIHJldHVybiBhd2FpdCB3aXRoQUlTdGF0ZShcbiAgICB7XG4gICAgICBzdGF0ZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgfSxcbiAgICBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpb24oLi4uYXJncyk7XG4gICAgICBzZWFsTXV0YWJsZUFJU3RhdGUoKTtcbiAgICAgIHJldHVybiBbZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSgpIGFzIFByb21pc2U8VD4sIHJlc3VsdF07XG4gICAgfSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gd3JhcEFjdGlvbjxUID0gdW5rbm93bj4oXG4gIGFjdGlvbjogQUlBY3Rpb24sXG4gIG9wdGlvbnM6IEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zLFxuKSB7XG4gIHJldHVybiBpbm5lckFjdGlvbi5iaW5kKG51bGwsIHsgYWN0aW9uLCBvcHRpb25zIH0pIGFzIEFJQWN0aW9uPFQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQUk8XG4gIEFJU3RhdGUgPSBhbnksXG4gIFVJU3RhdGUgPSBhbnksXG4gIEFjdGlvbnMgZXh0ZW5kcyBBSUFjdGlvbnMgPSB7fSxcbj4oe1xuICBhY3Rpb25zLFxuICBpbml0aWFsQUlTdGF0ZSxcbiAgaW5pdGlhbFVJU3RhdGUsXG5cbiAgb25TZXRBSVN0YXRlLFxuICBvbkdldFVJU3RhdGUsXG59OiB7XG4gIGFjdGlvbnM6IEFjdGlvbnM7XG4gIGluaXRpYWxBSVN0YXRlPzogQUlTdGF0ZTtcbiAgaW5pdGlhbFVJU3RhdGU/OiBVSVN0YXRlO1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgQUkgc3RhdGUgaXMgdXBkYXRlZCBieSBhbiBBY3Rpb24uXG4gICAqIFlvdSBjYW4gdXNlIHRoaXMgdG8gcGVyc2lzdCB0aGUgQUkgc3RhdGUgdG8gYSBkYXRhYmFzZSwgb3IgdG8gc2VuZCBpdCB0byBhXG4gICAqIGxvZ2dpbmcgc2VydmljZS5cbiAgICovXG4gIG9uU2V0QUlTdGF0ZT86IE9uU2V0QUlTdGF0ZTxBSVN0YXRlPjtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJldHJpZXZlIHRoZSBVSSBzdGF0ZSBiYXNlZCBvbiB0aGUgQUkgc3RhdGUuXG4gICAqIEZvciBleGFtcGxlLCB0byByZW5kZXIgdGhlIGluaXRpYWwgVUkgc3RhdGUgYmFzZWQgb24gYSBnaXZlbiBBSSBzdGF0ZSwgb3JcbiAgICogdG8gc3luYyB0aGUgVUkgc3RhdGUgd2hlbiB0aGUgYXBwbGljYXRpb24gaXMgYWxyZWFkeSBsb2FkZWQuXG4gICAqXG4gICAqIElmIHJldHVybmluZyBgdW5kZWZpbmVkYCwgdGhlIGNsaWVudCBzaWRlIFVJIHN0YXRlIHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBhbm5vdGF0ZWQgd2l0aCB0aGUgYFwidXNlIHNlcnZlclwiYCBkaXJlY3RpdmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzeFxuICAgKiBvbkdldFVJU3RhdGU6IGFzeW5jICgpID0+IHtcbiAgICogICAndXNlIHNlcnZlcic7XG4gICAqXG4gICAqICAgY29uc3QgY3VycmVudEFJU3RhdGUgPSBnZXRBSVN0YXRlKCk7XG4gICAqICAgY29uc3QgZXh0ZXJuYWxBSVN0YXRlID0gYXdhaXQgbG9hZEFJU3RhdGVGcm9tRGF0YWJhc2UoKTtcbiAgICpcbiAgICogICBpZiAoY3VycmVudEFJU3RhdGUgPT09IGV4dGVybmFsQUlTdGF0ZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICpcbiAgICogICAvLyBVcGRhdGUgY3VycmVudCBBSSBzdGF0ZSBhbmQgcmV0dXJuIHRoZSBuZXcgVUkgc3RhdGVcbiAgICogICBjb25zdCBzdGF0ZSA9IGdldE11dGFibGVBSVN0YXRlKClcbiAgICogICBzdGF0ZS5kb25lKGV4dGVybmFsQUlTdGF0ZSlcbiAgICpcbiAgICogICByZXR1cm4gPGRpdj4uLi48L2Rpdj47XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBvbkdldFVJU3RhdGU/OiBPbkdldFVJU3RhdGU8VUlTdGF0ZT47XG59KSB7XG4gIC8vIFdyYXAgYWxsIGFjdGlvbnMgd2l0aCBvdXIgSG9DLlxuICBjb25zdCB3cmFwcGVkQWN0aW9uczogU2VydmVyV3JhcHBlZEFjdGlvbnMgPSB7fTtcbiAgZm9yIChjb25zdCBuYW1lIGluIGFjdGlvbnMpIHtcbiAgICB3cmFwcGVkQWN0aW9uc1tuYW1lXSA9IHdyYXBBY3Rpb24oYWN0aW9uc1tuYW1lXSwge1xuICAgICAgb25TZXRBSVN0YXRlLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgd3JhcHBlZFN5bmNVSVN0YXRlID0gb25HZXRVSVN0YXRlXG4gICAgPyB3cmFwQWN0aW9uKG9uR2V0VUlTdGF0ZSwge30pXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgQUk6IEFJUHJvdmlkZXI8QUlTdGF0ZSwgVUlTdGF0ZSwgQWN0aW9ucz4gPSBhc3luYyBwcm9wcyA9PiB7XG4gICAgaWYgKCd1c2VTdGF0ZScgaW4gUmVhY3QpIHtcbiAgICAgIC8vIFRoaXMgZmlsZSBtdXN0IGJlIHJ1bm5pbmcgb24gdGhlIFJlYWN0IFNlcnZlciBsYXllci5cbiAgICAgIC8vIElkZWFsbHkgd2Ugc2hvdWxkIGJlIHVzaW5nIGBpbXBvcnQgXCJzZXJ2ZXItb25seVwiYCBoZXJlIGJ1dCB3ZSBjYW4gaGF2ZSBhXG4gICAgICAvLyBtb3JlIGN1c3RvbWl6ZWQgZXJyb3IgbWVzc2FnZSB3aXRoIHRoaXMgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGlzIGNvbXBvbmVudCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBTZXJ2ZXIgQ29tcG9uZW50cy4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgdWlTdGF0ZSA9IHByb3BzLmluaXRpYWxVSVN0YXRlID8/IGluaXRpYWxVSVN0YXRlO1xuICAgIGxldCBhaVN0YXRlID0gcHJvcHMuaW5pdGlhbEFJU3RhdGUgPz8gaW5pdGlhbEFJU3RhdGU7XG4gICAgbGV0IGFpU3RhdGVEZWx0YSA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh3cmFwcGVkU3luY1VJU3RhdGUpIHtcbiAgICAgIGNvbnN0IFtuZXdBSVN0YXRlRGVsdGEsIG5ld1VJU3RhdGVdID0gYXdhaXQgd3JhcHBlZFN5bmNVSVN0YXRlKGFpU3RhdGUpO1xuICAgICAgaWYgKG5ld1VJU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhaVN0YXRlRGVsdGEgPSBuZXdBSVN0YXRlRGVsdGE7XG4gICAgICAgIHVpU3RhdGUgPSBuZXdVSVN0YXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8SW50ZXJuYWxBSVByb3ZpZGVyXG4gICAgICAgIHdyYXBwZWRBY3Rpb25zPXt3cmFwcGVkQWN0aW9uc31cbiAgICAgICAgd3JhcHBlZFN5bmNVSVN0YXRlPXt3cmFwcGVkU3luY1VJU3RhdGV9XG4gICAgICAgIGluaXRpYWxVSVN0YXRlPXt1aVN0YXRlfVxuICAgICAgICBpbml0aWFsQUlTdGF0ZT17YWlTdGF0ZX1cbiAgICAgICAgaW5pdGlhbEFJU3RhdGVQYXRjaD17YWlTdGF0ZURlbHRhfVxuICAgICAgPlxuICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICA8L0ludGVybmFsQUlQcm92aWRlcj5cbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBBSTtcbn1cbiJdLCJuYW1lcyI6WyJBc3luY0xvY2FsU3RvcmFnZSIsImpzb25kaWZmcGF0Y2giLCJTdXNwZW5zZSIsIkZyYWdtZW50IiwianN4IiwianN4cyIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiUiIsImMiLCJuIiwiY2h1bmsiLCJkb25lIiwidmFsdWUiLCJhcHBlbmQiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwibmV4dCIsImNyZWF0ZVN1c3BlbnNlZENodW5rIiwiaW5pdGlhbFZhbHVlIiwicm93IiwiaXNGdW5jdGlvbiIsIngiLCJjb25zdW1lU3RyZWFtIiwic3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwicmVhZCIsImFzeW5jQUlTdGF0ZVN0b3JhZ2UiLCJnZXRBSVN0YXRlU3RvcmVPclRocm93IiwibWVzc2FnZSIsInN0b3JlIiwiZ2V0U3RvcmUiLCJFcnJvciIsIndpdGhBSVN0YXRlIiwic3RhdGUiLCJvcHRpb25zIiwiZm4iLCJydW4iLCJjdXJyZW50U3RhdGUiLCJvcmlnaW5hbFN0YXRlIiwic2VhbGVkIiwiZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSIsIm11dGF0aW9uRGVsdGFQcm9taXNlIiwic2VhbE11dGFibGVBSVN0YXRlIiwiZ2V0QUlTdGF0ZSIsImFyZ3MiLCJsZW5ndGgiLCJrZXkiLCJTdHJpbmciLCJnZXRNdXRhYmxlQUlTdGF0ZSIsIm11dGF0aW9uRGVsdGFSZXNvbHZlIiwiZG9VcGRhdGUiLCJuZXdTdGF0ZSIsIl9hIiwiX2IiLCJvblNldEFJU3RhdGUiLCJjYWxsIiwibXV0YWJsZVN0YXRlIiwiZ2V0IiwidXBkYXRlIiwibmV3QUlTdGF0ZSIsImRvbmVBcmdzIiwiZGVsdGEiLCJkaWZmIiwiem9kVG9Kc29uU2NoZW1hIiwibWltZVR5cGVTaWduYXR1cmVzIiwibWltZVR5cGUiLCJieXRlcyIsImRldGVjdEltYWdlTWltZVR5cGUiLCJpbWFnZSIsImV2ZXJ5IiwiYnl0ZSIsImluZGV4IiwiSW52YWxpZERhdGFDb250ZW50RXJyb3IiLCJjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IiwiY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCIsImNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheSIsImNvbnRlbnQiLCJVaW50OEFycmF5IiwiQXJyYXlCdWZmZXIiLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0IiwicHJvbXB0IiwibGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzIiwic3lzdGVtIiwicHVzaCIsInJvbGUiLCJ0eXBlIiwidGV4dCIsIm1lc3NhZ2VzIiwibWFwIiwicGFydCIsIlVSTCIsImltYWdlVWludDgiLCJfZXhoYXVzdGl2ZUNoZWNrIiwiSW52YWxpZFByb21wdEVycm9yIiwiZ2V0VmFsaWRhdGVkUHJvbXB0IiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJwcmVwYXJlQ2FsbFNldHRpbmdzIiwibWF4VG9rZW5zIiwidGVtcGVyYXR1cmUiLCJ0b3BQIiwicHJlc2VuY2VQZW5hbHR5IiwiZnJlcXVlbmN5UGVuYWx0eSIsInNlZWQiLCJtYXhSZXRyaWVzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwicGFyYW1ldGVyIiwiY29udmVydFpvZFRvSlNPTlNjaGVtYSIsInpvZFNjaGVtYSIsIkFQSUNhbGxFcnJvciIsIlJldHJ5RXJyb3IiLCJnZXRFcnJvck1lc3NhZ2UiLCJpc0Fib3J0RXJyb3IiLCJkZWxheSIsImRlbGF5SW5NcyIsInNldFRpbWVvdXQiLCJyZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYiLCJpbml0aWFsRGVsYXlJbk1zIiwiYmFja29mZkZhY3RvciIsImYiLCJfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiZXJyb3JzIiwiZXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJuZXdFcnJvcnMiLCJ0cnlOdW1iZXIiLCJyZWFzb24iLCJpc0FQSUNhbGxFcnJvciIsImlzUmV0cnlhYmxlIiwidGV4dFN0cmVhbVBhcnQiLCJjb2RlIiwibmFtZSIsInBhcnNlIiwiZnVuY3Rpb25DYWxsU3RyZWFtUGFydCIsImZ1bmN0aW9uX2NhbGwiLCJhcmd1bWVudHMiLCJkYXRhU3RyZWFtUGFydCIsIkFycmF5IiwiaXNBcnJheSIsImVycm9yU3RyZWFtUGFydCIsImFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0IiwiaWQiLCJpdGVtIiwiYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0IiwidGhyZWFkSWQiLCJtZXNzYWdlSWQiLCJkYXRhTWVzc2FnZVN0cmVhbVBhcnQiLCJ0b29sQ2FsbFN0cmVhbVBhcnQiLCJ0b29sX2NhbGxzIiwic29tZSIsInRjIiwiZnVuY3Rpb24iLCJtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Iiwic3RyZWFtUGFydHMiLCJzdHJlYW1QYXJ0c0J5Q29kZSIsIlN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlcyIsInBhcnNlU3RyZWFtUGFydCIsImxpbmUiLCJmaXJzdFNlcGFyYXRvckluZGV4IiwiaW5kZXhPZiIsInByZWZpeCIsInNsaWNlIiwiaW5jbHVkZXMiLCJ0ZXh0VmFsdWUiLCJqc29uVmFsdWUiLCJKU09OIiwiZm9ybWF0U3RyZWFtUGFydCIsInN0cmVhbVBhcnQiLCJmaW5kIiwic3RyaW5naWZ5IiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwiY29tcGxleCIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsImRlY29kZWQiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJjcmVhdGVQYXJzZXIiLCJjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyIiwiY3VzdG9tUGFyc2VyIiwidGV4dERlY29kZXIiLCJldmVudFNvdXJjZVBhcnNlciIsIlRyYW5zZm9ybVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsImV2ZW50IiwiZGF0YSIsInRlcm1pbmF0ZSIsInBhcnNlZE1lc3NhZ2UiLCJlbnF1ZXVlIiwidHJhbnNmb3JtIiwiZmVlZCIsImNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyIiwiY2IiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwiYWdncmVnYXRlZFJlc3BvbnNlIiwiY2FsbGJhY2tzIiwib25TdGFydCIsImVuY29kZSIsIm9uVG9rZW4iLCJvblRleHQiLCJmbHVzaCIsImlzT3BlbkFJQ2FsbGJhY2tzIiwiaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MiLCJvbkNvbXBsZXRpb24iLCJvbkZpbmFsIiwidHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIiLCJpc1N0cmVhbVN0YXJ0IiwidHJpbVN0YXJ0IiwiQUlTdHJlYW0iLCJyZXNwb25zZSIsIm9rIiwiYm9keSIsIlJlYWRhYmxlU3RyZWFtIiwiZXJyb3JUZXh0IiwicmVzcG9uc2VCb2R5U3RyZWFtIiwiY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSIsInBpcGVUaHJvdWdoIiwiY2xvc2UiLCJyZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlIiwiaXRlcmFibGUiLCJpdCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJwdWxsIiwiY2FuY2VsIiwicmV0dXJuIiwiY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyIiwiZW5jb2RlciIsInBhcnNlT3BlbkFJU3RyZWFtIiwiZXh0cmFjdCIsImNodW5rVG9UZXh0Iiwic3RyZWFtYWJsZSIsImNyZWF0ZWQiLCJnZXREYXRlIiwib2JqZWN0IiwibW9kZWwiLCJjaG9pY2VzIiwiY2hvaWNlIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsImZ1bmN0aW9uQ2FsbCIsInRvb2xDYWxscyIsInRvb2xDYWxsIiwiZmluaXNoX3JlYXNvbiIsImZpbmlzaFJlYXNvbiIsInRyaW1TdGFydE9mU3RyZWFtIiwiaXNGdW5jdGlvblN0cmVhbWluZ0luIiwianNvbiIsIl9oIiwiX2kiLCJfaiIsIl9rIiwiX2wiLCJfbSIsIl9uIiwiX28iLCJfcCIsIl9xIiwiX3IiLCJpc0NoYXRDb21wbGV0aW9uQ2h1bmsiLCJpc1RleHQiLCJjbGVhbnVwQXJndW1lbnRzIiwiaXNDb21wbGV0aW9uIiwiYXJndW1lbnRDaHVuayIsImVzY2FwZWRQYXJ0aWFsSnNvbiIsInJlcGxhY2UiLCJfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sIiwiT3BlbkFJU3RyZWFtIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyIiwiaXNGaXJzdENodW5rIiwiYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlIiwiZnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJzaG91bGRIYW5kbGVBc0Z1bmN0aW9uIiwic3RhcnRzV2l0aCIsInBheWxvYWQiLCJuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyIsImZ1bmN0aW9uUmVzcG9uc2UiLCJjb25zb2xlIiwid2FybiIsImFyZ3VtZW50c1BheWxvYWQiLCJyZXN1bHQiLCJ0b29scyIsInRvb2wiLCJmdW5jIiwicmVzcG9uc2VJbmRleCIsInRvb2xfY2FsbF9pZCIsImZ1bmN0aW9uX25hbWUiLCJ0b29sX2NhbGxfcmVzdWx0IiwiZSIsImZpbHRlcmVkQ2FsbGJhY2tzIiwib3BlbkFJU3RyZWFtIiwiU1RSRUFNQUJMRV9WQUxVRV9UWVBFIiwiZm9yIiwiREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUiLCJjcmVhdGVTdHJlYW1hYmxlVUkiLCJjdXJyZW50VmFsdWUiLCJjbG9zZWQiLCJhc3NlcnRTdHJlYW0iLCJtZXRob2QiLCJ3YXJuaW5nVGltZW91dCIsIndhcm5VbmNsb3NlZFN0cmVhbSIsInByb2Nlc3MiLCJjbGVhclRpbWVvdXQiLCJyZXNvbHZhYmxlIiwiU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLIiwiY3JlYXRlU3RyZWFtYWJsZVZhbHVlIiwiaXNSZWFkYWJsZVN0cmVhbSIsImxvY2tlZCIsImNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGwiLCJzdHJlYW1hYmxlVmFsdWUiLCJjdXJyZW50RXJyb3IiLCJjdXJyZW50UHJvbWlzZSIsImN1cnJlbnRQYXRjaFZhbHVlIiwiY3JlYXRlV3JhcHBlZCIsImluaXRpYWxDaHVuayIsImluaXQiLCJjdXJyIiwidXBkYXRlVmFsdWVTdGF0ZXMiLCJyZXNvbHZlUHJldmlvdXMiLCJyZW5kZXIiLCJ1aSIsImluaXRpYWwiLCJmdW5jdGlvbnMiLCJPYmplY3QiLCJlbnRyaWVzIiwiZGVzY3JpcHRpb24iLCJwYXJhbWV0ZXJzIiwiZmluaXNoZWQiLCJoYW5kbGVSZW5kZXIiLCJyZW5kZXJlciIsInRoZW4iLCJub2RlIiwiaXRlcmF0b3IiLCJoYXNGdW5jdGlvbiIsInByb3ZpZGVyIiwiY2hhdCIsImNvbXBsZXRpb25zIiwiY3JlYXRlIiwiZnVuY3Rpb25DYWxsUGF5bG9hZCIsInRvb2xDYWxsUGF5bG9hZCIsIkludmFsaWRUb29sQXJndW1lbnRzRXJyb3IiLCJOb1N1Y2hUb29sRXJyb3IiLCJzYWZlUGFyc2VKU09OIiwiZGVmYXVsdFRleHRSZW5kZXJlciIsInN0cmVhbVVJIiwiYWJvcnRTaWduYWwiLCJzZXR0aW5ncyIsInRleHRSZW5kZXIiLCJyZXRyeSIsInZhbGlkYXRlZFByb21wdCIsImRvU3RyZWFtIiwibW9kZSIsImlucHV0Rm9ybWF0IiwiZm9ya2VkU3RyZWFtIiwidGVlIiwiaGFzVG9vbENhbGwiLCJ0ZXh0RGVsdGEiLCJ0b29sTmFtZSIsImF2YWlsYWJsZVRvb2xzIiwia2V5cyIsInBhcnNlUmVzdWx0Iiwic2NoZW1hIiwic3VjY2VzcyIsInRvb2xBcmdzIiwiY2F1c2UiLCJ0b29sQ2FsbElkIiwiZ2VuZXJhdGUiLCJSZWFjdCIsIkludGVybmFsQUlQcm92aWRlciIsImlubmVyQWN0aW9uIiwiYWN0aW9uIiwid3JhcEFjdGlvbiIsImJpbmQiLCJjcmVhdGVBSSIsImFjdGlvbnMiLCJpbml0aWFsQUlTdGF0ZSIsImluaXRpYWxVSVN0YXRlIiwib25HZXRVSVN0YXRlIiwid3JhcHBlZEFjdGlvbnMiLCJ3cmFwcGVkU3luY1VJU3RhdGUiLCJBSSIsInByb3BzIiwidWlTdGF0ZSIsImFpU3RhdGUiLCJhaVN0YXRlRGVsdGEiLCJuZXdBSVN0YXRlRGVsdGEiLCJuZXdVSVN0YXRlIiwiaW5pdGlhbEFJU3RhdGVQYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ e0),
/* harmony export */   readStreamableValue: () => (/* binding */ e1),
/* harmony export */   useAIState: () => (/* binding */ e2),
/* harmony export */   useActions: () => (/* binding */ e3),
/* harmony export */   useStreamableValue: () => (/* binding */ e4),
/* harmony export */   useSyncUIState: () => (/* binding */ e5),
/* harmony export */   useUIState: () => (/* binding */ e6)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#InternalAIProvider`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#readStreamableValue`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useAIState`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useActions`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useStreamableValue`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useSyncUIState`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useUIState`);


/***/ })

};
;