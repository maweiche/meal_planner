"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/shared-client/streamable.tsx\n\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/shared-client/streamable.tsx\nfunction hasReadableValueSignature(value) {\n    return !!(value && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE);\n}\nfunction assertStreamableValue(value) {\n    if (!hasReadableValueSignature(value)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n}\nfunction isStreamableValue(value) {\n    const hasSignature = hasReadableValueSignature(value);\n    if (!hasSignature && typeof value !== \"undefined\") {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction readStreamableValue(streamableValue) {\n    assertStreamableValue(streamableValue);\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let curr = row.curr;\n            let done = false;\n            let initial = true;\n            return {\n                async next () {\n                    if (done) return {\n                        value: curr,\n                        done: true\n                    };\n                    row = await row;\n                    if (typeof row.error !== \"undefined\") {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            switch(row.diff[0]){\n                                case 0:\n                                    if (typeof curr !== \"string\") {\n                                        throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                    } else {\n                                        curr = curr + row.diff[1];\n                                    }\n                                    break;\n                            }\n                        } else {\n                            curr = row.curr;\n                        }\n                        if (!row.next) {\n                            done = true;\n                            return {\n                                value: curr,\n                                done: false\n                            };\n                        }\n                    }\n                    if (!row.next) {\n                        return {\n                            value: curr,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (initial) {\n                        initial = false;\n                        if (typeof curr === \"undefined\") {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value: curr,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!isStreamableValue(streamableValue)) return;\n        let cancelled = false;\n        const iterator = readStreamableValue(streamableValue);\n        if (streamableValue.next) {\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                if (cancelled) return;\n                setPending(true);\n            });\n        }\n        (async ()=>{\n            try {\n                for await (const value of iterator){\n                    if (cancelled) return;\n                    (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                        if (cancelled) return;\n                        setCurr(value);\n                    });\n                }\n            } catch (e) {\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setError(e);\n                });\n            } finally{\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setPending(false);\n                });\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// rsc/utils.tsx\n\n\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nvar isFunction = (x)=>typeof x === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (resolvedInitialAIStatePatch) {\n            return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n        }\n        return initialAIState;\n    }, [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        aiStateRef.current = aiState[0];\n    }, [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.fromEntries(Object.entries(wrappedActions).map(([key, action])=>[\n                key,\n                async (...args)=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                    (async ()=>{\n                        const delta = await aiStateDelta;\n                        if (delta !== void 0) {\n                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                        }\n                    })();\n                    return result;\n                }\n            ])), [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!wrappedSyncUIState) {\n            return ()=>{};\n        }\n        return async ()=>{\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n            if (uiState2 !== void 0) {\n                setUIState(uiState2);\n            }\n            const delta = await aiStateDelta;\n            if (delta !== void 0) {\n                const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                setAIState(patchedAiState);\n            }\n        };\n    }, [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : (newState)=>{\n        if (isFunction(newState)) {\n            return state[1]((s)=>{\n                return {\n                    ...s,\n                    [key]: newState(s[key])\n                };\n            });\n        } else {\n            return state[1]({\n                ...state[0],\n                [key]: newState\n            });\n        }\n    }, [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNoYXJlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7K0pBRUEsbUNBQW1DO0FBQ2dDO0FBRW5FLG1CQUFtQjtBQUNuQixJQUFJRyx3QkFBd0JDLE9BQU9DLEdBQUcsQ0FBQztBQUN2QyxJQUFJQyxzQ0FBc0MsS0FBSztBQUUvQyxtQ0FBbUM7QUFDbkMsU0FBU0MsMEJBQTBCQyxLQUFLO0lBQ3RDLE9BQU8sQ0FBQyxDQUFFQSxDQUFBQSxTQUFTLE9BQU9BLFVBQVUsWUFBWSxVQUFVQSxTQUFTQSxNQUFNQyxJQUFJLEtBQUtOLHFCQUFvQjtBQUN4RztBQUNBLFNBQVNPLHNCQUFzQkYsS0FBSztJQUNsQyxJQUFJLENBQUNELDBCQUEwQkMsUUFBUTtRQUNyQyxNQUFNLElBQUlHLE1BQ1I7SUFFSjtBQUNGO0FBQ0EsU0FBU0Msa0JBQWtCSixLQUFLO0lBQzlCLE1BQU1LLGVBQWVOLDBCQUEwQkM7SUFDL0MsSUFBSSxDQUFDSyxnQkFBZ0IsT0FBT0wsVUFBVSxhQUFhO1FBQ2pELE1BQU0sSUFBSUcsTUFDUjtJQUVKO0lBQ0EsT0FBT0U7QUFDVDtBQUNBLFNBQVNDLG9CQUFvQkMsZUFBZTtJQUMxQ0wsc0JBQXNCSztJQUN0QixPQUFPO1FBQ0wsQ0FBQ1gsT0FBT1ksYUFBYSxDQUFDO1lBQ3BCLElBQUlDLE1BQU1GO1lBQ1YsSUFBSUcsT0FBT0QsSUFBSUMsSUFBSTtZQUNuQixJQUFJQyxPQUFPO1lBQ1gsSUFBSUMsVUFBVTtZQUNkLE9BQU87Z0JBQ0wsTUFBTUM7b0JBQ0osSUFBSUYsTUFDRixPQUFPO3dCQUFFWCxPQUFPVTt3QkFBTUMsTUFBTTtvQkFBSztvQkFDbkNGLE1BQU0sTUFBTUE7b0JBQ1osSUFBSSxPQUFPQSxJQUFJSyxLQUFLLEtBQUssYUFBYTt3QkFDcEMsTUFBTUwsSUFBSUssS0FBSztvQkFDakI7b0JBQ0EsSUFBSSxVQUFVTCxPQUFPQSxJQUFJTSxJQUFJLEVBQUU7d0JBQzdC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dWxlcy9haS9yc2MvZGlzdC9yc2Mtc2hhcmVkLm1qcz9mZWVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG4vLyByc2Mvc2hhcmVkLWNsaWVudC9zdHJlYW1hYmxlLnRzeFxuaW1wb3J0IHsgc3RhcnRUcmFuc2l0aW9uLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHJzYy9jb25zdGFudHMudHNcbnZhciBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUgPSBTeW1ib2wuZm9yKFwidWkuc3RyZWFtYWJsZS52YWx1ZVwiKTtcbnZhciBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSA9IDE1ICogMWUzO1xuXG4vLyByc2Mvc2hhcmVkLWNsaWVudC9zdHJlYW1hYmxlLnRzeFxuZnVuY3Rpb24gaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSk7XG59XG5mdW5jdGlvbiBhc3NlcnRTdHJlYW1hYmxlVmFsdWUodmFsdWUpIHtcbiAgaWYgKCFoYXNSZWFkYWJsZVZhbHVlU2lnbmF0dXJlKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZTogdGhpcyBob29rIG9ubHkgYWNjZXB0cyB2YWx1ZXMgY3JlYXRlZCB2aWEgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZWAuXCJcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBpc1N0cmVhbWFibGVWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBoYXNTaWduYXR1cmUgPSBoYXNSZWFkYWJsZVZhbHVlU2lnbmF0dXJlKHZhbHVlKTtcbiAgaWYgKCFoYXNTaWduYXR1cmUgJiYgdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlOiB0aGlzIGhvb2sgb25seSBhY2NlcHRzIHZhbHVlcyBjcmVhdGVkIHZpYSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlYC5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGhhc1NpZ25hdHVyZTtcbn1cbmZ1bmN0aW9uIHJlYWRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSB7XG4gIGFzc2VydFN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICBsZXQgcm93ID0gc3RyZWFtYWJsZVZhbHVlO1xuICAgICAgbGV0IGN1cnIgPSByb3cuY3VycjtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICBsZXQgaW5pdGlhbCA9IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGN1cnIsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICByb3cgPSBhd2FpdCByb3c7XG4gICAgICAgICAgaWYgKHR5cGVvZiByb3cuZXJyb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IHJvdy5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFwiY3VyclwiIGluIHJvdyB8fCByb3cuZGlmZikge1xuICAgICAgICAgICAgaWYgKHJvdy5kaWZmKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocm93LmRpZmZbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCBwYXRjaDogY2FuIG9ubHkgYXBwZW5kIHRvIHN0cmluZyB0eXBlcy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgQUkgU0RLLlwiXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VyciArIHJvdy5kaWZmWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnIgPSByb3cuY3VycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm93Lm5leHQpIHtcbiAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1cnIsXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyb3cubmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGN1cnIsXG4gICAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvdyA9IHJvdy5uZXh0O1xuICAgICAgICAgIGlmIChpbml0aWFsKSB7XG4gICAgICAgICAgICBpbml0aWFsID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGN1cnIsXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdXNlU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkge1xuICBjb25zdCBbY3Vyciwgc2V0Q3Vycl0gPSB1c2VTdGF0ZShcbiAgICBpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gc3RyZWFtYWJsZVZhbHVlLmN1cnIgOiB2b2lkIDBcbiAgKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShcbiAgICBpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gc3RyZWFtYWJsZVZhbHVlLmVycm9yIDogdm9pZCAwXG4gICk7XG4gIGNvbnN0IFtwZW5kaW5nLCBzZXRQZW5kaW5nXSA9IHVzZVN0YXRlKFxuICAgIGlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkgPyAhIXN0cmVhbWFibGVWYWx1ZS5uZXh0IDogZmFsc2VcbiAgKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gcmVhZFN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpO1xuICAgIGlmIChzdHJlYW1hYmxlVmFsdWUubmV4dCkge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNldFBlbmRpbmcodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRDdXJyKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHNldEVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgIGlmIChjYW5jZWxsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc2V0UGVuZGluZyhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgfSwgW3N0cmVhbWFibGVWYWx1ZV0pO1xuICByZXR1cm4gW2N1cnIsIGVycm9yLCBwZW5kaW5nXTtcbn1cblxuLy8gcnNjL3NoYXJlZC1jbGllbnQvY29udGV4dC50c3hcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCAqIGFzIGpzb25kaWZmcGF0Y2ggZnJvbSBcImpzb25kaWZmcGF0Y2hcIjtcblxuLy8gcnNjL3V0aWxzLnRzeFxuaW1wb3J0IHsgU3VzcGVuc2UgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEZyYWdtZW50LCBqc3gsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSID0gW1xuICBhc3luYyAoe1xuICAgIGMsXG4gICAgLy8gY3VycmVudFxuICAgIG5cbiAgICAvLyBuZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBjaHVuayA9IGF3YWl0IG47XG4gICAgaWYgKGNodW5rLmRvbmUpIHtcbiAgICAgIHJldHVybiBjaHVuay52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGNodW5rLmFwcGVuZCkge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAgIGMsXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goU3VzcGVuc2UsIHsgZmFsbGJhY2s6IGNodW5rLnZhbHVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChSLCB7IGM6IGNodW5rLnZhbHVlLCBuOiBjaHVuay5uZXh0IH0pIH0pXG4gICAgICBdIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTdXNwZW5zZSwgeyBmYWxsYmFjazogY2h1bmsudmFsdWUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFIsIHsgYzogY2h1bmsudmFsdWUsIG46IGNodW5rLm5leHQgfSkgfSk7XG4gIH1cbl1bMF07XG52YXIgaXNGdW5jdGlvbiA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xuXG4vLyByc2Mvc2hhcmVkLWNsaWVudC9jb250ZXh0LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBJbnRlcm5hbFVJU3RhdGVQcm92aWRlciA9IFJlYWN0Mi5jcmVhdGVDb250ZXh0KG51bGwpO1xudmFyIEludGVybmFsQUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QyLmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbnZhciBJbnRlcm5hbEFjdGlvblByb3ZpZGVyID0gUmVhY3QyLmNyZWF0ZUNvbnRleHQobnVsbCk7XG52YXIgSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QyLmNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiBJbnRlcm5hbEFJUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbiAgaW5pdGlhbFVJU3RhdGUsXG4gIGluaXRpYWxBSVN0YXRlLFxuICBpbml0aWFsQUlTdGF0ZVBhdGNoLFxuICB3cmFwcGVkQWN0aW9ucyxcbiAgd3JhcHBlZFN5bmNVSVN0YXRlXG59KSB7XG4gIGlmICghKFwidXNlXCIgaW4gUmVhY3QyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFJlYWN0IHZlcnNpb24uXCIpO1xuICB9XG4gIGNvbnN0IHVpU3RhdGUgPSBSZWFjdDIudXNlU3RhdGUoaW5pdGlhbFVJU3RhdGUpO1xuICBjb25zdCBzZXRVSVN0YXRlID0gdWlTdGF0ZVsxXTtcbiAgY29uc3QgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoID0gaW5pdGlhbEFJU3RhdGVQYXRjaCA/IFJlYWN0Mi51c2UoaW5pdGlhbEFJU3RhdGVQYXRjaCkgOiB2b2lkIDA7XG4gIGluaXRpYWxBSVN0YXRlID0gUmVhY3QyLnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChyZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2gpIHtcbiAgICAgIHJldHVybiBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGluaXRpYWxBSVN0YXRlKSxcbiAgICAgICAgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbEFJU3RhdGU7XG4gIH0sIFtpbml0aWFsQUlTdGF0ZSwgcmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoXSk7XG4gIGNvbnN0IGFpU3RhdGUgPSBSZWFjdDIudXNlU3RhdGUoaW5pdGlhbEFJU3RhdGUpO1xuICBjb25zdCBzZXRBSVN0YXRlID0gYWlTdGF0ZVsxXTtcbiAgY29uc3QgYWlTdGF0ZVJlZiA9IFJlYWN0Mi51c2VSZWYoYWlTdGF0ZVswXSk7XG4gIFJlYWN0Mi51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFpU3RhdGVSZWYuY3VycmVudCA9IGFpU3RhdGVbMF07XG4gIH0sIFthaVN0YXRlWzBdXSk7XG4gIGNvbnN0IGNsaWVudFdyYXBwZWRBY3Rpb25zID0gUmVhY3QyLnVzZU1lbW8oXG4gICAgKCkgPT4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMod3JhcHBlZEFjdGlvbnMpLm1hcCgoW2tleSwgYWN0aW9uXSkgPT4gW1xuICAgICAgICBrZXksXG4gICAgICAgIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgY29uc3QgYWlTdGF0ZVNuYXBzaG90ID0gYWlTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICAgIGNvbnN0IFthaVN0YXRlRGVsdGEsIHJlc3VsdF0gPSBhd2FpdCBhY3Rpb24oXG4gICAgICAgICAgICBhaVN0YXRlU25hcHNob3QsXG4gICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBhd2FpdCBhaVN0YXRlRGVsdGE7XG4gICAgICAgICAgICBpZiAoZGVsdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBhaVN0YXRlWzFdKFxuICAgICAgICAgICAgICAgIGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgICAgICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGFpU3RhdGVTbmFwc2hvdCksXG4gICAgICAgICAgICAgICAgICBkZWx0YVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIF0pXG4gICAgKSxcbiAgICBbd3JhcHBlZEFjdGlvbnNdXG4gICk7XG4gIGNvbnN0IGNsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbiA9IFJlYWN0Mi51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIXdyYXBwZWRTeW5jVUlTdGF0ZSkge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhaVN0YXRlU25hcHNob3QgPSBhaVN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBbYWlTdGF0ZURlbHRhLCB1aVN0YXRlMl0gPSBhd2FpdCB3cmFwcGVkU3luY1VJU3RhdGUoXG4gICAgICAgIGFpU3RhdGVTbmFwc2hvdFxuICAgICAgKTtcbiAgICAgIGlmICh1aVN0YXRlMiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHNldFVJU3RhdGUodWlTdGF0ZTIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVsdGEgPSBhd2FpdCBhaVN0YXRlRGVsdGE7XG4gICAgICBpZiAoZGVsdGEgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBwYXRjaGVkQWlTdGF0ZSA9IGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShhaVN0YXRlU25hcHNob3QpLFxuICAgICAgICAgIGRlbHRhXG4gICAgICAgICk7XG4gICAgICAgIHNldEFJU3RhdGUocGF0Y2hlZEFpU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFt3cmFwcGVkU3luY1VJU3RhdGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKEludGVybmFsQUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyLCB7IHZhbHVlOiBhaVN0YXRlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIoSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXIsIHsgdmFsdWU6IHVpU3RhdGUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihJbnRlcm5hbEFjdGlvblByb3ZpZGVyLlByb3ZpZGVyLCB7IHZhbHVlOiBjbGllbnRXcmFwcGVkQWN0aW9ucywgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFxuICAgIEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlci5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZTogY2xpZW50V3JhcHBlZFN5bmNVSVN0YXRlQWN0aW9uLFxuICAgICAgY2hpbGRyZW5cbiAgICB9XG4gICkgfSkgfSkgfSk7XG59XG5mdW5jdGlvbiB1c2VVSVN0YXRlKCkge1xuICBjb25zdCBzdGF0ZSA9IFJlYWN0Mi51c2VDb250ZXh0KEludGVybmFsVUlTdGF0ZVByb3ZpZGVyKTtcbiAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYHVzZVVJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci5cIik7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGVcIik7XG4gIH1cbiAgaWYgKHN0YXRlWzBdID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImBpbml0aWFsVUlTdGF0ZWAgbXVzdCBiZSBwcm92aWRlZCB0byBgY3JlYXRlQUlgIG9yIGA8QUk+YFwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB1c2VBSVN0YXRlKC4uLmFyZ3MpIHtcbiAgY29uc3Qgc3RhdGUgPSBSZWFjdDIudXNlQ29udGV4dChJbnRlcm5hbEFJU3RhdGVQcm92aWRlcik7XG4gIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImB1c2VBSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuXCIpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlXCIpO1xuICB9XG4gIGlmIChzdGF0ZVswXSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgaW5pdGlhbEFJU3RhdGVgIG11c3QgYmUgcHJvdmlkZWQgdG8gYGNyZWF0ZUFJYCBvciBgPEFJPmBcIlxuICAgICk7XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoID49IDEgJiYgdHlwZW9mIHN0YXRlWzBdICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJXaGVuIHVzaW5nIGB1c2VBSVN0YXRlYCB3aXRoIGEga2V5LCB0aGUgQUkgc3RhdGUgbXVzdCBiZSBhbiBvYmplY3QuXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gIGNvbnN0IHNldHRlciA9IFJlYWN0Mi51c2VDYWxsYmFjayhcbiAgICB0eXBlb2Yga2V5ID09PSBcInVuZGVmaW5lZFwiID8gc3RhdGVbMV0gOiAobmV3U3RhdGUpID0+IHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG5ld1N0YXRlKSkge1xuICAgICAgICByZXR1cm4gc3RhdGVbMV0oKHMpID0+IHtcbiAgICAgICAgICByZXR1cm4geyAuLi5zLCBba2V5XTogbmV3U3RhdGUoc1trZXldKSB9O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZVsxXSh7IC4uLnN0YXRlWzBdLCBba2V5XTogbmV3U3RhdGUgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBba2V5XVxuICApO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtzdGF0ZVswXVthcmdzWzBdXSwgc2V0dGVyXTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlQWN0aW9ucygpIHtcbiAgY29uc3QgYWN0aW9ucyA9IFJlYWN0Mi51c2VDb250ZXh0KEludGVybmFsQWN0aW9uUHJvdmlkZXIpO1xuICByZXR1cm4gYWN0aW9ucztcbn1cbmZ1bmN0aW9uIHVzZVN5bmNVSVN0YXRlKCkge1xuICBjb25zdCBzeW5jVUlTdGF0ZSA9IFJlYWN0Mi51c2VDb250ZXh0KFxuICAgIEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlclxuICApO1xuICBpZiAoc3luY1VJU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdXNlU3luY1VJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci5cIik7XG4gIH1cbiAgcmV0dXJuIHN5bmNVSVN0YXRlO1xufVxuZXhwb3J0IHtcbiAgSW50ZXJuYWxBSVByb3ZpZGVyLFxuICByZWFkU3RyZWFtYWJsZVZhbHVlLFxuICB1c2VBSVN0YXRlLFxuICB1c2VBY3Rpb25zLFxuICB1c2VTdHJlYW1hYmxlVmFsdWUsXG4gIHVzZVN5bmNVSVN0YXRlLFxuICB1c2VVSVN0YXRlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnNjLXNoYXJlZC5tanMubWFwIl0sIm5hbWVzIjpbInN0YXJ0VHJhbnNpdGlvbiIsInVzZUxheW91dEVmZmVjdCIsInVzZVN0YXRlIiwiU1RSRUFNQUJMRV9WQUxVRV9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUiLCJoYXNSZWFkYWJsZVZhbHVlU2lnbmF0dXJlIiwidmFsdWUiLCJ0eXBlIiwiYXNzZXJ0U3RyZWFtYWJsZVZhbHVlIiwiRXJyb3IiLCJpc1N0cmVhbWFibGVWYWx1ZSIsImhhc1NpZ25hdHVyZSIsInJlYWRTdHJlYW1hYmxlVmFsdWUiLCJzdHJlYW1hYmxlVmFsdWUiLCJhc3luY0l0ZXJhdG9yIiwicm93IiwiY3VyciIsImRvbmUiLCJpbml0aWFsIiwibmV4dCIsImVycm9yIiwiZGlmZiIsInVzZVN0cmVhbWFibGVWYWx1ZSIsInNldEN1cnIiLCJzZXRFcnJvciIsInBlbmRpbmciLCJzZXRQZW5kaW5nIiwiY2FuY2VsbGVkIiwiaXRlcmF0b3IiLCJlIiwiUmVhY3QyIiwianNvbmRpZmZwYXRjaCIsIlN1c3BlbnNlIiwiRnJhZ21lbnQiLCJqc3giLCJqc3hzIiwiUiIsImMiLCJuIiwiY2h1bmsiLCJhcHBlbmQiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwiaXNGdW5jdGlvbiIsIngiLCJqc3gyIiwiSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIiLCJjcmVhdGVDb250ZXh0IiwiSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIiLCJJbnRlcm5hbEFjdGlvblByb3ZpZGVyIiwiSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyIiwiSW50ZXJuYWxBSVByb3ZpZGVyIiwiaW5pdGlhbFVJU3RhdGUiLCJpbml0aWFsQUlTdGF0ZSIsImluaXRpYWxBSVN0YXRlUGF0Y2giLCJ3cmFwcGVkQWN0aW9ucyIsIndyYXBwZWRTeW5jVUlTdGF0ZSIsInVpU3RhdGUiLCJzZXRVSVN0YXRlIiwicmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoIiwidXNlIiwidXNlTWVtbyIsInBhdGNoIiwiY2xvbmUiLCJhaVN0YXRlIiwic2V0QUlTdGF0ZSIsImFpU3RhdGVSZWYiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiY2xpZW50V3JhcHBlZEFjdGlvbnMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJtYXAiLCJrZXkiLCJhY3Rpb24iLCJhcmdzIiwiYWlTdGF0ZVNuYXBzaG90IiwiYWlTdGF0ZURlbHRhIiwicmVzdWx0IiwiZGVsdGEiLCJjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb24iLCJ1aVN0YXRlMiIsInBhdGNoZWRBaVN0YXRlIiwiUHJvdmlkZXIiLCJ1c2VVSVN0YXRlIiwic3RhdGUiLCJ1c2VDb250ZXh0IiwiQXJyYXkiLCJpc0FycmF5IiwidXNlQUlTdGF0ZSIsImxlbmd0aCIsInNldHRlciIsInVzZUNhbGxiYWNrIiwibmV3U3RhdGUiLCJzIiwidXNlQWN0aW9ucyIsImFjdGlvbnMiLCJ1c2VTeW5jVUlTdGF0ZSIsInN5bmNVSVN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_3___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$ACTION_0: () => (/* binding */ $$ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   experimental_streamUI: () => (/* binding */ experimental_streamUI),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(rsc)/./node_modules/next/dist/server/app-render/action-encryption.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jsondiffpatch */ \"(rsc)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"784eaeca1c316aa5d98fd936c53125000c396aeb\":\"$$ACTION_0\"} */ \n\n\n\n// rsc/utils.tsx\n\n\nfunction createResolvablePromise() {\n    let resolve, reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspensedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\nvar isFunction = (x)=>typeof x === \"function\";\nvar consumeStream = async (stream)=>{\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n};\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: state,\n        originalState: state,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a = store.options).onSetAIState) == null ? void 0 : _b.call(_a, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/streamable.tsx\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.convertBase64ToUint8Array)(content);\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidDataContentError({\n        content\n    });\n}\n// core/prompt/convert-to-language-model-prompt.ts\nfunction convertToLanguageModelPrompt(prompt) {\n    const languageModelMessages = [];\n    if (prompt.system != null) {\n        languageModelMessages.push({\n            role: \"system\",\n            content: prompt.system\n        });\n    }\n    switch(prompt.type){\n        case \"prompt\":\n            {\n                languageModelMessages.push({\n                    role: \"user\",\n                    content: [\n                        {\n                            type: \"text\",\n                            text: prompt.prompt\n                        }\n                    ]\n                });\n                break;\n            }\n        case \"messages\":\n            {\n                languageModelMessages.push(...prompt.messages.map((message)=>{\n                    switch(message.role){\n                        case \"user\":\n                            {\n                                if (typeof message.content === \"string\") {\n                                    return {\n                                        role: \"user\",\n                                        content: [\n                                            {\n                                                type: \"text\",\n                                                text: message.content\n                                            }\n                                        ]\n                                    };\n                                }\n                                return {\n                                    role: \"user\",\n                                    content: message.content.map((part)=>{\n                                        var _a;\n                                        switch(part.type){\n                                            case \"text\":\n                                                {\n                                                    return part;\n                                                }\n                                            case \"image\":\n                                                {\n                                                    if (part.image instanceof URL) {\n                                                        return {\n                                                            type: \"image\",\n                                                            image: part.image,\n                                                            mimeType: part.mimeType\n                                                        };\n                                                    }\n                                                    const imageUint8 = convertDataContentToUint8Array(part.image);\n                                                    return {\n                                                        type: \"image\",\n                                                        image: imageUint8,\n                                                        mimeType: (_a = part.mimeType) != null ? _a : detectImageMimeType(imageUint8)\n                                                    };\n                                                }\n                                        }\n                                    })\n                                };\n                            }\n                        case \"assistant\":\n                            {\n                                if (typeof message.content === \"string\") {\n                                    return {\n                                        role: \"assistant\",\n                                        content: [\n                                            {\n                                                type: \"text\",\n                                                text: message.content\n                                            }\n                                        ]\n                                    };\n                                }\n                                return {\n                                    role: \"assistant\",\n                                    content: message.content\n                                };\n                            }\n                        case \"tool\":\n                            {\n                                return message;\n                            }\n                    }\n                }));\n                break;\n            }\n        default:\n            {\n                const _exhaustiveCheck = prompt;\n                throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n            }\n    }\n    return languageModelMessages;\n}\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    return prompt.prompt != null ? {\n        type: \"prompt\",\n        prompt: prompt.prompt,\n        messages: void 0,\n        system: prompt.system\n    } : {\n        type: \"messages\",\n        prompt: void 0,\n        messages: prompt.messages,\n        // only possible case bc of checks above\n        system: prompt.system\n    };\n}\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({ maxTokens, temperature, topP, presencePenalty, frequencyPenalty, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        presencePenalty,\n        frequencyPenalty,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/util/convert-zod-to-json-schema.ts\n\nfunction convertZodToJSONSchema(zodSchema) {\n    return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(zodSchema);\n}\n// core/util/retry-with-exponential-backoff.ts\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n    return new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n    const streamPart = streamParts.find((part)=>part.name === type);\n    if (!streamPart) {\n        throw new Error(`Invalid stream part type: ${type}`);\n    }\n    return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_9__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a;\n            await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a = choice.delta) == null ? void 0 : _a.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = createChunkDecoder();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode(formatStreamPart(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode(formatStreamPart(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/streamable.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspensedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    return {\n        /**\n     * The value of the streamable UI. This can be returned from a Server Action and received by the client.\n     */ value: row,\n        /**\n     * This method updates the current UI node. It takes a new UI node and replaces the old one.\n     */ update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to append a new UI node to the end of the old one.\n     * Once appended a new UI node, the previous UI node cannot be updated anymore.\n     *\n     * @example\n     * ```jsx\n     * const ui = createStreamableUI(<div>hello</div>)\n     * ui.append(<div>world</div>)\n     *\n     * // The UI node will be:\n     * // <>\n     * //   <div>hello</div>\n     * //   <div>world</div>\n     * // </>\n     * ```\n     */ append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to signal that there is an error in the UI stream.\n     * It will be thrown on the client side and caught by the nearest error boundary component.\n     */ error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n        },\n        /**\n     * This method marks the UI node as finalized. You can either call it without any parameters or with a new UI node as the final state.\n     * Once called, the UI node cannot be updated or appended anymore.\n     *\n     * This method is always **required** to be called, otherwise the response will be stuck in a loading state.\n     */ done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n        }\n    };\n}\nfunction createStreamableValue(initialValue) {\n    let closed = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    return {\n        /**\n     * The value of the streamable. This can be returned from a Server Action and\n     * received by the client. To read the streamed values, use the\n     * `readStreamableValue` or `useStreamableValue` APIs.\n     */ get value () {\n            return createWrapped(true);\n        },\n        /**\n     * This method updates the current value with a new one.\n     */ update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return;\n            }\n            resolvable.resolve({});\n        }\n    };\n}\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name, { description, parameters }])=>{\n        return {\n            name,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a = options.functions) == null ? void 0 : _a[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a = options.tools) == null ? void 0 : _a[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n\nvar defaultTextRenderer = ({ content })=>content;\nasync function experimental_streamUI({ model, tools, system, prompt, messages, maxRetries, abortSignal, initial, text, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `experimental_streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `experimental_streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `experimental_streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `experimental_streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(...args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n    });\n    const result = await retry(()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool])=>({\n                        type: \"function\",\n                        name,\n                        description: tool.description,\n                        parameters: convertZodToJSONSchema(tool.parameters)\n                    }))\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: convertToLanguageModelPrompt(validatedPrompt),\n            abortSignal\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            handleRender([\n                                {\n                                    content,\n                                    done: false,\n                                    delta: value.textDelta\n                                }\n                            ], textRender, ui);\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            handleRender([\n                                parseResult.value,\n                                {\n                                    toolName,\n                                    toolCallId: value.toolCallId\n                                }\n                            ], tool.generate, ui);\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {}\n                }\n            }\n            if (hasToolCall) {\n                await finished;\n                ui.done();\n            } else {\n                handleRender([\n                    {\n                        content,\n                        done: true\n                    }\n                ], textRender, ui);\n                await finished;\n                ui.done();\n            }\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/provider.tsx\n\n\n\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(\"784eaeca1c316aa5d98fd936c53125000c396aeb\", $$ACTION_0);\nasync function $$ACTION_0({ action, options }, state, ...args) {\n    return await withAIState({\n        state,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n}\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name in actions){\n        wrappedActions[name] = wrapAction(actions[name], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_3__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a = props.initialUIState) != null ? _a : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_10__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNlcnZlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtQkFBbUI7OztBQUM2QjtBQUNEO0FBRS9DLGdCQUFnQjtBQUNpQjtBQUN1QjtBQUN4RCxTQUFTTTtJQUNQLElBQUlDLFNBQVNDO0lBQ2IsTUFBTUMsVUFBVSxJQUFJQyxRQUFRLENBQUNDLEtBQUtDO1FBQ2hDTCxVQUFVSTtRQUNWSCxTQUFTSTtJQUNYO0lBQ0EsT0FBTztRQUNMSDtRQUNBRjtRQUNBQztJQUNGO0FBQ0Y7QUFDQSxJQUFJSyxJQUFJO0lBQ04sT0FBTyxFQUNMQyxDQUFDLEVBQ0QsVUFBVTtJQUNWQyxDQUFDLEVBRUY7UUFDQyxNQUFNQyxRQUFRLE1BQU1EO1FBQ3BCLElBQUlDLE1BQU1DLElBQUksRUFBRTtZQUNkLE9BQU9ELE1BQU1FLEtBQUs7UUFDcEI7UUFDQSxJQUFJRixNQUFNRyxNQUFNLEVBQUU7WUFDaEIsT0FBTyxhQUFhLEdBQUdkLHVEQUFJQSxDQUFDRix1REFBUUEsRUFBRTtnQkFBRWlCLFVBQVU7b0JBQ2hETjtvQkFDQSxhQUFhLEdBQUdWLHNEQUFHQSxDQUFDRiwyQ0FBUUEsRUFBRTt3QkFBRW1CLFVBQVVMLE1BQU1FLEtBQUs7d0JBQUVFLFVBQVUsYUFBYSxHQUFHaEIsc0RBQUdBLENBQUNTLEdBQUc7NEJBQUVDLEdBQUdFLE1BQU1FLEtBQUs7NEJBQUVILEdBQUdDLE1BQU1NLElBQUk7d0JBQUM7b0JBQUc7aUJBQzVIO1lBQUM7UUFDSjtRQUNBLE9BQU8sYUFBYSxHQUFHbEIsc0RBQUdBLENBQUNGLDJDQUFRQSxFQUFFO1lBQUVtQixVQUFVTCxNQUFNRSxLQUFLO1lBQUVFLFVBQVUsYUFBYSxHQUFHaEIsc0RBQUdBLENBQUNTLEdBQUc7Z0JBQUVDLEdBQUdFLE1BQU1FLEtBQUs7Z0JBQUVILEdBQUdDLE1BQU1NLElBQUk7WUFBQztRQUFHO0lBQ3BJO0NBQ0QsQ0FBQyxF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V0FBV00sY0FBYyxDQUFDLEtBQUssS0FBSztJQUM5RSxNQUFNRyxLQUFLLE9BQU9DO1FBQ2hCLElBQUlsVixJQUFJQztRQUNSLElBQUksdU1BQW9Ca1UsRUFBRTtZQUN4QixNQUFNLElBQUl4VixNQUNSO1FBRUo7UUFDQSxJQUFJd1csVUFBVSxDQUFDblYsS0FBS2tWLE1BQU1MLGNBQWMsS0FBSyxPQUFPN1UsS0FBSzZVO1FBQ3pELElBQUlPLFVBQVUsQ0FBQ25WLEtBQUtpVixNQUFNTixjQUFjLEtBQUssT0FBTzNVLEtBQUsyVTtRQUN6RCxJQUFJUyxlQUFlLEtBQUs7UUFDeEIsSUFBSUwsb0JBQW9CO1lBQ3RCLE1BQU0sQ0FBQ00saUJBQWlCQyxXQUFXLEdBQUcsTUFBTVAsbUJBQW1CSTtZQUMvRCxJQUFJRyxlQUFlLEtBQUssR0FBRztnQkFDekJGLGVBQWVDO2dCQUNmSCxVQUFVSTtZQUNaO1FBQ0Y7UUFDQSxPQUFPLGFBQWEsR0FBR2xCLHNEQUFJQSxDQUN6QkQsZ0VBQWtCQSxFQUNsQjtZQUNFVztZQUNBQztZQUNBSCxnQkFBZ0JNO1lBQ2hCUCxnQkFBZ0JRO1lBQ2hCSSxxQkFBcUJIO1lBQ3JCNVgsVUFBVXlYLE1BQU16WCxRQUFRO1FBQzFCO0lBRUo7SUFDQSxPQUFPd1g7QUFDVDtBQVNFLENBQ0YsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FpL3JzYy9kaXN0L3JzYy1zZXJ2ZXIubWpzP2I5N2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcnNjL2FpLXN0YXRlLnRzeFxuaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2UgfSBmcm9tIFwiYXN5bmNfaG9va3NcIjtcbmltcG9ydCAqIGFzIGpzb25kaWZmcGF0Y2ggZnJvbSBcImpzb25kaWZmcGF0Y2hcIjtcblxuLy8gcnNjL3V0aWxzLnRzeFxuaW1wb3J0IHsgU3VzcGVuc2UgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEZyYWdtZW50LCBqc3gsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZSwgcmVqZWN0O1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZSxcbiAgICByZWplY3RcbiAgfTtcbn1cbnZhciBSID0gW1xuICBhc3luYyAoe1xuICAgIGMsXG4gICAgLy8gY3VycmVudFxuICAgIG5cbiAgICAvLyBuZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBjaHVuayA9IGF3YWl0IG47XG4gICAgaWYgKGNodW5rLmRvbmUpIHtcbiAgICAgIHJldHVybiBjaHVuay52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGNodW5rLmFwcGVuZCkge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAgIGMsXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goU3VzcGVuc2UsIHsgZmFsbGJhY2s6IGNodW5rLnZhbHVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChSLCB7IGM6IGNodW5rLnZhbHVlLCBuOiBjaHVuay5uZXh0IH0pIH0pXG4gICAgICBdIH0pO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChTdXNwZW5zZSwgeyBmYWxsYmFjazogY2h1bmsudmFsdWUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFIsIHsgYzogY2h1bmsudmFsdWUsIG46IGNodW5rLm5leHQgfSkgfSk7XG4gIH1cbl1bMF07XG5mdW5jdGlvbiBjcmVhdGVTdXNwZW5zZWRDaHVuayhpbml0aWFsVmFsdWUpIHtcbiAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gIHJldHVybiB7XG4gICAgcm93OiAvKiBAX19QVVJFX18gKi8ganN4KFN1c3BlbnNlLCB7IGZhbGxiYWNrOiBpbml0aWFsVmFsdWUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFIsIHsgYzogaW5pdGlhbFZhbHVlLCBuOiBwcm9taXNlIH0pIH0pLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0XG4gIH07XG59XG52YXIgaXNGdW5jdGlvbiA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xudmFyIGNvbnN1bWVTdHJlYW0gPSBhc3luYyAoc3RyZWFtKSA9PiB7XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpXG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLy8gcnNjL2FpLXN0YXRlLnRzeFxudmFyIGFzeW5jQUlTdGF0ZVN0b3JhZ2UgPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2UoKTtcbmZ1bmN0aW9uIGdldEFJU3RhdGVTdG9yZU9yVGhyb3cobWVzc2FnZSkge1xuICBjb25zdCBzdG9yZSA9IGFzeW5jQUlTdGF0ZVN0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgaWYgKCFzdG9yZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gc3RvcmU7XG59XG5mdW5jdGlvbiB3aXRoQUlTdGF0ZSh7IHN0YXRlLCBvcHRpb25zIH0sIGZuKSB7XG4gIHJldHVybiBhc3luY0FJU3RhdGVTdG9yYWdlLnJ1bihcbiAgICB7XG4gICAgICBjdXJyZW50U3RhdGU6IHN0YXRlLFxuICAgICAgb3JpZ2luYWxTdGF0ZTogc3RhdGUsXG4gICAgICBzZWFsZWQ6IGZhbHNlLFxuICAgICAgb3B0aW9uc1xuICAgIH0sXG4gICAgZm5cbiAgKTtcbn1cbmZ1bmN0aW9uIGdldEFJU3RhdGVEZWx0YVByb21pc2UoKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcIkludGVybmFsIGVycm9yIG9jY3VycmVkLlwiKTtcbiAgcmV0dXJuIHN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlO1xufVxuZnVuY3Rpb24gc2VhbE11dGFibGVBSVN0YXRlKCkge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coXCJJbnRlcm5hbCBlcnJvciBvY2N1cnJlZC5cIik7XG4gIHN0b3JlLnNlYWxlZCA9IHRydWU7XG59XG5mdW5jdGlvbiBnZXRBSVN0YXRlKC4uLmFyZ3MpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KFxuICAgIFwiYGdldEFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhbiBBSSBBY3Rpb24uXCJcbiAgKTtcbiAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW4ndCBnZXQgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAga2V5XG4gICAgICAgICl9XCIgZmllbGQgZnJvbSB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZVtrZXldO1xuICB9XG4gIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGU7XG59XG5mdW5jdGlvbiBnZXRNdXRhYmxlQUlTdGF0ZSguLi5hcmdzKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcbiAgICBcImBnZXRNdXRhYmxlQUlTdGF0ZWAgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGFuIEFJIEFjdGlvbi5cIlxuICApO1xuICBpZiAoc3RvcmUuc2VhbGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgZ2V0TXV0YWJsZUFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIGJlZm9yZSByZXR1cm5pbmcgZnJvbSBhbiBBSSBBY3Rpb24uIFBsZWFzZSBtb3ZlIGl0IHRvIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIEFjdGlvbidzIGZ1bmN0aW9uIGJvZHkuXCJcbiAgICApO1xuICB9XG4gIGlmICghc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2UpIHtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2UgPSBwcm9taXNlO1xuICAgIHN0b3JlLm11dGF0aW9uRGVsdGFSZXNvbHZlID0gcmVzb2x2ZTtcbiAgfVxuICBmdW5jdGlvbiBkb1VwZGF0ZShuZXdTdGF0ZSwgZG9uZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgY2FuJ3QgbW9kaWZ5IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX1cIiBmaWVsZCBvZiB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZSkpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dID0gbmV3U3RhdGUoc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlKHN0b3JlLmN1cnJlbnRTdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dID0gbmV3U3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgKF9iID0gKF9hID0gc3RvcmUub3B0aW9ucykub25TZXRBSVN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAga2V5OiBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzWzBdIDogdm9pZCAwLFxuICAgICAgc3RhdGU6IHN0b3JlLmN1cnJlbnRTdGF0ZSxcbiAgICAgIGRvbmVcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtdXRhYmxlU3RhdGUgPSB7XG4gICAgZ2V0OiAoKSA9PiB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFlvdSBjYW4ndCBnZXQgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKX1cIiBmaWVsZCBmcm9tIHRoZSBBSSBzdGF0ZSBiZWNhdXNlIGl0J3Mgbm90IGFuIG9iamVjdC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUobmV3QUlTdGF0ZSkge1xuICAgICAgZG9VcGRhdGUobmV3QUlTdGF0ZSwgZmFsc2UpO1xuICAgIH0sXG4gICAgZG9uZTogZnVuY3Rpb24gZG9uZSguLi5kb25lQXJncykge1xuICAgICAgaWYgKGRvbmVBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZG9VcGRhdGUoZG9uZUFyZ3NbMF0sIHRydWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVsdGEgPSBqc29uZGlmZnBhdGNoLmRpZmYoc3RvcmUub3JpZ2luYWxTdGF0ZSwgc3RvcmUuY3VycmVudFN0YXRlKTtcbiAgICAgIHN0b3JlLm11dGF0aW9uRGVsdGFSZXNvbHZlKGRlbHRhKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBtdXRhYmxlU3RhdGU7XG59XG5cbi8vIHJzYy9zdHJlYW1hYmxlLnRzeFxuaW1wb3J0IHpvZFRvSnNvblNjaGVtYTIgZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuXG4vLyBjb3JlL3V0aWwvZGV0ZWN0LWltYWdlLW1pbWV0eXBlLnRzXG52YXIgbWltZVR5cGVTaWduYXR1cmVzID0gW1xuICB7IG1pbWVUeXBlOiBcImltYWdlL2dpZlwiLCBieXRlczogWzcxLCA3MywgNzBdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvcG5nXCIsIGJ5dGVzOiBbMTM3LCA4MCwgNzgsIDcxXSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL2pwZWdcIiwgYnl0ZXM6IFsyNTUsIDIxNl0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS93ZWJwXCIsIGJ5dGVzOiBbODIsIDczLCA3MCwgNzBdIH1cbl07XG5mdW5jdGlvbiBkZXRlY3RJbWFnZU1pbWVUeXBlKGltYWdlKSB7XG4gIGZvciAoY29uc3QgeyBieXRlcywgbWltZVR5cGUgfSBvZiBtaW1lVHlwZVNpZ25hdHVyZXMpIHtcbiAgICBpZiAoaW1hZ2UubGVuZ3RoID49IGJ5dGVzLmxlbmd0aCAmJiBieXRlcy5ldmVyeSgoYnl0ZSwgaW5kZXgpID0+IGltYWdlW2luZGV4XSA9PT0gYnl0ZSkpIHtcbiAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gY29yZS9wcm9tcHQvZGF0YS1jb250ZW50LnRzXG5pbXBvcnQgeyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCkge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY29udmVydEJhc2U2NFRvVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2NvbnZlcnQtdG8tbGFuZ3VhZ2UtbW9kZWwtcHJvbXB0LnRzXG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHByb21wdCkge1xuICBjb25zdCBsYW5ndWFnZU1vZGVsTWVzc2FnZXMgPSBbXTtcbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCkge1xuICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHsgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogcHJvbXB0LnN5c3RlbSB9KTtcbiAgfVxuICBzd2l0Y2ggKHByb21wdC50eXBlKSB7XG4gICAgY2FzZSBcInByb21wdFwiOiB7XG4gICAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogcHJvbXB0LnByb21wdCB9XVxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIm1lc3NhZ2VzXCI6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKFxuICAgICAgICAuLi5wcm9tcHQubWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnJvbGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoXG4gICAgICAgICAgICAgICAgICAocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5pbWFnZSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogcGFydC5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogcGFydC5taW1lVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VVaW50OCA9IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5pbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlVWludDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiAoX2EgPSBwYXJ0Lm1pbWVUeXBlKSAhPSBudWxsID8gX2EgOiBkZXRlY3RJbWFnZU1pbWVUeXBlKGltYWdlVWludDgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHsgcm9sZTogXCJhc3Npc3RhbnRcIiwgY29udGVudDogbWVzc2FnZS5jb250ZW50IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHByb21wdDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcHJvbXB0IHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxhbmd1YWdlTW9kZWxNZXNzYWdlcztcbn1cblxuLy8gY29yZS9wcm9tcHQvZ2V0LXZhbGlkYXRlZC1wcm9tcHQudHNcbmltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZWRQcm9tcHQocHJvbXB0KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWVcIlxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwcm9tcHQucHJvbXB0ICE9IG51bGwgPyB7XG4gICAgdHlwZTogXCJwcm9tcHRcIixcbiAgICBwcm9tcHQ6IHByb21wdC5wcm9tcHQsXG4gICAgbWVzc2FnZXM6IHZvaWQgMCxcbiAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgfSA6IHtcbiAgICB0eXBlOiBcIm1lc3NhZ2VzXCIsXG4gICAgcHJvbXB0OiB2b2lkIDAsXG4gICAgbWVzc2FnZXM6IHByb21wdC5tZXNzYWdlcyxcbiAgICAvLyBvbmx5IHBvc3NpYmxlIGNhc2UgYmMgb2YgY2hlY2tzIGFib3ZlXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH07XG59XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncy50c1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gcHJlcGFyZUNhbGxTZXR0aW5ncyh7XG4gIG1heFRva2VucyxcbiAgdGVtcGVyYXR1cmUsXG4gIHRvcFAsXG4gIHByZXNlbmNlUGVuYWx0eSxcbiAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgc2VlZCxcbiAgbWF4UmV0cmllc1xufSkge1xuICBpZiAobWF4VG9rZW5zICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4VG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhUb2tlbnMgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4VG9rZW5zIG11c3QgYmUgPj0gMVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRlbXBlcmF0dXJlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidGVtcGVyYXR1cmVcIixcbiAgICAgICAgdmFsdWU6IHRlbXBlcmF0dXJlLFxuICAgICAgICBtZXNzYWdlOiBcInRlbXBlcmF0dXJlIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0b3BQICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcFAgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0b3BQXCIsXG4gICAgICAgIHZhbHVlOiB0b3BQLFxuICAgICAgICBtZXNzYWdlOiBcInRvcFAgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJwcmVzZW5jZVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJwcmVzZW5jZVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImZyZXF1ZW5jeVBlbmFsdHlcIixcbiAgICAgICAgdmFsdWU6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwiZnJlcXVlbmN5UGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2VlZFwiLFxuICAgICAgICB2YWx1ZTogc2VlZCxcbiAgICAgICAgbWVzc2FnZTogXCJzZWVkIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlID49IDBcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWF4VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSAhPSBudWxsID8gdGVtcGVyYXR1cmUgOiAwLFxuICAgIHRvcFAsXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc2VlZCxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzICE9IG51bGwgPyBtYXhSZXRyaWVzIDogMlxuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvY29udmVydC16b2QtdG8tanNvbi1zY2hlbWEudHNcbmltcG9ydCB6b2RUb0pzb25TY2hlbWEgZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuZnVuY3Rpb24gY29udmVydFpvZFRvSlNPTlNjaGVtYSh6b2RTY2hlbWEpIHtcbiAgcmV0dXJuIHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEpO1xufVxuXG4vLyBjb3JlL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IsIFJldHJ5RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3V0aWwvZGVsYXkudHNcbmFzeW5jIGZ1bmN0aW9uIGRlbGF5KGRlbGF5SW5Ncykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlJbk1zKSk7XG59XG5cbi8vIGNvcmUvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbnZhciByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYgPSAoe1xuICBtYXhSZXRyaWVzID0gMixcbiAgaW5pdGlhbERlbGF5SW5NcyA9IDJlMyxcbiAgYmFja29mZkZhY3RvciA9IDJcbn0gPSB7fSkgPT4gYXN5bmMgKGYpID0+IF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXM6IGluaXRpYWxEZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0pO1xuYXN5bmMgZnVuY3Rpb24gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSwgZXJyb3JzID0gW10pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246IFwibWF4UmV0cmllc0V4Y2VlZGVkXCIsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgQVBJQ2FsbEVycm9yLmlzQVBJQ2FsbEVycm9yKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogXCJlcnJvck5vdFJldHJ5YWJsZVwiLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzaGFyZWQvc3RyZWFtLXBhcnRzLnRzXG52YXIgdGV4dFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMFwiLFxuICBuYW1lOiBcInRleHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjFcIixcbiAgbmFtZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZ1bmN0aW9uX2NhbGxcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8ICEoXCJuYW1lXCIgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHwgIShcImFyZ3VtZW50c1wiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMlwiLFxuICBuYW1lOiBcImRhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBlcnJvclN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiM1wiLFxuICBuYW1lOiBcImVycm9yXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI0XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB2YWx1ZSkgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImNvbnRlbnRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmlkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHwgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAoaXRlbSkgPT4gaXRlbSAhPSBudWxsICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGl0ZW0gJiYgaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtICYmIGl0ZW0udGV4dCAhPSBudWxsICYmIHR5cGVvZiBpdGVtLnRleHQgPT09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIGl0ZW0udGV4dCAmJiB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNVwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidGhyZWFkSWRcIiBpbiB2YWx1ZSkgfHwgIShcIm1lc3NhZ2VJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudGhyZWFkSWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0aHJlYWRJZFwiIGFuZCBcIm1lc3NhZ2VJZFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHRocmVhZElkOiB2YWx1ZS50aHJlYWRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI2XCIsXG4gIG5hbWU6IFwiZGF0YV9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImRhdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJkYXRhXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZGF0YV9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJyb2xlXCIgYW5kIFwiZGF0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI3XCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sX2NhbGxzXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sX2NhbGxzICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLnRvb2xfY2FsbHMgPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZS50b29sX2NhbGxzKSB8fCB2YWx1ZS50b29sX2NhbGxzLnNvbWUoXG4gICAgICAodGMpID0+IHRjID09IG51bGwgfHwgdHlwZW9mIHRjICE9PSBcIm9iamVjdFwiIHx8ICEoXCJpZFwiIGluIHRjKSB8fCB0eXBlb2YgdGMuaWQgIT09IFwic3RyaW5nXCIgfHwgIShcInR5cGVcIiBpbiB0YykgfHwgdHlwZW9mIHRjLnR5cGUgIT09IFwic3RyaW5nXCIgfHwgIShcImZ1bmN0aW9uXCIgaW4gdGMpIHx8IHRjLmZ1bmN0aW9uID09IG51bGwgfHwgdHlwZW9mIHRjLmZ1bmN0aW9uICE9PSBcIm9iamVjdFwiIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB0Yy5mdW5jdGlvbikgfHwgdHlwZW9mIHRjLmZ1bmN0aW9uLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIlxuICAgICkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsc1wiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFRvb2xDYWxsUGF5bG9hZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxzXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI4XCIsXG4gIG5hbWU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIHN0cmVhbVBhcnRzID0gW1xuICB0ZXh0U3RyZWFtUGFydCxcbiAgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgZGF0YVN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnRcbl07XG52YXIgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0XG59O1xudmFyIFN0cmVhbVN0cmluZ1ByZWZpeGVzID0ge1xuICBbdGV4dFN0cmVhbVBhcnQubmFtZV06IHRleHRTdHJlYW1QYXJ0LmNvZGUsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0Lm5hbWVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhU3RyZWFtUGFydC5uYW1lXTogZGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2Vycm9yU3RyZWFtUGFydC5uYW1lXTogZXJyb3JTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQubmFtZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZVxufTtcbnZhciB2YWxpZENvZGVzID0gc3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGUpO1xudmFyIHBhcnNlU3RyZWFtUGFydCA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cbiAgY29uc3QgY29kZSA9IHByZWZpeDtcbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuZnVuY3Rpb24gZm9ybWF0U3RyZWFtUGFydCh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZCgocGFydCkgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cbmA7XG59XG5cbi8vIHNoYXJlZC91dGlscy50c1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKGNvbXBsZXgpIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBpZiAoIWNvbXBsZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIGlmICghY2h1bmspXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKTtcbiAgICByZXR1cm4gZGVjb2RlZC5tYXAocGFyc2VTdHJlYW1QYXJ0KS5maWx0ZXIoQm9vbGVhbik7XG4gIH07XG59XG5cbi8vIHN0cmVhbXMvYWktc3RyZWFtLnRzXG5pbXBvcnQge1xuICBjcmVhdGVQYXJzZXJcbn0gZnJvbSBcImV2ZW50c291cmNlLXBhcnNlclwiO1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpIHtcbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGV2ZW50U291cmNlUGFyc2VyO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIgPSBjcmVhdGVQYXJzZXIoXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCAmJiBldmVudC50eXBlID09PSBcImV2ZW50XCIgJiYgZXZlbnQuZGF0YSA9PT0gXCJbRE9ORV1cIiB8fCAvLyBSZXBsaWNhdGUgZG9lc24ndCBzZW5kIFtET05FXSBidXQgZG9lcyBzZW5kIGEgJ2RvbmUnIGV2ZW50XG4gICAgICAgICAgLy8gQHNlZSBodHRwczovL3JlcGxpY2F0ZS5jb20vZG9jcy9zdHJlYW1pbmdcbiAgICAgICAgICBldmVudC5ldmVudCA9PT0gXCJkb25lXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IGN1c3RvbVBhcnNlciA/IGN1c3RvbVBhcnNlcihldmVudC5kYXRhLCB7XG4gICAgICAgICAgICAgIGV2ZW50OiBldmVudC5ldmVudFxuICAgICAgICAgICAgfSkgOiBldmVudC5kYXRhO1xuICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UpXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyLmZlZWQodGV4dERlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICBjb25zdCBjYWxsYmFja3MgPSBjYiB8fCB7fTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KVxuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgIH0sXG4gICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpKTtcbiAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBjb250ZW50O1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRva2VuKVxuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Ub2tlbihjb250ZW50KTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25UZXh0ICYmIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRleHQobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgIGNvbnN0IGlzT3BlbkFJQ2FsbGJhY2tzID0gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiAhaXNPcGVuQUlDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gIHJldHVybiBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbFwiIGluIGNhbGxiYWNrcztcbn1cbmZ1bmN0aW9uIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCkge1xuICBsZXQgaXNTdHJlYW1TdGFydCA9IHRydWU7XG4gIHJldHVybiAodGV4dCkgPT4ge1xuICAgIGlmIChpc1N0cmVhbVN0YXJ0KSB7XG4gICAgICB0ZXh0ID0gdGV4dC50cmltU3RhcnQoKTtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICBpc1N0cmVhbVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuZnVuY3Rpb24gQUlTdHJlYW0ocmVzcG9uc2UsIGN1c3RvbVBhcnNlciwgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JUZXh0fWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKFwiUmVzcG9uc2UgZXJyb3I6IE5vIHJlc3BvbnNlIGJvZHlcIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VCb2R5U3RyZWFtID0gcmVzcG9uc2UuYm9keSB8fCBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG4gIHJldHVybiByZXNwb25zZUJvZHlTdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShpdGVyYWJsZSkge1xuICBsZXQgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgZWxzZVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgIH0sXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgdmFyIF9hO1xuICAgICAgYXdhaXQgKChfYSA9IGl0LnJldHVybikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoaXQsIHJlYXNvbikpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtLWRhdGEudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBtZXNzYWdlKSkpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvb3BlbmFpLXN0cmVhbS50c1xuZnVuY3Rpb24gcGFyc2VPcGVuQUlTdHJlYW0oKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICByZXR1cm4gKGRhdGEpID0+IGV4dHJhY3QoSlNPTi5wYXJzZShkYXRhKSk7XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW0pIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIGZvciBhd2FpdCAobGV0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChcInByb21wdEZpbHRlclJlc3VsdHNcIiBpbiBjaHVuaykge1xuICAgICAgY2h1bmsgPSB7XG4gICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgY3JlYXRlZDogY2h1bmsuY3JlYXRlZC5nZXREYXRlKCksXG4gICAgICAgIG9iamVjdDogY2h1bmsub2JqZWN0LFxuICAgICAgICAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgbW9kZWw6IGNodW5rLm1vZGVsLFxuICAgICAgICAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgY2hvaWNlczogY2h1bmsuY2hvaWNlcy5tYXAoKGNob2ljZSkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsdGE6IHtcbiAgICAgICAgICAgICAgY29udGVudDogKF9hID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29udGVudCxcbiAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogKF9iID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgICByb2xlOiAoX2MgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yb2xlLFxuICAgICAgICAgICAgICB0b29sX2NhbGxzOiAoKF9lID0gKF9kID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2QudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2UubGVuZ3RoKSA/IChfZyA9IChfZiA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgdHlwZTogdG9vbENhbGwudHlwZVxuICAgICAgICAgICAgICB9KSkgOiB2b2lkIDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5pc2hfcmVhc29uOiBjaG9pY2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgaW5kZXg6IGNob2ljZS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gZXh0cmFjdChjaHVuayk7XG4gICAgaWYgKHRleHQpXG4gICAgICB5aWVsZCB0ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBjaHVua1RvVGV4dCgpIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luO1xuICByZXR1cm4gKGpzb24pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uLCBfbywgX3AsIF9xLCBfcjtcbiAgICBpZiAoaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IChfYSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlbHRhO1xuICAgICAgaWYgKChfYiA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiJHtkZWx0YS5mdW5jdGlvbl9jYWxsLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoX2UgPSAoX2QgPSAoX2MgPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9vbENhbGwgPSBkZWx0YS50b29sX2NhbGxzWzBdO1xuICAgICAgICBpZiAodG9vbENhbGwuaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGB7XCJ0b29sX2NhbGxzXCI6WyB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9mID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZi5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYFwifX0sIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHsoX2cgPSB0b29sQ2FsbC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKF9oID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cygoX2kgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2kuYXJndW1lbnRzKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoX2wgPSAoX2sgPSAoX2ogPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2pbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfay5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9sLmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cygoX28gPSAoX24gPSAoX20gPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX21bMF0pID09IG51bGwgPyB2b2lkIDAgOiBfbi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9vLmFyZ3VtZW50cylcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvblN0cmVhbWluZ0luICYmICgoKF9wID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3AuZmluaXNoX3JlYXNvbikgPT09IFwiZnVuY3Rpb25fY2FsbFwiIHx8ICgoX3EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcS5maW5pc2hfcmVhc29uKSA9PT0gXCJzdG9wXCIpKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX0nXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKF9yID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3IuZmluaXNoX3JlYXNvbikgPT09IFwidG9vbF9jYWxsc1wiKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX1dfSdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50ID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgOiBpc0NvbXBsZXRpb24oanNvbikgPyBqc29uLmNob2ljZXNbMF0udGV4dCA6IFwiXCJcbiAgICApO1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bmspIHtcbiAgICBsZXQgZXNjYXBlZFBhcnRpYWxKc29uID0gYXJndW1lbnRDaHVuay5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIikucmVwbGFjZSgvXFwvL2csIFwiXFxcXC9cIikucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpLnJlcGxhY2UoL1xcZi9nLCBcIlxcXFxmXCIpO1xuICAgIHJldHVybiBgJHtlc2NhcGVkUGFydGlhbEpzb259YDtcbiAgfVxufVxudmFyIF9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wgPSBTeW1ib2woXG4gIFwiaW50ZXJuYWxfb3BlbmFpX2ZuX21lc3NhZ2VzXCJcbik7XG5mdW5jdGlvbiBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoZGF0YSkge1xuICByZXR1cm4gXCJjaG9pY2VzXCIgaW4gZGF0YSAmJiBkYXRhLmNob2ljZXMgJiYgZGF0YS5jaG9pY2VzWzBdICYmIFwiZGVsdGFcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YSkge1xuICByZXR1cm4gXCJjaG9pY2VzXCIgaW4gZGF0YSAmJiBkYXRhLmNob2ljZXMgJiYgZGF0YS5jaG9pY2VzWzBdICYmIFwidGV4dFwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIE9wZW5BSVN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICBjb25zdCBjYiA9IGNhbGxiYWNrcztcbiAgbGV0IHN0cmVhbTtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZShyZXMpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICAgICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgfHwgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkgPyB7XG4gICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgb25GaW5hbDogdm9pZCAwXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgLi4uY2JcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gQUlTdHJlYW0oXG4gICAgICByZXMsXG4gICAgICBwYXJzZU9wZW5BSVN0cmVhbSgpLFxuICAgICAgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHx8IChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpID8ge1xuICAgICAgICAuLi5jYixcbiAgICAgICAgb25GaW5hbDogdm9pZCAwXG4gICAgICB9IDoge1xuICAgICAgICAuLi5jYlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgaWYgKGNiICYmIChjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNhbGxiYWNrcykge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGxldCBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlcyA9IGNhbGxiYWNrc1tfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXSB8fCBbXTtcbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGUoY2h1bmspO1xuICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICBjb25zdCBzaG91bGRIYW5kbGVBc0Z1bmN0aW9uID0gaXNGaXJzdENodW5rICYmIChtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSB8fCBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSk7XG4gICAgICBpZiAoc2hvdWxkSGFuZGxlQXNGdW5jdGlvbikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNGdW5jdGlvblN0cmVhbWluZ0luKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0Q2h1bmsgJiYgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIGxldCBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgXTtcbiAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNQYXlsb2FkID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNQYXlsb2FkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0ge1xuICAgICAgICAgICAgICB0b29sczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgcGF5bG9hZC50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy50b29scy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogdG9vbC5pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnBhcnNlKHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VJbmRleCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKFxuICAgICAgICAgICAgICAgIHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsX2lkLCBmdW5jdGlvbl9uYW1lLCB0b29sX2NhbGxfcmVzdWx0IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLm5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwZW5kIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBpZiBpdCdzIHRoZSBmaXJzdCByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlSW5kZXggPT09IDAgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHBheWxvYWQudG9vbF9jYWxscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGMuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2VuZCB0aGUgYXJndW1lbnRzIGFuIG9iamVjdCB0byB0aGUgdXNlciwgYnV0IGFzIHRoZSBBUEkgZXhwZWN0cyBhIHN0cmluZywgd2UgbmVlZCB0byBzdHJpbmdpZnkgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Yy5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBdIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlc3VsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodG9vbF9jYWxsX3Jlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYWxsaW5nIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOlwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsID8gXCJmdW5jdGlvbl9jYWxsXCIgOiBcInRvb2xfY2FsbHNcIixcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRvIHByZXZlbnQgZG91YmxlLWVuY29kaW5nOlxuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIGZ1bmN0aW9uUmVzcG9uc2UpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IGZ1bmN0aW9uUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLi4uY2FsbGJhY2tzLFxuICAgICAgICAgICAgb25TdGFydDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFja3Mub25GaW5hbCA9IHZvaWQgMDtcbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gb3BlbkFJU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyByc2MvY29uc3RhbnRzLnRzXG52YXIgU1RSRUFNQUJMRV9WQUxVRV9UWVBFID0gU3ltYm9sLmZvcihcInVpLnN0cmVhbWFibGUudmFsdWVcIik7XG52YXIgREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUgPSAxNSAqIDFlMztcblxuLy8gcnNjL3N0cmVhbWFibGUudHN4XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVUkoaW5pdGlhbFZhbHVlKSB7XG4gIGxldCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gIGxldCBjbG9zZWQgPSBmYWxzZTtcbiAgbGV0IHsgcm93LCByZXNvbHZlLCByZWplY3QgfSA9IGNyZWF0ZVN1c3BlbnNlZENodW5rKGluaXRpYWxWYWx1ZSk7XG4gIGZ1bmN0aW9uIGFzc2VydFN0cmVhbShtZXRob2QpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgXCI6IFVJIHN0cmVhbSBpcyBhbHJlYWR5IGNsb3NlZC5cIik7XG4gICAgfVxuICB9XG4gIGxldCB3YXJuaW5nVGltZW91dDtcbiAgZnVuY3Rpb24gd2FyblVuY2xvc2VkU3RyZWFtKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBzdHJlYW1hYmxlIFVJIGhhcyBiZWVuIHNsb3cgdG8gdXBkYXRlLiBUaGlzIG1heSBiZSBhIGJ1ZyBvciBhIHBlcmZvcm1hbmNlIGlzc3VlIG9yIHlvdSBmb3Jnb3QgdG8gY2FsbCBgLmRvbmUoKWAuXCJcbiAgICAgICAgKTtcbiAgICAgIH0sIERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FKTtcbiAgICB9XG4gIH1cbiAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlIFVJLiBUaGlzIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgU2VydmVyIEFjdGlvbiBhbmQgcmVjZWl2ZWQgYnkgdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICB2YWx1ZTogcm93LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGN1cnJlbnQgVUkgbm9kZS4gSXQgdGFrZXMgYSBuZXcgVUkgbm9kZSBhbmQgcmVwbGFjZXMgdGhlIG9sZCBvbmUuXG4gICAgICovXG4gICAgdXBkYXRlKHZhbHVlKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oXCIudXBkYXRlKClcIik7XG4gICAgICBpZiAodmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJlc29sdmUoeyB2YWx1ZTogY3VycmVudFZhbHVlLCBkb25lOiBmYWxzZSwgbmV4dDogcmVzb2x2YWJsZS5wcm9taXNlIH0pO1xuICAgICAgcmVzb2x2ZSA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlamVjdCA9IHJlc29sdmFibGUucmVqZWN0O1xuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGFwcGVuZCBhIG5ldyBVSSBub2RlIHRvIHRoZSBlbmQgb2YgdGhlIG9sZCBvbmUuXG4gICAgICogT25jZSBhcHBlbmRlZCBhIG5ldyBVSSBub2RlLCB0aGUgcHJldmlvdXMgVUkgbm9kZSBjYW5ub3QgYmUgdXBkYXRlZCBhbnltb3JlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc3hcbiAgICAgKiBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSSg8ZGl2PmhlbGxvPC9kaXY+KVxuICAgICAqIHVpLmFwcGVuZCg8ZGl2PndvcmxkPC9kaXY+KVxuICAgICAqXG4gICAgICogLy8gVGhlIFVJIG5vZGUgd2lsbCBiZTpcbiAgICAgKiAvLyA8PlxuICAgICAqIC8vICAgPGRpdj5oZWxsbzwvZGl2PlxuICAgICAqIC8vICAgPGRpdj53b3JsZDwvZGl2PlxuICAgICAqIC8vIDwvPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFwcGVuZCh2YWx1ZSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKFwiLmFwcGVuZCgpXCIpO1xuICAgICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJlc29sdmUoeyB2YWx1ZSwgZG9uZTogZmFsc2UsIGFwcGVuZDogdHJ1ZSwgbmV4dDogcmVzb2x2YWJsZS5wcm9taXNlIH0pO1xuICAgICAgcmVzb2x2ZSA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlamVjdCA9IHJlc29sdmFibGUucmVqZWN0O1xuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNpZ25hbCB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSBVSSBzdHJlYW0uXG4gICAgICogSXQgd2lsbCBiZSB0aHJvd24gb24gdGhlIGNsaWVudCBzaWRlIGFuZCBjYXVnaHQgYnkgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGVycm9yKGVycm9yKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oXCIuZXJyb3IoKVwiKTtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXJrcyB0aGUgVUkgbm9kZSBhcyBmaW5hbGl6ZWQuIFlvdSBjYW4gZWl0aGVyIGNhbGwgaXQgd2l0aG91dCBhbnkgcGFyYW1ldGVycyBvciB3aXRoIGEgbmV3IFVJIG5vZGUgYXMgdGhlIGZpbmFsIHN0YXRlLlxuICAgICAqIE9uY2UgY2FsbGVkLCB0aGUgVUkgbm9kZSBjYW5ub3QgYmUgdXBkYXRlZCBvciBhcHBlbmRlZCBhbnltb3JlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgYWx3YXlzICoqcmVxdWlyZWQqKiB0byBiZSBjYWxsZWQsIG90aGVyd2lzZSB0aGUgcmVzcG9uc2Ugd2lsbCBiZSBzdHVjayBpbiBhIGxvYWRpbmcgc3RhdGUuXG4gICAgICovXG4gICAgZG9uZSguLi5hcmdzKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oXCIuZG9uZSgpXCIpO1xuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJlc29sdmUoeyB2YWx1ZTogYXJnc1swXSwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBjdXJyZW50VmFsdWUsIGRvbmU6IHRydWUgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtYWJsZVZhbHVlKGluaXRpYWxWYWx1ZSkge1xuICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gIGxldCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGV0IGN1cnJlbnRFcnJvcjtcbiAgbGV0IGN1cnJlbnRQcm9taXNlID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICBsZXQgY3VycmVudFBhdGNoVmFsdWU7XG4gIGZ1bmN0aW9uIGFzc2VydFN0cmVhbShtZXRob2QpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgXCI6IFZhbHVlIHN0cmVhbSBpcyBhbHJlYWR5IGNsb3NlZC5cIik7XG4gICAgfVxuICB9XG4gIGxldCB3YXJuaW5nVGltZW91dDtcbiAgZnVuY3Rpb24gd2FyblVuY2xvc2VkU3RyZWFtKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBzdHJlYW1hYmxlIFVJIGhhcyBiZWVuIHNsb3cgdG8gdXBkYXRlLiBUaGlzIG1heSBiZSBhIGJ1ZyBvciBhIHBlcmZvcm1hbmNlIGlzc3VlIG9yIHlvdSBmb3Jnb3QgdG8gY2FsbCBgLmRvbmUoKWAuXCJcbiAgICAgICAgKTtcbiAgICAgIH0sIERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FKTtcbiAgICB9XG4gIH1cbiAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZWQoaW5pdGlhbENodW5rKSB7XG4gICAgbGV0IGluaXQ7XG4gICAgaWYgKGN1cnJlbnRFcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICBpbml0ID0geyBlcnJvcjogY3VycmVudEVycm9yIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50UGF0Y2hWYWx1ZSAmJiAhaW5pdGlhbENodW5rKSB7XG4gICAgICAgIGluaXQgPSB7IGRpZmY6IGN1cnJlbnRQYXRjaFZhbHVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0ID0geyBjdXJyOiBjdXJyZW50VmFsdWUgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQcm9taXNlKSB7XG4gICAgICBpbml0Lm5leHQgPSBjdXJyZW50UHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKGluaXRpYWxDaHVuaykge1xuICAgICAgaW5pdC50eXBlID0gU1RSRUFNQUJMRV9WQUxVRV9UWVBFO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVWYWx1ZVN0YXRlcyh2YWx1ZSkge1xuICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gdm9pZCAwO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IFswLCB2YWx1ZS5zbGljZShjdXJyZW50VmFsdWUubGVuZ3RoKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUuIFRoaXMgY2FuIGJlIHJldHVybmVkIGZyb20gYSBTZXJ2ZXIgQWN0aW9uIGFuZFxuICAgICAqIHJlY2VpdmVkIGJ5IHRoZSBjbGllbnQuIFRvIHJlYWQgdGhlIHN0cmVhbWVkIHZhbHVlcywgdXNlIHRoZVxuICAgICAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYCBBUElzLlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVkKHRydWUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCB2YWx1ZSB3aXRoIGEgbmV3IG9uZS5cbiAgICAgKi9cbiAgICB1cGRhdGUodmFsdWUpIHtcbiAgICAgIGFzc2VydFN0cmVhbShcIi51cGRhdGUoKVwiKTtcbiAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgdXBkYXRlVmFsdWVTdGF0ZXModmFsdWUpO1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgICByZXNvbHZlUHJldmlvdXMoY3JlYXRlV3JhcHBlZCgpKTtcbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuICAgIH0sXG4gICAgZXJyb3IoZXJyb3IpIHtcbiAgICAgIGFzc2VydFN0cmVhbShcIi5lcnJvcigpXCIpO1xuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgY3VycmVudEVycm9yID0gZXJyb3I7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh7IGVycm9yIH0pO1xuICAgIH0sXG4gICAgZG9uZSguLi5hcmdzKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oXCIuZG9uZSgpXCIpO1xuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgY3VycmVudFByb21pc2UgPSB2b2lkIDA7XG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdXBkYXRlVmFsdWVTdGF0ZXMoYXJnc1swXSk7XG4gICAgICAgIHJlc29sdmFibGUucmVzb2x2ZShjcmVhdGVXcmFwcGVkKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUoe30pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihvcHRpb25zKSB7XG4gIGNvbnN0IHVpID0gY3JlYXRlU3RyZWFtYWJsZVVJKG9wdGlvbnMuaW5pdGlhbCk7XG4gIGNvbnN0IHRleHQgPSBvcHRpb25zLnRleHQgPyBvcHRpb25zLnRleHQgOiAoeyBjb250ZW50IH0pID0+IGNvbnRlbnQ7XG4gIGNvbnN0IGZ1bmN0aW9ucyA9IG9wdGlvbnMuZnVuY3Rpb25zID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy5mdW5jdGlvbnMpLm1hcChcbiAgICAoW25hbWUsIHsgZGVzY3JpcHRpb24sIHBhcmFtZXRlcnMgfV0pID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBwYXJhbWV0ZXJzOiB6b2RUb0pzb25TY2hlbWEyKHBhcmFtZXRlcnMpXG4gICAgICB9O1xuICAgIH1cbiAgKSA6IHZvaWQgMDtcbiAgY29uc3QgdG9vbHMgPSBvcHRpb25zLnRvb2xzID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy50b29scykubWFwKFxuICAgIChbbmFtZSwgeyBkZXNjcmlwdGlvbiwgcGFyYW1ldGVycyB9XSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgcGFyYW1ldGVyczogem9kVG9Kc29uU2NoZW1hMihwYXJhbWV0ZXJzKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgKSA6IHZvaWQgMDtcbiAgaWYgKGZ1bmN0aW9ucyAmJiB0b29scykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbid0IGhhdmUgYm90aCBmdW5jdGlvbnMgYW5kIHRvb2xzIGRlZmluZWQuIFBsZWFzZSBjaG9vc2Ugb25lIG9yIHRoZSBvdGhlci5cIlxuICAgICk7XG4gIH1cbiAgbGV0IGZpbmlzaGVkO1xuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVSZW5kZXIoYXJncywgcmVuZGVyZXIsIHJlcykge1xuICAgIGlmICghcmVuZGVyZXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICBmaW5pc2hlZCA9IGZpbmlzaGVkLnRoZW4oKCkgPT4gcmVzb2x2YWJsZS5wcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoZWQgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcmVuZGVyZXIoYXJncyk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSB8fCB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3Qgbm9kZSA9IGF3YWl0IHZhbHVlO1xuICAgICAgcmVzLnVwZGF0ZShub2RlKTtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZTogdmFsdWUyIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUyKTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWU7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiB2YWx1ZTIgfSA9IGl0Lm5leHQoKTtcbiAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZTIpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH1cbiAgfVxuICAoYXN5bmMgKCkgPT4ge1xuICAgIGxldCBoYXNGdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50ID0gXCJcIjtcbiAgICBjb25zdW1lU3RyZWFtKFxuICAgICAgT3BlbkFJU3RyZWFtKFxuICAgICAgICBhd2FpdCBvcHRpb25zLnByb3ZpZGVyLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgICAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgICAgLi4uZnVuY3Rpb25zID8ge1xuICAgICAgICAgICAgZnVuY3Rpb25zXG4gICAgICAgICAgfSA6IHt9LFxuICAgICAgICAgIC4uLnRvb2xzID8ge1xuICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICB9IDoge31cbiAgICAgICAgfSksXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5mdW5jdGlvbnMgPyB7XG4gICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZnVuY3Rpb25DYWxsUGF5bG9hZCkge1xuICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICBoYXNGdW5jdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxQYXlsb2FkLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBvcHRpb25zLmZ1bmN0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2Z1bmN0aW9uQ2FsbFBheWxvYWQubmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5yZW5kZXIsXG4gICAgICAgICAgICAgICAgdWlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgLi4udG9vbHMgPyB7XG4gICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25Ub29sQ2FsbCh0b29sQ2FsbFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgaGFzRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbENhbGxQYXlsb2FkLnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICAgICAgdG9vbC5mdW5jLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IG9wdGlvbnMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYVt0b29sLmZ1bmMubmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5yZW5kZXIsXG4gICAgICAgICAgICAgICAgICB1aVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgb25UZXh0KGNodW5rKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IGNodW5rO1xuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKHsgY29udGVudCwgZG9uZTogZmFsc2UsIGRlbHRhOiBjaHVuayB9LCB0ZXh0LCB1aSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBvbkZpbmFsKCkge1xuICAgICAgICAgICAgaWYgKGhhc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcih7IGNvbnRlbnQsIGRvbmU6IHRydWUgfSwgdGV4dCwgdWkpO1xuICAgICAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSkoKTtcbiAgcmV0dXJuIHVpLnZhbHVlO1xufVxuXG4vLyByc2Mvc3RyZWFtLXVpL3N0cmVhbS11aS50c3hcbmltcG9ydCB7XG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgZGVmYXVsdFRleHRSZW5kZXJlciA9ICh7IGNvbnRlbnQgfSkgPT4gY29udGVudDtcbmFzeW5jIGZ1bmN0aW9uIGV4cGVyaW1lbnRhbF9zdHJlYW1VSSh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaW5pdGlhbCxcbiAgdGV4dCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgaWYgKHR5cGVvZiBtb2RlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYG1vZGVsYCBjYW5ub3QgYmUgYSBzdHJpbmcgaW4gYGV4cGVyaW1lbnRhbF9zdHJlYW1VSWAuIFVzZSB0aGUgYWN0dWFsIG1vZGVsIGluc3RhbmNlIGluc3RlYWQuXCJcbiAgICApO1xuICB9XG4gIGlmIChcImZ1bmN0aW9uc1wiIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgZnVuY3Rpb25zYCBpcyBub3Qgc3VwcG9ydGVkIGluIGBleHBlcmltZW50YWxfc3RyZWFtVUlgLCB1c2UgYHRvb2xzYCBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgfVxuICBpZiAoXCJwcm92aWRlclwiIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgcHJvdmlkZXJgIGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gYGV4cGVyaW1lbnRhbF9zdHJlYW1VSWAuIFVzZSBgbW9kZWxgIGluc3RlYWQuXCJcbiAgICApO1xuICB9XG4gIGlmICh0b29scykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHRvb2xdIG9mIE9iamVjdC5lbnRyaWVzKHRvb2xzKSkge1xuICAgICAgaWYgKFwicmVuZGVyXCIgaW4gdG9vbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJUb29sIGRlZmluaXRpb24gaW4gYGV4cGVyaW1lbnRhbF9zdHJlYW1VSWAgc2hvdWxkIG5vdCBoYXZlIGByZW5kZXJgIHByb3BlcnR5LiBVc2UgYGdlbmVyYXRlYCBpbnN0ZWFkLiBGb3VuZCBpbiB0b29sOiBcIiArIG5hbWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkoaW5pdGlhbCk7XG4gIGNvbnN0IHRleHRSZW5kZXIgPSB0ZXh0IHx8IGRlZmF1bHRUZXh0UmVuZGVyZXI7XG4gIGxldCBmaW5pc2hlZDtcbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVuZGVyKGFyZ3MsIHJlbmRlcmVyLCByZXMpIHtcbiAgICBpZiAoIXJlbmRlcmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgZmluaXNoZWQgPSBmaW5pc2hlZC50aGVuKCgpID0+IHJlc29sdmFibGUucHJvbWlzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaGVkID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHJlbmRlcmVyKC4uLmFyZ3MpO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgfHwgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhd2FpdCB2YWx1ZTtcbiAgICAgIHJlcy51cGRhdGUobm9kZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWU6IHZhbHVlMiB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgICByZXMudXBkYXRlKHZhbHVlMik7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZTogdmFsdWUyIH0gPSBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUyKTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICgpID0+IG1vZGVsLmRvU3RyZWFtKHtcbiAgICAgIG1vZGU6IHtcbiAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgIHRvb2xzOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUsIHRvb2xdKSA9PiAoe1xuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IGNvbnZlcnRab2RUb0pTT05TY2hlbWEodG9vbC5wYXJhbWV0ZXJzKVxuICAgICAgICB9KSlcbiAgICAgIH0sXG4gICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KVxuICApO1xuICBjb25zdCBbc3RyZWFtLCBmb3JrZWRTdHJlYW1dID0gcmVzdWx0LnN0cmVhbS50ZWUoKTtcbiAgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGNvbnRlbnQgPSBcIlwiO1xuICAgICAgbGV0IGhhc1Rvb2xDYWxsID0gZmFsc2U7XG4gICAgICBjb25zdCByZWFkZXIgPSBmb3JrZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjoge1xuICAgICAgICAgICAgY29udGVudCArPSB2YWx1ZS50ZXh0RGVsdGE7XG4gICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgIFt7IGNvbnRlbnQsIGRvbmU6IGZhbHNlLCBkZWx0YTogdmFsdWUudGV4dERlbHRhIH1dLFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVyLFxuICAgICAgICAgICAgICB1aVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICAgIGhhc1Rvb2xDYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gdmFsdWUudG9vbE5hbWU7XG4gICAgICAgICAgICBpZiAoIXRvb2xzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvb2wgPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgICBpZiAoIXRvb2wpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgICAgIHNjaGVtYTogdG9vbC5wYXJhbWV0ZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwYXJzZVJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgdG9vbEFyZ3M6IHZhbHVlLmFyZ3MsXG4gICAgICAgICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB2YWx1ZS50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICB0b29sLmdlbmVyYXRlLFxuICAgICAgICAgICAgICB1aVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgdGhyb3cgdmFsdWUuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc1Rvb2xDYWxsKSB7XG4gICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICB1aS5kb25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVSZW5kZXIoW3sgY29udGVudCwgZG9uZTogdHJ1ZSB9XSwgdGV4dFJlbmRlciwgdWkpO1xuICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgdWkuZG9uZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB1aS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9KSgpO1xuICByZXR1cm4ge1xuICAgIC4uLnJlc3VsdCxcbiAgICBzdHJlYW0sXG4gICAgdmFsdWU6IHVpLnZhbHVlXG4gIH07XG59XG5cbi8vIHJzYy9wcm92aWRlci50c3hcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEludGVybmFsQUlQcm92aWRlciB9IGZyb20gXCIuL3JzYy1zaGFyZWQubWpzXCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuYXN5bmMgZnVuY3Rpb24gaW5uZXJBY3Rpb24oe1xuICBhY3Rpb24sXG4gIG9wdGlvbnNcbn0sIHN0YXRlLCAuLi5hcmdzKSB7XG4gIFwidXNlIHNlcnZlclwiO1xuICByZXR1cm4gYXdhaXQgd2l0aEFJU3RhdGUoXG4gICAge1xuICAgICAgc3RhdGUsXG4gICAgICBvcHRpb25zXG4gICAgfSxcbiAgICBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhY3Rpb24oLi4uYXJncyk7XG4gICAgICBzZWFsTXV0YWJsZUFJU3RhdGUoKTtcbiAgICAgIHJldHVybiBbZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSgpLCByZXN1bHRdO1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHdyYXBBY3Rpb24oYWN0aW9uLCBvcHRpb25zKSB7XG4gIHJldHVybiBpbm5lckFjdGlvbi5iaW5kKG51bGwsIHsgYWN0aW9uLCBvcHRpb25zIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQUkoe1xuICBhY3Rpb25zLFxuICBpbml0aWFsQUlTdGF0ZSxcbiAgaW5pdGlhbFVJU3RhdGUsXG4gIG9uU2V0QUlTdGF0ZSxcbiAgb25HZXRVSVN0YXRlXG59KSB7XG4gIGNvbnN0IHdyYXBwZWRBY3Rpb25zID0ge307XG4gIGZvciAoY29uc3QgbmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgd3JhcHBlZEFjdGlvbnNbbmFtZV0gPSB3cmFwQWN0aW9uKGFjdGlvbnNbbmFtZV0sIHtcbiAgICAgIG9uU2V0QUlTdGF0ZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHdyYXBwZWRTeW5jVUlTdGF0ZSA9IG9uR2V0VUlTdGF0ZSA/IHdyYXBBY3Rpb24ob25HZXRVSVN0YXRlLCB7fSkgOiB2b2lkIDA7XG4gIGNvbnN0IEFJID0gYXN5bmMgKHByb3BzKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoXCJ1c2VTdGF0ZVwiIGluIFJlYWN0Mikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRoaXMgY29tcG9uZW50IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIFNlcnZlciBDb21wb25lbnRzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgdWlTdGF0ZSA9IChfYSA9IHByb3BzLmluaXRpYWxVSVN0YXRlKSAhPSBudWxsID8gX2EgOiBpbml0aWFsVUlTdGF0ZTtcbiAgICBsZXQgYWlTdGF0ZSA9IChfYiA9IHByb3BzLmluaXRpYWxBSVN0YXRlKSAhPSBudWxsID8gX2IgOiBpbml0aWFsQUlTdGF0ZTtcbiAgICBsZXQgYWlTdGF0ZURlbHRhID0gdm9pZCAwO1xuICAgIGlmICh3cmFwcGVkU3luY1VJU3RhdGUpIHtcbiAgICAgIGNvbnN0IFtuZXdBSVN0YXRlRGVsdGEsIG5ld1VJU3RhdGVdID0gYXdhaXQgd3JhcHBlZFN5bmNVSVN0YXRlKGFpU3RhdGUpO1xuICAgICAgaWYgKG5ld1VJU3RhdGUgIT09IHZvaWQgMCkge1xuICAgICAgICBhaVN0YXRlRGVsdGEgPSBuZXdBSVN0YXRlRGVsdGE7XG4gICAgICAgIHVpU3RhdGUgPSBuZXdVSVN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgICBJbnRlcm5hbEFJUHJvdmlkZXIsXG4gICAgICB7XG4gICAgICAgIHdyYXBwZWRBY3Rpb25zLFxuICAgICAgICB3cmFwcGVkU3luY1VJU3RhdGUsXG4gICAgICAgIGluaXRpYWxVSVN0YXRlOiB1aVN0YXRlLFxuICAgICAgICBpbml0aWFsQUlTdGF0ZTogYWlTdGF0ZSxcbiAgICAgICAgaW5pdGlhbEFJU3RhdGVQYXRjaDogYWlTdGF0ZURlbHRhLFxuICAgICAgICBjaGlsZHJlbjogcHJvcHMuY2hpbGRyZW5cbiAgICAgIH1cbiAgICApO1xuICB9O1xuICByZXR1cm4gQUk7XG59XG5leHBvcnQge1xuICBjcmVhdGVBSSxcbiAgY3JlYXRlU3RyZWFtYWJsZVVJLFxuICBjcmVhdGVTdHJlYW1hYmxlVmFsdWUsXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1VSSxcbiAgZ2V0QUlTdGF0ZSxcbiAgZ2V0TXV0YWJsZUFJU3RhdGUsXG4gIHJlbmRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJzYy1zZXJ2ZXIubWpzLm1hcCJdLCJuYW1lcyI6WyJBc3luY0xvY2FsU3RvcmFnZSIsImpzb25kaWZmcGF0Y2giLCJTdXNwZW5zZSIsIkZyYWdtZW50IiwianN4IiwianN4cyIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiUiIsImMiLCJuIiwiY2h1bmsiLCJkb25lIiwidmFsdWUiLCJhcHBlbmQiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwibmV4dCIsImNyZWF0ZVN1c3BlbnNlZENodW5rIiwiaW5pdGlhbFZhbHVlIiwicm93IiwiaXNGdW5jdGlvbiIsIngiLCJjb25zdW1lU3RyZWFtIiwic3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwicmVhZCIsImFzeW5jQUlTdGF0ZVN0b3JhZ2UiLCJnZXRBSVN0YXRlU3RvcmVPclRocm93IiwibWVzc2FnZSIsInN0b3JlIiwiZ2V0U3RvcmUiLCJFcnJvciIsIndpdGhBSVN0YXRlIiwic3RhdGUiLCJvcHRpb25zIiwiZm4iLCJydW4iLCJjdXJyZW50U3RhdGUiLCJvcmlnaW5hbFN0YXRlIiwic2VhbGVkIiwiZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSIsIm11dGF0aW9uRGVsdGFQcm9taXNlIiwic2VhbE11dGFibGVBSVN0YXRlIiwiZ2V0QUlTdGF0ZSIsImFyZ3MiLCJsZW5ndGgiLCJrZXkiLCJTdHJpbmciLCJnZXRNdXRhYmxlQUlTdGF0ZSIsIm11dGF0aW9uRGVsdGFSZXNvbHZlIiwiZG9VcGRhdGUiLCJuZXdTdGF0ZSIsIl9hIiwiX2IiLCJvblNldEFJU3RhdGUiLCJjYWxsIiwibXV0YWJsZVN0YXRlIiwiZ2V0IiwidXBkYXRlIiwibmV3QUlTdGF0ZSIsImRvbmVBcmdzIiwiZGVsdGEiLCJkaWZmIiwiem9kVG9Kc29uU2NoZW1hMiIsIm1pbWVUeXBlU2lnbmF0dXJlcyIsIm1pbWVUeXBlIiwiYnl0ZXMiLCJkZXRlY3RJbWFnZU1pbWVUeXBlIiwiaW1hZ2UiLCJldmVyeSIsImJ5dGUiLCJpbmRleCIsIkludmFsaWREYXRhQ29udGVudEVycm9yIiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQiLCJjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkiLCJjb250ZW50IiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCIsInByb21wdCIsImxhbmd1YWdlTW9kZWxNZXNzYWdlcyIsInN5c3RlbSIsInB1c2giLCJyb2xlIiwidHlwZSIsInRleHQiLCJtZXNzYWdlcyIsIm1hcCIsInBhcnQiLCJVUkwiLCJpbWFnZVVpbnQ4IiwiX2V4aGF1c3RpdmVDaGVjayIsIkludmFsaWRQcm9tcHRFcnJvciIsImdldFZhbGlkYXRlZFByb21wdCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicHJlcGFyZUNhbGxTZXR0aW5ncyIsIm1heFRva2VucyIsInRlbXBlcmF0dXJlIiwidG9wUCIsInByZXNlbmNlUGVuYWx0eSIsImZyZXF1ZW5jeVBlbmFsdHkiLCJzZWVkIiwibWF4UmV0cmllcyIsIk51bWJlciIsImlzSW50ZWdlciIsInBhcmFtZXRlciIsInpvZFRvSnNvblNjaGVtYSIsImNvbnZlcnRab2RUb0pTT05TY2hlbWEiLCJ6b2RTY2hlbWEiLCJBUElDYWxsRXJyb3IiLCJSZXRyeUVycm9yIiwiZ2V0RXJyb3JNZXNzYWdlIiwiaXNBYm9ydEVycm9yIiwiZGVsYXkiLCJkZWxheUluTXMiLCJzZXRUaW1lb3V0IiwicmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiaW5pdGlhbERlbGF5SW5NcyIsImJhY2tvZmZGYWN0b3IiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImVycm9ycyIsImVycm9yIiwiZXJyb3JNZXNzYWdlIiwibmV3RXJyb3JzIiwidHJ5TnVtYmVyIiwicmVhc29uIiwiaXNBUElDYWxsRXJyb3IiLCJpc1JldHJ5YWJsZSIsInRleHRTdHJlYW1QYXJ0IiwiY29kZSIsIm5hbWUiLCJwYXJzZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCIsImlkIiwiaXRlbSIsImFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCIsInRocmVhZElkIiwibWVzc2FnZUlkIiwiZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0IiwidG9vbENhbGxTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInN0cmVhbVBhcnRzIiwic3RyZWFtUGFydHNCeUNvZGUiLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsInZhbGlkQ29kZXMiLCJwYXJzZVN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJzbGljZSIsImluY2x1ZGVzIiwidGV4dFZhbHVlIiwianNvblZhbHVlIiwiSlNPTiIsImZvcm1hdFN0cmVhbVBhcnQiLCJzdHJlYW1QYXJ0IiwiZmluZCIsInN0cmluZ2lmeSIsImNyZWF0ZUNodW5rRGVjb2RlciIsImNvbXBsZXgiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJkZWNvZGVkIiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiY3JlYXRlUGFyc2VyIiwiY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lciIsImN1c3RvbVBhcnNlciIsInRleHREZWNvZGVyIiwiZXZlbnRTb3VyY2VQYXJzZXIiLCJUcmFuc2Zvcm1TdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXIiLCJldmVudCIsImRhdGEiLCJ0ZXJtaW5hdGUiLCJwYXJzZWRNZXNzYWdlIiwiZW5xdWV1ZSIsInRyYW5zZm9ybSIsImZlZWQiLCJjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lciIsImNiIiwidGV4dEVuY29kZXIiLCJUZXh0RW5jb2RlciIsImFnZ3JlZ2F0ZWRSZXNwb25zZSIsImNhbGxiYWNrcyIsIm9uU3RhcnQiLCJlbmNvZGUiLCJvblRva2VuIiwib25UZXh0IiwiZmx1c2giLCJpc09wZW5BSUNhbGxiYWNrcyIsImlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIiwib25Db21wbGV0aW9uIiwib25GaW5hbCIsInRyaW1TdGFydE9mU3RyZWFtSGVscGVyIiwiaXNTdHJlYW1TdGFydCIsInRyaW1TdGFydCIsIkFJU3RyZWFtIiwicmVzcG9uc2UiLCJvayIsImJvZHkiLCJSZWFkYWJsZVN0cmVhbSIsImVycm9yVGV4dCIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJwaXBlVGhyb3VnaCIsImNsb3NlIiwicmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwicHVsbCIsImNhbmNlbCIsInJldHVybiIsImNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciIsImVuY29kZXIiLCJwYXJzZU9wZW5BSVN0cmVhbSIsImV4dHJhY3QiLCJjaHVua1RvVGV4dCIsInN0cmVhbWFibGUiLCJjcmVhdGVkIiwiZ2V0RGF0ZSIsIm9iamVjdCIsIm1vZGVsIiwiY2hvaWNlcyIsImNob2ljZSIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJmdW5jdGlvbkNhbGwiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsImZpbmlzaF9yZWFzb24iLCJmaW5pc2hSZWFzb24iLCJ0cmltU3RhcnRPZlN0cmVhbSIsImlzRnVuY3Rpb25TdHJlYW1pbmdJbiIsImpzb24iLCJfaCIsIl9pIiwiX2oiLCJfayIsIl9sIiwiX20iLCJfbiIsIl9vIiwiX3AiLCJfcSIsIl9yIiwiaXNDaGF0Q29tcGxldGlvbkNodW5rIiwiaXNUZXh0IiwiY2xlYW51cEFyZ3VtZW50cyIsImlzQ29tcGxldGlvbiIsImFyZ3VtZW50Q2h1bmsiLCJlc2NhcGVkUGFydGlhbEpzb24iLCJyZXBsYWNlIiwiX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCIsIk9wZW5BSVN0cmVhbSIsImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCIsImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIiwiZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIiLCJjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImlzRmlyc3RDaHVuayIsImFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSIsImZ1bmN0aW9uQ2FsbE1lc3NhZ2VzIiwic2hvdWxkSGFuZGxlQXNGdW5jdGlvbiIsInN0YXJ0c1dpdGgiLCJwYXlsb2FkIiwibmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJmdW5jdGlvblJlc3BvbnNlIiwiY29uc29sZSIsIndhcm4iLCJhcmd1bWVudHNQYXlsb2FkIiwicmVzdWx0IiwidG9vbHMiLCJ0b29sIiwiZnVuYyIsInJlc3BvbnNlSW5kZXgiLCJ0b29sX2NhbGxfaWQiLCJmdW5jdGlvbl9uYW1lIiwidG9vbF9jYWxsX3Jlc3VsdCIsImUiLCJmaWx0ZXJlZENhbGxiYWNrcyIsIm9wZW5BSVN0cmVhbSIsIlNUUkVBTUFCTEVfVkFMVUVfVFlQRSIsImZvciIsIkRFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FIiwiY3JlYXRlU3RyZWFtYWJsZVVJIiwiY3VycmVudFZhbHVlIiwiY2xvc2VkIiwiYXNzZXJ0U3RyZWFtIiwibWV0aG9kIiwid2FybmluZ1RpbWVvdXQiLCJ3YXJuVW5jbG9zZWRTdHJlYW0iLCJwcm9jZXNzIiwiY2xlYXJUaW1lb3V0IiwicmVzb2x2YWJsZSIsImNyZWF0ZVN0cmVhbWFibGVWYWx1ZSIsImN1cnJlbnRFcnJvciIsImN1cnJlbnRQcm9taXNlIiwiY3VycmVudFBhdGNoVmFsdWUiLCJjcmVhdGVXcmFwcGVkIiwiaW5pdGlhbENodW5rIiwiaW5pdCIsImN1cnIiLCJ1cGRhdGVWYWx1ZVN0YXRlcyIsInJlc29sdmVQcmV2aW91cyIsInJlbmRlciIsInVpIiwiaW5pdGlhbCIsImZ1bmN0aW9ucyIsIk9iamVjdCIsImVudHJpZXMiLCJkZXNjcmlwdGlvbiIsInBhcmFtZXRlcnMiLCJmaW5pc2hlZCIsImhhbmRsZVJlbmRlciIsInJlbmRlcmVyIiwidGhlbiIsIm5vZGUiLCJ2YWx1ZTIiLCJpdGVyYXRvciIsImhhc0Z1bmN0aW9uIiwicHJvdmlkZXIiLCJjaGF0IiwiY29tcGxldGlvbnMiLCJjcmVhdGUiLCJmdW5jdGlvbkNhbGxQYXlsb2FkIiwidG9vbENhbGxQYXlsb2FkIiwiSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciIsIk5vU3VjaFRvb2xFcnJvciIsInNhZmVQYXJzZUpTT04iLCJkZWZhdWx0VGV4dFJlbmRlcmVyIiwiZXhwZXJpbWVudGFsX3N0cmVhbVVJIiwiYWJvcnRTaWduYWwiLCJzZXR0aW5ncyIsInRleHRSZW5kZXIiLCJyZXRyeSIsInZhbGlkYXRlZFByb21wdCIsImRvU3RyZWFtIiwibW9kZSIsImlucHV0Rm9ybWF0IiwiZm9ya2VkU3RyZWFtIiwidGVlIiwiaGFzVG9vbENhbGwiLCJ0ZXh0RGVsdGEiLCJ0b29sTmFtZSIsImF2YWlsYWJsZVRvb2xzIiwia2V5cyIsInBhcnNlUmVzdWx0Iiwic2NoZW1hIiwic3VjY2VzcyIsInRvb2xBcmdzIiwiY2F1c2UiLCJ0b29sQ2FsbElkIiwiZ2VuZXJhdGUiLCJSZWFjdDIiLCJJbnRlcm5hbEFJUHJvdmlkZXIiLCJqc3gyIiwiaW5uZXJBY3Rpb24iLCJhY3Rpb24iLCJ3cmFwQWN0aW9uIiwiYmluZCIsImNyZWF0ZUFJIiwiYWN0aW9ucyIsImluaXRpYWxBSVN0YXRlIiwiaW5pdGlhbFVJU3RhdGUiLCJvbkdldFVJU3RhdGUiLCJ3cmFwcGVkQWN0aW9ucyIsIndyYXBwZWRTeW5jVUlTdGF0ZSIsIkFJIiwicHJvcHMiLCJ1aVN0YXRlIiwiYWlTdGF0ZSIsImFpU3RhdGVEZWx0YSIsIm5ld0FJU3RhdGVEZWx0YSIsIm5ld1VJU3RhdGUiLCJpbml0aWFsQUlTdGF0ZVBhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ e0),
/* harmony export */   readStreamableValue: () => (/* binding */ e1),
/* harmony export */   useAIState: () => (/* binding */ e2),
/* harmony export */   useActions: () => (/* binding */ e3),
/* harmony export */   useStreamableValue: () => (/* binding */ e4),
/* harmony export */   useSyncUIState: () => (/* binding */ e5),
/* harmony export */   useUIState: () => (/* binding */ e6)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#InternalAIProvider`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#readStreamableValue`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useAIState`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useActions`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useStreamableValue`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useSyncUIState`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/matt/Desktop/Projects/meal_planner/node_modules/ai/rsc/dist/rsc-shared.mjs#useUIState`);


/***/ })

};
;